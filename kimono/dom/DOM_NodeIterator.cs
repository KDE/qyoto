//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  NodeIterators are used to step through a set of nodes, e.g. the set
	///  of nodes in an ArrayList, the document subtree governed by a
	///  particular node, the results of a query, or any other set of nodes.
	///  The set of nodes to be iterated is determined by the implementation
	///  of the NodeIterator. DOM Level 2 specifies a single NodeIterator
	///  implementation for document-order traversal of a document subtree.
	///  Instances of these iterators are created by calling
	///  DocumentTraversal.createNodeIterator().
	///   Any Iterator that returns nodes may implement the
	///  <code>NodeIterator</code> interface. Users and vendor libraries may also
	///  choose to create Iterators that implement the <code>NodeIterator</code>
	///  interface.
	///  </remarks>		<short>    NodeIterators are used to step through a set of nodes, e.</short>

	[SmokeClass("DOM::NodeIterator")]
	public class NodeIterator : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected NodeIterator(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(NodeIterator), this);
		}
		// DOM::NodeIterator* NodeIterator(DOM::NodeIteratorImpl* arg1); >>>> NOT CONVERTED
		public NodeIterator() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("NodeIterator", "NodeIterator()", typeof(void));
		}
		public NodeIterator(DOM.NodeIterator other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("NodeIterator#", "NodeIterator(const DOM::NodeIterator&)", typeof(void), typeof(DOM.NodeIterator), other);
		}
		/// <remarks>
		///  The root node of the NodeIterator, as specified when it was created.
		///      </remarks>		<short>    The root node of the NodeIterator, as specified when it was created.</short>
		public DOM.Node Root() {
			return (DOM.Node) interceptor.Invoke("root", "root()", typeof(DOM.Node));
		}
		/// <remarks>
		///  This attribute determines which node types are presented via the
		///  iterator. The available set of constants is defined in the NodeFilter
		///  interface. Nodes not accepted by whatToShow will be skipped, but their
		///  children may still be considered. Note that this skip takes precedence
		///  over the filter, if any.
		///     </remarks>		<short>    This attribute determines which node types are presented via the  iterator.</short>
		public ulong WhatToShow() {
			return (ulong) interceptor.Invoke("whatToShow", "whatToShow()", typeof(ulong));
		}
		/// <remarks>
		///  The NodeFilter used to screen nodes.
		///      </remarks>		<short>    The NodeFilter used to screen nodes.</short>
		public DOM.NodeFilter Filter() {
			return (DOM.NodeFilter) interceptor.Invoke("filter", "filter()", typeof(DOM.NodeFilter));
		}
		/// <remarks>
		///  The value of this flag determines whether the children of entity
		///  reference nodes are visible to the iterator. If false, they and
		///  their descendents will be rejected. Note that this rejection takes
		///  precedence over whatToShow and the filter. Also note that this is
		///  currently the only situation where NodeIterators may reject a complete
		///  subtree rather than skipping individual nodes.
		///  To produce a view of the document that has entity references expanded
		///  and does not expose the entity reference node itself, use the whatToShow
		///  flags to hide the entity reference node and set expandEntityReferences to
		///  true when creating the iterator. To produce a view of the document that
		///  has entity reference nodes but no entity expansion, use the whatToShow
		///  flags to show the entity reference node and set expandEntityReferences to
		///  false.
		///      </remarks>		<short>    The value of this flag determines whether the children of entity  reference nodes are visible to the iterator.</short>
		public bool ExpandEntityReferences() {
			return (bool) interceptor.Invoke("expandEntityReferences", "expandEntityReferences()", typeof(bool));
		}
		/// <remarks>
		///  Returns the next node in the set and advances the position of
		///  the Iterator in the set. After a NodeIterator is created, the
		///  first call to nextNode() returns the first node in the set.
		///      </remarks>		<return> The next <code>Node</code> in the set being iterated
		///  over, or <code>null</code> if there are no more members in
		///  that set.
		/// </return>
		/// 		<short>    Returns the next node in the set and advances the position of  the Iterator in the set.</short>
		public DOM.Node NextNode() {
			return (DOM.Node) interceptor.Invoke("nextNode", "nextNode()", typeof(DOM.Node));
		}
		/// <remarks>
		///  Returns the previous node in the set and moves the position of
		///  the Iterator backwards in the set.
		///      </remarks>		<return> The previous <code>Node</code> in the set being
		///  iterated over, or <code>null</code> if there are no more
		///  members in that set.
		/// </return>
		/// 		<short>    Returns the previous node in the set and moves the position of  the Iterator backwards in the set.</short>
		public DOM.Node PreviousNode() {
			return (DOM.Node) interceptor.Invoke("previousNode", "previousNode()", typeof(DOM.Node));
		}
		/// <remarks>
		///  Detaches the NodeIterator from the set which it iterated over,
		///  releasing any computational resources and placing the iterator in the
		///  INVALID state. After detach has been invoked, calls to nextNode or
		///  previousNode will raise the exception INVALID_STATE_ERR.
		///      </remarks>		<short>    Detaches the NodeIterator from the set which it iterated over,  releasing any computational resources and placing the iterator in the  INVALID state.</short>
		public void Detach() {
			interceptor.Invoke("detach", "detach()", typeof(void));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		~NodeIterator() {
			interceptor.Invoke("~NodeIterator", "~NodeIterator()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~NodeIterator", "~NodeIterator()", typeof(void));
		}
	}
	}
}
