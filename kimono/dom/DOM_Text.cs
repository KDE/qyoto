//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  The <code>Text</code> interface represents the textual content
	///  (termed <a href="&xml-spec;#syntax"> character data </a> in XML) of
	///  an <code>Element</code> or <code>Attr</code> . If there is no
	///  markup inside an element's content, the text is contained in a
	///  single object implementing the <code>Text</code> interface that
	///  is the only child of the element. If there is markup, it is parsed
	///  into a list of elements and <code>Text</code> nodes that form the
	///  list of children of the element.
	///   When a document is first made available via the DOM, there is only
	///  one <code>Text</code> node for each block of text. Users may
	///  create adjacent <code>Text</code> nodes that represent the
	///  contents of a given element without any intervening markup, but
	///  should be aware that there is no way to represent the separations
	///  between these nodes in XML or HTML, so they will not (in general)
	///  persist between DOM editing sessions. The <code>normalize</code>()
	///  method on <code>Element</code> merges any such adjacent
	///  <code>Text</code> objects into a single node for each block of
	///  text; this is recommended before employing operations that depend
	///  on a particular document structure, such as navigation with
	///  <code>XPointers</code>.
	///  </remarks>		<short>    The <code>Text</code> interface represents the textual content  (termed <a href="&xml-spec;#syntax"> character data </a> in XML) of  an <code>Element</code> or <code>Attr</code> .</short>

	[SmokeClass("DOM::Text")]
	public class Text : DOM.CharacterData, IDisposable {
 		protected Text(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Text), this);
		}
		// DOM::Text* Text(DOM::TextImpl* arg1); >>>> NOT CONVERTED
		public Text() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Text", "Text()", typeof(void));
		}
		public Text(DOM.Text other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Text#", "Text(const DOM::Text&)", typeof(void), typeof(DOM.Text), other);
		}
		public Text(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Text#", "Text(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  Breaks this <code>Text</code> node into two Text nodes at the
		///  specified offset, keeping both in the tree as siblings. This
		///  node then only contains all the content up to the <code>offset</code>
		///  point. And a new <code>Text</code> node, which is
		///  inserted as the next sibling of this node, contains all the
		///  content at and after the <code>offset</code> point.
		/// <param> name="offset" The offset at which to split, starting from 0.
		/// </param>  NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
		///      </remarks>		<return> The new <code>Text</code> node.
		/// </return>
		/// 		<short>    Breaks this <code>Text</code> node into two Text nodes at the  specified offset, keeping both in the tree as siblings.</short>
		public DOM.Text SplitText(ulong offset) {
			return (DOM.Text) interceptor.Invoke("splitText$", "splitText(const unsigned long)", typeof(DOM.Text), typeof(ulong), offset);
		}
		~Text() {
			interceptor.Invoke("~Text", "~Text()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~Text", "~Text()", typeof(void));
		}
	}
	}
}
