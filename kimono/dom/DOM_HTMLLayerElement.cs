//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  Layer container for Netscape 4.x compatability.
	///  Behaves mostly like absolute positioned DIV-blocks.
	///  </remarks>		<short>    Layer container for Netscape 4.</short>

	[SmokeClass("DOM::HTMLLayerElement")]
	public class HTMLLayerElement : DOM.HTMLElement, IDisposable {
 		protected HTMLLayerElement(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(HTMLLayerElement), this);
		}
		// DOM::HTMLLayerElement* HTMLLayerElement(DOM::HTMLLayerElementImpl* arg1); >>>> NOT CONVERTED
		public HTMLLayerElement() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLLayerElement", "HTMLLayerElement()", typeof(void));
		}
		public HTMLLayerElement(DOM.HTMLLayerElement other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLLayerElement#", "HTMLLayerElement(const DOM::HTMLLayerElement&)", typeof(void), typeof(DOM.HTMLLayerElement), other);
		}
		public HTMLLayerElement(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLLayerElement#", "HTMLLayerElement(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  The absolute position of the layer from the top.
		///      </remarks>		<short>    The absolute position of the layer from the top.</short>
		public long Top() {
			return (long) interceptor.Invoke("top", "top() const", typeof(long));
		}
		/// <remarks>
		///  see top
		///      </remarks>		<short>    see top      </short>
		public void SetTop(long arg1) {
			interceptor.Invoke("setTop$", "setTop(long)", typeof(void), typeof(long), arg1);
		}
		/// <remarks>
		///  The absolute position of the layer from the left.
		///      </remarks>		<short>    The absolute position of the layer from the left.</short>
		public long Left() {
			return (long) interceptor.Invoke("left", "left() const", typeof(long));
		}
		/// <remarks>
		///  see left
		///      </remarks>		<short>    see left      </short>
		public void SetLeft(long arg1) {
			interceptor.Invoke("setLeft$", "setLeft(long)", typeof(void), typeof(long), arg1);
		}
		/// <remarks>
		///  The visibility of layers is either "show" or "hide"
		///      </remarks>		<short>    The visibility of layers is either "show" or "hide" </short>
		public string Visibility() {
			return (string) interceptor.Invoke("visibility", "visibility() const", typeof(string));
		}
		/// <remarks>
		///  see visibility
		///      </remarks>		<short>    see visibility      </short>
		public void SetVisibility(string arg1) {
			interceptor.Invoke("setVisibility#", "setVisibility(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The background color of the layer.
		///      </remarks>		<short>    The background color of the layer.</short>
		public string BgColor() {
			return (string) interceptor.Invoke("bgColor", "bgColor() const", typeof(string));
		}
		/// <remarks>
		///  see bgColor
		///      </remarks>		<short>    see bgColor      </short>
		public void SetBgColor(string arg1) {
			interceptor.Invoke("setBgColor#", "setBgColor(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The collection of sub-layers
		///      </remarks>		<short>    The collection of sub-layers </short>
		public DOM.HTMLCollection Layers() {
			return (DOM.HTMLCollection) interceptor.Invoke("layers", "layers() const", typeof(DOM.HTMLCollection));
		}
		~HTMLLayerElement() {
			interceptor.Invoke("~HTMLLayerElement", "~HTMLLayerElement()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~HTMLLayerElement", "~HTMLLayerElement()", typeof(void));
		}
	}
	}
}
