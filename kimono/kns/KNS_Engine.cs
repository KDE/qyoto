//Auto-generated by kalyptus. DO NOT EDIT.
namespace KNS {

	using Kimono;
	using System;
	using Qyoto;

	/// <remarks>
	///  @brief The KNewStuff2 engine is the top-level class to handle GHNS and DXS workflows.
	///  An engine implements GHNS workflows, which consist of discrete steps
	///  performed by the inherited engine. Depending on the provider, traditional
	///  GHNS or DXS are used transparently.
	///  This class is the one which applications should use.
	///  In most cases, either \ref upload() or \ref download() will be called by the
	///  application to upload or download data.
	///  </remarks>		<short>    @brief The KNewStuff2 engine is the top-level class to handle GHNS and DXS workflows.</short>

	[SmokeClass("KNS::Engine")]
	public class Engine : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected Engine(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(Engine), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static Engine() {
			staticInterceptor = new SmokeInvocationKDE(typeof(Engine), null);
		}
		// KNS::Entry::List downloadDialogModal(QWidget* arg1); >>>> NOT CONVERTED
		// KNS::Entry::List downloadDialogModal(); >>>> NOT CONVERTED
		// KNS::Entry::List download(); >>>> NOT CONVERTED
		/// <remarks>
		///  @brief Engine constructor.
		///  As many engines as needed can be instantiated, although one should use
		///  the static methods \ref download() and \ref upload() instead.
		///      </remarks>		<short>    @brief Engine constructor.</short>
		public Engine(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Engine#", "Engine(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public Engine() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Engine", "Engine()", typeof(void));
		}
		/// <remarks>
		///  @brief Synchronous way of starting the download workflow.
		///  Starts the download workflow. This workflow will turn up a dialog
		///  where the user can select entries for installation and uninstallation.
		///  This method is a modal one. It will return all affected entries as
		///  a list.
		///  NOTE: this list must be queried to see which ones were installed and which were uninstalled
		///  since both are in the one list. i.e. (entry.Status() == KNS.Entry.Installed)
		/// </remarks>		<return> List of installed or deinstalled entries
		///      </return>
		/// 		<short>    @brief Synchronous way of starting the download workflow.</short>
		/// <remarks>
		///  @brief Synchronous way of starting the upload workflow.
		///  Starts the upload workflow. This workflow will offer provider
		///  selection and afterwards upload all files associated with an entry.
		///  This method is a modal one. It will return the uploaded entry.
		/// </remarks>		<return> Uploaded entry, or <b></b>ull in case of failures
		///      </return>
		/// 		<short>    @brief Synchronous way of starting the upload workflow.</short>
		public KNS.Entry UploadDialogModal(string file) {
			return (KNS.Entry) interceptor.Invoke("uploadDialogModal$", "uploadDialogModal(const QString&)", typeof(KNS.Entry), typeof(string), file);
		}
		/// <remarks>
		///  @brief Asynchronous way of starting the download workflow.
		///  This method should be used whenever a blocking application with a
		///  non-blocking GUI during GHNS operations is not suitable.
		///  Affected entries will be reported by signals.
		/// </remarks>		<short>    @brief Asynchronous way of starting the download workflow.</short>
		/// 		<see> downloadDialogModal</see>
		public void DownloadDialog() {
			interceptor.Invoke("downloadDialog", "downloadDialog()", typeof(void));
		}
		/// <remarks>
		///  @brief Asynchronous way of starting the upload workflow.
		///  This method should be used whenever a blocking application with a
		///  non-blocking GUI during GHNS operations is not suitable.
		///  The affected entry will be reported by signals.
		/// </remarks>		<short>    @brief Asynchronous way of starting the upload workflow.</short>
		/// 		<see> uploadDialogModal</see>
		public void UploadDialog(string file) {
			interceptor.Invoke("uploadDialog$", "uploadDialog(const QString&)", typeof(void), typeof(string), file);
		}
		public bool Init(string config) {
			return (bool) interceptor.Invoke("init$", "init(const QString&)", typeof(bool), typeof(string), config);
		}
		~Engine() {
			interceptor.Invoke("~Engine", "~Engine()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~Engine", "~Engine()", typeof(void));
		}
		/// <remarks>
		///  @brief Recommended download workflow entry point.
		///  This method is a static convenience wrapper around \ref downloadDialogModal()
		///  which does not require the manual construction of an engine object.
		///  The engine will be configured to load appname.knsrc.
		///  The resulting entry list must not be freed, as the engine will continue
		///  to keep track of it.
		/// </remarks>		<return> List of installed or deinstalled entries
		///  NOTE: this is a copy of each entry because this call deletes its own
		///  engine which deletes the original entries, so you need to delete the entries
		///  returned in the list
		/// </return>
		/// 		<short>    @brief Recommended download workflow entry point.</short>
		/// 		<see> downloadDialogModal</see>
		/// <remarks>
		///  @brief Recommended upload workflow entry point.
		///  This method is a static convenience wrapper around \ref uploadDialogModal()
		///  which does not require the manual construction of an engine object.
		///  The engine will be configured to load appname.knsrc.
		///  The resulting entry must not be freed, as the engine will continue
		///  to keep track of it.
		/// </remarks>		<return> Uploaded entry, or <b></b>ull in case of failures
		/// </return>
		/// 		<short>    @brief Recommended upload workflow entry point.</short>
		/// 		<see> uploadDialogModal</see>
		public static KNS.Entry Upload(string file) {
			return (KNS.Entry) staticInterceptor.Invoke("upload$", "upload(const QString&)", typeof(KNS.Entry), typeof(string), file);
		}
	}
}
