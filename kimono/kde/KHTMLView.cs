//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  Renders and displays HTML in a QScrollArea.
	///  Suitable for use as an application's main view.
	///  See <see cref="IKHTMLViewSignals"></see> for signals emitted by KHTMLView
	/// </remarks>		<short>    Renders and displays HTML in a QScrollArea.</short>

	[SmokeClass("KHTMLView")]
	public class KHTMLView : QScrollArea, IDisposable {
 		protected KHTMLView(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KHTMLView), this);
		}
		/// <remarks>
		///  Constructs a KHTMLView.
		///      </remarks>		<short>    Constructs a KHTMLView.</short>
		public KHTMLView(KHTMLPart part, QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KHTMLView##", "KHTMLView(KHTMLPart*, QWidget*)", typeof(void), typeof(KHTMLPart), part, typeof(QWidget), parent);
		}
		/// <remarks>
		///  Returns a pointer to the KHTMLPart that is
		///  rendering the page.
		/// </remarks>		<short>    Returns a pointer to the KHTMLPart that is  rendering the page.</short>
		public KHTMLPart Part() {
			return (KHTMLPart) interceptor.Invoke("part", "part() const", typeof(KHTMLPart));
		}
		public new int FrameWidth() {
			return (int) interceptor.Invoke("frameWidth", "frameWidth() const", typeof(int));
		}
		/// <remarks>
		///  Sets a margin in x direction.
		///      </remarks>		<short>    Sets a margin in x direction.</short>
		public void SetMarginWidth(int x) {
			interceptor.Invoke("setMarginWidth$", "setMarginWidth(int)", typeof(void), typeof(int), x);
		}
		/// <remarks>
		///  Returns the margin width.
		///  A return value of -1 means the default value will be used.
		///      </remarks>		<short>    Returns the margin width.</short>
		public int MarginWidth() {
			return (int) interceptor.Invoke("marginWidth", "marginWidth() const", typeof(int));
		}
		public void SetMarginHeight(int y) {
			interceptor.Invoke("setMarginHeight$", "setMarginHeight(int)", typeof(void), typeof(int), y);
		}
		/// <remarks>
		///  Returns the margin height.
		///  A return value of -1 means the default value will be used.
		///      </remarks>		<short>    Returns the margin height.</short>
		public int MarginHeight() {
			return (int) interceptor.Invoke("marginHeight", "marginHeight()", typeof(int));
		}
		/// <remarks>
		///  Sets verticals scrollbar mode. Reimplemented for internal reasons.
		///      </remarks>		<short>    Sets verticals scrollbar mode.</short>
		[SmokeMethod("setVerticalScrollBarPolicy(Qt::ScrollBarPolicy)")]
		public virtual void SetVerticalScrollBarPolicy(Qt.ScrollBarPolicy policy) {
			interceptor.Invoke("setVerticalScrollBarPolicy$", "setVerticalScrollBarPolicy(Qt::ScrollBarPolicy)", typeof(void), typeof(Qt.ScrollBarPolicy), policy);
		}
		/// <remarks>
		///  Sets horizontal scrollbar mode. Reimplemented for internal reasons.
		///      </remarks>		<short>    Sets horizontal scrollbar mode.</short>
		[SmokeMethod("setHorizontalScrollBarPolicy(Qt::ScrollBarPolicy)")]
		public virtual void SetHorizontalScrollBarPolicy(Qt.ScrollBarPolicy policy) {
			interceptor.Invoke("setHorizontalScrollBarPolicy$", "setHorizontalScrollBarPolicy(Qt::ScrollBarPolicy)", typeof(void), typeof(Qt.ScrollBarPolicy), policy);
		}
		/// <remarks>
		///  Prints the HTML document.
		/// <param> name="quick" if true, fully automated printing, without print dialog
		///      </param></remarks>		<short>    Prints the HTML document.</short>
		public void Print(bool quick) {
			interceptor.Invoke("print$", "print(bool)", typeof(void), typeof(bool), quick);
		}
		public void Print() {
			interceptor.Invoke("print", "print()", typeof(void));
		}
		/// <remarks>
		///  Display all accesskeys in small tooltips
		///      </remarks>		<short>    Display all accesskeys in small tooltips      </short>
		public void DisplayAccessKeys() {
			interceptor.Invoke("displayAccessKeys", "displayAccessKeys()", typeof(void));
		}
		/// <remarks>
		///  Returns the contents area's width
		///      </remarks>		<short>    Returns the contents area's width      </short>
		public int ContentsWidth() {
			return (int) interceptor.Invoke("contentsWidth", "contentsWidth() const", typeof(int));
		}
		/// <remarks>
		///  Returns the contents area's height
		///      </remarks>		<short>    Returns the contents area's height      </short>
		public int ContentsHeight() {
			return (int) interceptor.Invoke("contentsHeight", "contentsHeight() const", typeof(int));
		}
		/// <remarks>
		///  Returns the x coordinate of the contents area point
		///  that is currently located at the top left in the viewport
		///      </remarks>		<short>    Returns the x coordinate of the contents area point  that is currently located at the top left in the viewport      </short>
		public int ContentsX() {
			return (int) interceptor.Invoke("contentsX", "contentsX() const", typeof(int));
		}
		/// <remarks>
		///  Returns the y coordinate of the contents area point
		///  that is currently located at the top left in the viewport
		///      </remarks>		<short>    Returns the y coordinate of the contents area point  that is currently located at the top left in the viewport      </short>
		public int ContentsY() {
			return (int) interceptor.Invoke("contentsY", "contentsY() const", typeof(int));
		}
		/// <remarks>
		///  Returns the width of the viewport
		///      </remarks>		<short>    Returns the width of the viewport      </short>
		public int VisibleWidth() {
			return (int) interceptor.Invoke("visibleWidth", "visibleWidth() const", typeof(int));
		}
		/// <remarks>
		///  Returns the height of the viewport
		///      </remarks>		<short>    Returns the height of the viewport      </short>
		public int VisibleHeight() {
			return (int) interceptor.Invoke("visibleHeight", "visibleHeight() const", typeof(int));
		}
		/// <remarks>
		///   Place the contents area point x/y
		///   at the top left of the viewport
		///      </remarks>		<short>     Place the contents area point x/y   at the top left of the viewport      </short>
		public void SetContentsPos(int x, int y) {
			interceptor.Invoke("setContentsPos$$", "setContentsPos(int, int)", typeof(void), typeof(int), x, typeof(int), y);
		}
		/// <remarks>
		///  Returns a point translated to viewport coordinates
		/// <param> name="p" the contents area point to translate
		/// </param>     </remarks>		<short>    Returns a point translated to viewport coordinates </short>
		public QPoint ContentsToViewport(QPoint p) {
			return (QPoint) interceptor.Invoke("contentsToViewport#", "contentsToViewport(const QPoint&) const", typeof(QPoint), typeof(QPoint), p);
		}
		/// <remarks>
		///  Returns a point translated to contents area coordinates
		/// <param> name="p" the viewport point to translate
		/// </param>     </remarks>		<short>    Returns a point translated to contents area coordinates </short>
		public QPoint ViewportToContents(QPoint p) {
			return (QPoint) interceptor.Invoke("viewportToContents#", "viewportToContents(const QPoint&) const", typeof(QPoint), typeof(QPoint), p);
		}
		/// <remarks>
		///  Returns a point translated to contents area coordinates
		/// <param> name="x" x coordinate of viewport point to translate
		/// </param><param> name="y" y coordinate of viewport point to translate
		/// </param><param> name="cx" resulting x coordinate 
		/// </param><param> name="cy" resulting y coordinate
		/// </param>     </remarks>		<short>    Returns a point translated to contents area coordinates </short>
		public void ViewportToContents(int x, int y, ref int cx, ref int cy) {
			StackItem[] stack = new StackItem[5];
			stack[1].s_int = x;
			stack[2].s_int = y;
			stack[3].s_int = cx;
			stack[4].s_int = cy;
			interceptor.Invoke("viewportToContents$$$$", "viewportToContents(int, int, int&, int&) const", stack);
			cx = stack[3].s_int;
			cy = stack[4].s_int;
			return;
		}
		/// <remarks>
		///  Returns a point translated to viewport coordinates
		/// <param> name="x" x coordinate of contents area point to translate
		/// </param><param> name="y" y coordinate of contents area point to translate
		/// </param><param> name="cx" resulting x coordinate 
		/// </param><param> name="cy" resulting y coordinate
		/// </param>     </remarks>		<short>    Returns a point translated to viewport coordinates </short>
		public void ContentsToViewport(int x, int y, ref int cx, ref int cy) {
			StackItem[] stack = new StackItem[5];
			stack[1].s_int = x;
			stack[2].s_int = y;
			stack[3].s_int = cx;
			stack[4].s_int = cy;
			interceptor.Invoke("contentsToViewport$$$$", "contentsToViewport(int, int, int&, int&) const", stack);
			cx = stack[3].s_int;
			cy = stack[4].s_int;
			return;
		}
		/// <remarks>
		///  Scrolls the content area by a given amount
		/// <param> name="x" x offset
		/// </param><param> name="y" y offset
		///      </param></remarks>		<short>    Scrolls the content area by a given amount </short>
		public void ScrollBy(int x, int y) {
			interceptor.Invoke("scrollBy$$", "scrollBy(int, int)", typeof(void), typeof(int), x, typeof(int), y);
		}
		/// <remarks>
		///  Requests an update of the content area
		/// <param> name="r" the content area rectangle to update
		///      </param></remarks>		<short>    Requests an update of the content area </short>
		public void UpdateContents(QRect r) {
			interceptor.Invoke("updateContents#", "updateContents(const QRect&)", typeof(void), typeof(QRect), r);
		}
		public void UpdateContents(int x, int y, int w, int h) {
			interceptor.Invoke("updateContents$$$$", "updateContents(int, int, int, int)", typeof(void), typeof(int), x, typeof(int), y, typeof(int), w, typeof(int), h);
		}
		public void AddChild(QWidget child, int dx, int dy) {
			interceptor.Invoke("addChild#$$", "addChild(QWidget*, int, int)", typeof(void), typeof(QWidget), child, typeof(int), dx, typeof(int), dy);
		}
		/// <remarks>
		///  Requests an immediate repaint of the content area
		/// <param> name="r" the content area rectangle to repaint
		///      </param></remarks>		<short>    Requests an immediate repaint of the content area </short>
		public void RepaintContents(QRect r) {
			interceptor.Invoke("repaintContents#", "repaintContents(const QRect&)", typeof(void), typeof(QRect), r);
		}
		public void RepaintContents(int x, int y, int w, int h) {
			interceptor.Invoke("repaintContents$$$$", "repaintContents(int, int, int, int)", typeof(void), typeof(int), x, typeof(int), y, typeof(int), w, typeof(int), h);
		}
		/// <remarks>
		///  Apply a zoom level to the content area
		/// <param> name="percent" a zoom level expressed as a percentage
		///      </param></remarks>		<short>    Apply a zoom level to the content area </short>
		public void SetZoomLevel(int percent) {
			interceptor.Invoke("setZoomLevel$", "setZoomLevel(int)", typeof(void), typeof(int), percent);
		}
		/// <remarks>
		///  Retrieve the current zoom level
		///      </remarks>		<short>    Retrieve the current zoom level </short>
		public int ZoomLevel() {
			return (int) interceptor.Invoke("zoomLevel", "zoomLevel() const", typeof(int));
		}
		/// <remarks>
		///  Resize the contents area
		/// <param> name="w" the new width
		/// </param><param> name="h" the new height
		///      </param></remarks>		<short>    Resize the contents area </short>
		[Q_SLOT("void resizeContents(int, int)")]
		[SmokeMethod("resizeContents(int, int)")]
		public virtual void ResizeContents(int w, int h) {
			interceptor.Invoke("resizeContents$$", "resizeContents(int, int)", typeof(void), typeof(int), w, typeof(int), h);
		}
		/// <remarks>
		///  ensure the display is up to date
		///      </remarks>		<short>    ensure the display is up to date      </short>
		[Q_SLOT("void layout()")]
		public void Layout() {
			interceptor.Invoke("layout", "layout()", typeof(void));
		}
		protected void Clear() {
			interceptor.Invoke("clear", "clear()", typeof(void));
		}
		[SmokeMethod("event(QEvent*)")]
		protected override bool Event(QEvent arg1) {
			return (bool) interceptor.Invoke("event#", "event(QEvent*)", typeof(bool), typeof(QEvent), arg1);
		}
		[SmokeMethod("paintEvent(QPaintEvent*)")]
		protected override void PaintEvent(QPaintEvent arg1) {
			interceptor.Invoke("paintEvent#", "paintEvent(QPaintEvent*)", typeof(void), typeof(QPaintEvent), arg1);
		}
		[SmokeMethod("resizeEvent(QResizeEvent*)")]
		protected override void ResizeEvent(QResizeEvent arg1) {
			interceptor.Invoke("resizeEvent#", "resizeEvent(QResizeEvent*)", typeof(void), typeof(QResizeEvent), arg1);
		}
		[SmokeMethod("showEvent(QShowEvent*)")]
		protected override void ShowEvent(QShowEvent arg1) {
			interceptor.Invoke("showEvent#", "showEvent(QShowEvent*)", typeof(void), typeof(QShowEvent), arg1);
		}
		[SmokeMethod("hideEvent(QHideEvent*)")]
		protected override void HideEvent(QHideEvent arg1) {
			interceptor.Invoke("hideEvent#", "hideEvent(QHideEvent*)", typeof(void), typeof(QHideEvent), arg1);
		}
		[SmokeMethod("focusNextPrevChild(bool)")]
		protected new virtual bool FocusNextPrevChild(bool next) {
			return (bool) interceptor.Invoke("focusNextPrevChild$", "focusNextPrevChild(bool)", typeof(bool), typeof(bool), next);
		}
		[SmokeMethod("mousePressEvent(QMouseEvent*)")]
		protected override void MousePressEvent(QMouseEvent arg1) {
			interceptor.Invoke("mousePressEvent#", "mousePressEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), arg1);
		}
		[SmokeMethod("focusInEvent(QFocusEvent*)")]
		protected override void FocusInEvent(QFocusEvent arg1) {
			interceptor.Invoke("focusInEvent#", "focusInEvent(QFocusEvent*)", typeof(void), typeof(QFocusEvent), arg1);
		}
		[SmokeMethod("focusOutEvent(QFocusEvent*)")]
		protected override void FocusOutEvent(QFocusEvent arg1) {
			interceptor.Invoke("focusOutEvent#", "focusOutEvent(QFocusEvent*)", typeof(void), typeof(QFocusEvent), arg1);
		}
		[SmokeMethod("mouseDoubleClickEvent(QMouseEvent*)")]
		protected override void MouseDoubleClickEvent(QMouseEvent arg1) {
			interceptor.Invoke("mouseDoubleClickEvent#", "mouseDoubleClickEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), arg1);
		}
		[SmokeMethod("mouseMoveEvent(QMouseEvent*)")]
		protected override void MouseMoveEvent(QMouseEvent arg1) {
			interceptor.Invoke("mouseMoveEvent#", "mouseMoveEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), arg1);
		}
		[SmokeMethod("mouseReleaseEvent(QMouseEvent*)")]
		protected override void MouseReleaseEvent(QMouseEvent arg1) {
			interceptor.Invoke("mouseReleaseEvent#", "mouseReleaseEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), arg1);
		}
		[SmokeMethod("wheelEvent(QWheelEvent*)")]
		protected override void WheelEvent(QWheelEvent arg1) {
			interceptor.Invoke("wheelEvent#", "wheelEvent(QWheelEvent*)", typeof(void), typeof(QWheelEvent), arg1);
		}
		[SmokeMethod("dragEnterEvent(QDragEnterEvent*)")]
		protected override void DragEnterEvent(QDragEnterEvent arg1) {
			interceptor.Invoke("dragEnterEvent#", "dragEnterEvent(QDragEnterEvent*)", typeof(void), typeof(QDragEnterEvent), arg1);
		}
		[SmokeMethod("dropEvent(QDropEvent*)")]
		protected override void DropEvent(QDropEvent arg1) {
			interceptor.Invoke("dropEvent#", "dropEvent(QDropEvent*)", typeof(void), typeof(QDropEvent), arg1);
		}
		[SmokeMethod("closeEvent(QCloseEvent*)")]
		protected override void CloseEvent(QCloseEvent arg1) {
			interceptor.Invoke("closeEvent#", "closeEvent(QCloseEvent*)", typeof(void), typeof(QCloseEvent), arg1);
		}
		[SmokeMethod("widgetEvent(QEvent*)")]
		protected virtual bool WidgetEvent(QEvent arg1) {
			return (bool) interceptor.Invoke("widgetEvent#", "widgetEvent(QEvent*)", typeof(bool), typeof(QEvent), arg1);
		}
		[SmokeMethod("viewportEvent(QEvent*)")]
		protected override bool ViewportEvent(QEvent e) {
			return (bool) interceptor.Invoke("viewportEvent#", "viewportEvent(QEvent*)", typeof(bool), typeof(QEvent), e);
		}
		[SmokeMethod("eventFilter(QObject*, QEvent*)")]
		protected override bool EventFilter(QObject arg1, QEvent arg2) {
			return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), arg1, typeof(QEvent), arg2);
		}
		[SmokeMethod("scrollContentsBy(int, int)")]
		protected override void ScrollContentsBy(int dx, int dy) {
			interceptor.Invoke("scrollContentsBy$$", "scrollContentsBy(int, int)", typeof(void), typeof(int), dx, typeof(int), dy);
		}
		[SmokeMethod("keyPressEvent(QKeyEvent*)")]
		protected override void KeyPressEvent(QKeyEvent _ke) {
			interceptor.Invoke("keyPressEvent#", "keyPressEvent(QKeyEvent*)", typeof(void), typeof(QKeyEvent), _ke);
		}
		[SmokeMethod("keyReleaseEvent(QKeyEvent*)")]
		protected override void KeyReleaseEvent(QKeyEvent _ke) {
			interceptor.Invoke("keyReleaseEvent#", "keyReleaseEvent(QKeyEvent*)", typeof(void), typeof(QKeyEvent), _ke);
		}
		protected void DoAutoScroll() {
			interceptor.Invoke("doAutoScroll", "doAutoScroll()", typeof(void));
		}
		[SmokeMethod("timerEvent(QTimerEvent*)")]
		protected override void TimerEvent(QTimerEvent arg1) {
			interceptor.Invoke("timerEvent#", "timerEvent(QTimerEvent*)", typeof(void), typeof(QTimerEvent), arg1);
		}
		[Q_SLOT("void slotPaletteChanged()")]
		protected void SlotPaletteChanged() {
			interceptor.Invoke("slotPaletteChanged", "slotPaletteChanged()", typeof(void));
		}
		~KHTMLView() {
			interceptor.Invoke("~KHTMLView", "~KHTMLView()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KHTMLView", "~KHTMLView()", typeof(void));
		}
		protected new IKHTMLViewSignals Emit {
			get { return (IKHTMLViewSignals) Q_EMIT; }
		}
	}

	public interface IKHTMLViewSignals : IQScrollAreaSignals {
		/// <remarks>
		///  This signal is used for internal layouting. Don't use it to check if rendering finished.
		///  Use <see cref="KHTMLPart"></see> completed() signal instead.
		///      </remarks>		<short>    This signal is used for internal layouting.</short>
		[Q_SIGNAL("void finishedLayout()")]
		void FinishedLayout();
		[Q_SIGNAL("void cleared()")]
		void Cleared();
		[Q_SIGNAL("void zoomView(int)")]
		void ZoomView(int arg1);
		[Q_SIGNAL("void hideAccessKeys()")]
		void HideAccessKeys();
		[Q_SIGNAL("void repaintAccessKeys()")]
		void RepaintAccessKeys();
		[Q_SIGNAL("void findAheadActive(bool)")]
		void FindAheadActive(bool arg1);
	}
}
