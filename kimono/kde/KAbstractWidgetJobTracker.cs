//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  The base class for widget based job trackers.
	///   See <see cref="IKAbstractWidgetJobTrackerSignals"></see> for signals emitted by KAbstractWidgetJobTracker
	/// </remarks>		<short>    The base class for widget based job trackers.</short>

	[SmokeClass("KAbstractWidgetJobTracker")]
	public abstract class KAbstractWidgetJobTracker : KJobTrackerInterface {
 		protected KAbstractWidgetJobTracker(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KAbstractWidgetJobTracker), this);
		}
		/// <remarks>
		///  Creates a new KAbstractWidgetJobTracker
		/// <param> name="parent" the parent of this object and of the widget displaying the job progresses
		///      </param></remarks>		<short>    Creates a new KAbstractWidgetJobTracker </short>
		public KAbstractWidgetJobTracker(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KAbstractWidgetJobTracker#", "KAbstractWidgetJobTracker(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KAbstractWidgetJobTracker() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KAbstractWidgetJobTracker", "KAbstractWidgetJobTracker()", typeof(void));
		}
		/// <remarks>
		///  Register a new job in this tracker.
		///  Note that job trackers inheriting from this class can have only one job
		///  registered at a time.
		/// <param> name="job" the job to register
		///      </param></remarks>		<short>    Register a new job in this tracker.</short>
		[SmokeMethod("registerJob(KJob*)")]
		public override void RegisterJob(KJob job) {
			interceptor.Invoke("registerJob#", "registerJob(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  Unregister a job from this tracker.
		/// <param> name="job" the job to unregister
		///      </param></remarks>		<short>    Unregister a job from this tracker.</short>
		[SmokeMethod("unregisterJob(KJob*)")]
		public override void UnregisterJob(KJob job) {
			interceptor.Invoke("unregisterJob#", "unregisterJob(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  The widget associated to this tracker.
		/// <param> name="job" the job that is assigned the widget we want to return
		/// </param></remarks>		<return> the widget displaying the job progresses
		///      </return>
		/// 		<short>    The widget associated to this tracker.</short>
		[SmokeMethod("widget(KJob*)")]
		public abstract QWidget Widget(KJob job);
		/// <remarks>
		///  This controls whether the job should be canceled if the dialog is closed.
		/// <param> name="job" the job's widget that will be stopped when closing
		/// </param><param> name="stopOnClose" If true the job will be stopped if the dialog is closed,
		///  otherwise the job will continue even on close.
		/// </param></remarks>		<short>    This controls whether the job should be canceled if the dialog is closed.</short>
		/// 		<see> stopOnClose</see>
		public void SetStopOnClose(KJob job, bool stopOnClose) {
			interceptor.Invoke("setStopOnClose#$", "setStopOnClose(KJob*, bool)", typeof(void), typeof(KJob), job, typeof(bool), stopOnClose);
		}
		/// <remarks>
		///  Checks whether the job will be killed when the dialog is closed.
		/// <param> name="job" the job's widget that will be stopped when closing
		/// </param></remarks>		<return> true if the job is killed on close event, false otherwise.
		/// </return>
		/// 		<short>    Checks whether the job will be killed when the dialog is closed.</short>
		/// 		<see> setStopOnClose</see>
		public bool StopOnClose(KJob job) {
			return (bool) interceptor.Invoke("stopOnClose#", "stopOnClose(KJob*) const", typeof(bool), typeof(KJob), job);
		}
		/// <remarks>
		///  This controls whether the dialog should be deleted or only cleaned when
		///  the KJob is finished (or canceled).
		///  If your dialog is an embedded widget and not a separate window, you should
		///  setAutoDelete(false) in the constructor of your custom dialog.
		/// <param> name="job" the job's widget that is going to be auto-deleted
		/// </param><param> name="autoDelete" If false the dialog will only call method slotClean.
		///  If true the dialog will be deleted.
		/// </param></remarks>		<short>    This controls whether the dialog should be deleted or only cleaned when  the KJob is finished (or canceled).</short>
		/// 		<see> autoDelete</see>
		public void SetAutoDelete(KJob job, bool autoDelete) {
			interceptor.Invoke("setAutoDelete#$", "setAutoDelete(KJob*, bool)", typeof(void), typeof(KJob), job, typeof(bool), autoDelete);
		}
		/// <remarks>
		///  Checks whether the dialog should be deleted or cleaned.
		/// <param> name="job" the job's widget that will be auto-deleted
		/// </param></remarks>		<return> false if the dialog only calls slotClean, true if it will be
		///          deleted
		/// </return>
		/// 		<short>    Checks whether the dialog should be deleted or cleaned.</short>
		/// 		<see> setAutoDelete</see>
		public bool AutoDelete(KJob job) {
			return (bool) interceptor.Invoke("autoDelete#", "autoDelete(KJob*) const", typeof(bool), typeof(KJob), job);
		}
		/// <remarks>
		///  Called when a job is finished, in any case. It is used to notify
		///  that the job is terminated and that progress UI (if any) can be hidden.
		/// <param> name="job" the job that emitted this signal
		///      </param></remarks>		<short>    Called when a job is finished, in any case.</short>
		[Q_SLOT("void finished(KJob*)")]
		[SmokeMethod("finished(KJob*)")]
		protected override void Finished(KJob job) {
			interceptor.Invoke("finished#", "finished(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  This method should be called for correct cancellation of IO operation
		///  Connect this to the progress widgets buttons etc.
		/// <param> name="job" The job that is being stopped
		///      </param></remarks>		<short>    This method should be called for correct cancellation of IO operation  Connect this to the progress widgets buttons etc.</short>
		[Q_SLOT("void slotStop(KJob*)")]
		[SmokeMethod("slotStop(KJob*)")]
		protected virtual void SlotStop(KJob job) {
			interceptor.Invoke("slotStop#", "slotStop(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  This method should be called for pause/resume
		///  Connect this to the progress widgets buttons etc.
		/// <param> name="job" The job that is being suspended
		///      </param></remarks>		<short>    This method should be called for pause/resume  Connect this to the progress widgets buttons etc.</short>
		[Q_SLOT("void slotSuspend(KJob*)")]
		[SmokeMethod("slotSuspend(KJob*)")]
		protected virtual void SlotSuspend(KJob job) {
			interceptor.Invoke("slotSuspend#", "slotSuspend(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  This method should be called for pause/resume
		///  Connect this to the progress widgets buttons etc.
		/// <param> name="job" The job that is being resumed
		///      </param></remarks>		<short>    This method should be called for pause/resume  Connect this to the progress widgets buttons etc.</short>
		[Q_SLOT("void slotResume(KJob*)")]
		[SmokeMethod("slotResume(KJob*)")]
		protected virtual void SlotResume(KJob job) {
			interceptor.Invoke("slotResume#", "slotResume(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  This method is called when the widget should be cleaned (after job is finished).
		///  redefine this for custom behavior.
		/// <param> name="job" The job that is being cleaned
		///      </param></remarks>		<short>    This method is called when the widget should be cleaned (after job is finished).</short>
		[Q_SLOT("void slotClean(KJob*)")]
		[SmokeMethod("slotClean(KJob*)")]
		protected virtual void SlotClean(KJob job) {
			interceptor.Invoke("slotClean#", "slotClean(KJob*)", typeof(void), typeof(KJob), job);
		}
		protected new IKAbstractWidgetJobTrackerSignals Emit {
			get { return (IKAbstractWidgetJobTrackerSignals) Q_EMIT; }
		}
	}

	public interface IKAbstractWidgetJobTrackerSignals : IKJobTrackerInterfaceSignals {
		/// <remarks>
		///  Emitted when the user aborted the operation
		/// <param> name="job" The job that has been stopped
		///      </param></remarks>		<short>    Emitted when the user aborted the operation </short>
		[Q_SIGNAL("void stopped(KJob*)")]
		void Stopped(KJob job);
		/// <remarks>
		///  Emitted when the user suspended the operation
		/// <param> name="job" The job that has been suspended
		///      </param></remarks>		<short>    Emitted when the user suspended the operation </short>
		[Q_SIGNAL("void suspend(KJob*)")]
		void Suspend(KJob job);
		/// <remarks>
		///  Emitted when the user resumed the operation
		/// <param> name="job" The job that has been resumed
		///      </param></remarks>		<short>    Emitted when the user resumed the operation </short>
		[Q_SIGNAL("void resume(KJob*)")]
		void Resume(KJob job);
	}
}
