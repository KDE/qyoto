//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	/// <remarks>
	///  KUniqueApplication is a KApplication which only uses a single process.  When
	///  a KUniqueApplication is started, it attempts to contact an existing copy 
	///  of the application.  If successful, the program asks the 
	///  existing process to create a new instance by calling its newInstance() method
	///  and then exits.  If there is no existing process then the program forks and
	///  calls the newInstance() method.  When newInstance() is called, the application
	///  will typically create a new window or activate an existing one.
	///  Instances of KUniqueApplication can be made to behave like a normal application by passing
	///  the StartFlag.NonUniqueInstance flag to start().
	///  Please note that this supports only one process per KDE session. If
	///  your application can only be opened once per user or once per host, you
	///  need to ensure this independently of KUniqueApplication.
	///  The .desktop file for the application should state X-DBUS-StartupType=Unique,
	///  see ktoolinvocation.h
	///  If your application is used to open files, it should also support the --tempfile
	///  option (see KCmdLineArgs.AddTempFileOption()), to delete tempfiles after use.
	///  Add X-KDE-HasTempFileOption=true to the .desktop file to indicate this.
	/// </remarks>		<author> Preston Brown <pbrown@kde.org>
	///  </author>
	/// 		<short>    KUniqueApplication is a KApplication which only uses a single process.</short>
	/// 		<see> KApplication</see>
	[SmokeClass("KUniqueApplication")]
	public class KUniqueApplication : KApplication, IDisposable {
 		protected KUniqueApplication(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KUniqueApplication), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KUniqueApplication() {
			staticInterceptor = new SmokeInvocation(typeof(KUniqueApplication), null);
		}
		/// <remarks> 
		///  These flags can be used to specify how new instances of 
		///  unique applications are created.
		///    </remarks>		<short>     These flags can be used to specify how new instances of   unique applications are created.</short>
		public enum StartFlag {
			NonUniqueInstance = 0x1,
		}
		/// <remarks>
		///  Constructor. Takes command line arguments from KCmdLineArgs
		/// <param> name="GUIenabled" Set to false to disable all GUI stuff. This implies
		///  no styles either.
		/// </param><param> name="configUnique" If true, the uniqueness of the application will
		///                  depend on the value of the "MultipleInstances"
		///                  key in the "KDE" group of the application config file.
		///    </param></remarks>		<short>    Constructor.</short>
		public KUniqueApplication(bool GUIenabled, bool configUnique) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication$$", "KUniqueApplication(bool, bool)", typeof(void), typeof(bool), GUIenabled, typeof(bool), configUnique);
		}
		public KUniqueApplication(bool GUIenabled) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication$", "KUniqueApplication(bool)", typeof(void), typeof(bool), GUIenabled);
		}
		public KUniqueApplication() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication", "KUniqueApplication()", typeof(void));
		}
		/// <remarks>
		///  Creates a new "instance" of the application.
		///  Usually this will involve making some calls into the GUI portion of your
		///  application asking for a new window to be created, possibly with
		///  some data already loaded based on the arguments received.
		///  Command line arguments have been passed to KCmdLineArgs before this
		///  function is called and can be checked in the usual way.
		///  The default implementation ensures the mainwindow of the already
		///  running instance is shown and activated if necessary. If your
		///  application has only one mainwindow, you should call this default
		///  implementation and only add your special handling if needed.
		///  Note that newInstance() is called also in the first started
		///  application process.
		///  For applications that share one process for several mainwindows,
		///  the reimplementation could be:
		///  <pre>
		///     int MyApp.NewInstance()
		///     {
		///     KCmdLineArgs.SetCwd(QDir.CurrentPath().toUtf8());
		///     KCmdLineArgs args = KCmdLineArgs.ParsedArgs();
		///     static bool first = true;
		///     if (args.Count() > 0) {
		///         for (int i = 0; i < args.Count(); ++i) {
		///             openWindow(args.Url(i));
		///         }
		///     } else if( !first || !isSessionRestored()) {
		///         openWindow(KUrl()); // create a new window
		///     }
		///     first = false;
		///     args.Clear();
		///     return 0;
		///     }
		///  </pre>
		/// </remarks>		<return> An exit value. The calling process will exit with this value.
		///    </return>
		/// 		<short>    Creates a new "instance" of the application.</short>
		[SmokeMethod("newInstance()")]
		public virtual int NewInstance() {
			return (int) interceptor.Invoke("newInstance", "newInstance()", typeof(int));
		}
		/// <remarks>
		///  Returns whether newInstance() is being called while session
		///  restoration is in progress.
		///    </remarks>		<short>    Returns whether newInstance() is being called while session  restoration is in progress.</short>
		public bool RestoringSession() {
			return (bool) interceptor.Invoke("restoringSession", "restoringSession()", typeof(bool));
		}
		~KUniqueApplication() {
			interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
		}
		/// <remarks>
		///  Adds command line options specific for KUniqueApplication.
		///  Should be called before calling KUniqueApplication constructor
		///  and / or start().
		///    </remarks>		<short>    Adds command line options specific for KUniqueApplication.</short>
		public static void AddCmdLineOptions() {
			staticInterceptor.Invoke("addCmdLineOptions", "addCmdLineOptions()", typeof(void));
		}
		/// <remarks>
		///  Forks and registers with D-Bus.
		///  The command line arguments are being sent via D-Bus to newInstance()
		///  and will be received once the application enters the event loop.
		///  Typically this is used like:
		///  <pre>
		///  int main(string[] args) {
		///     KAboutData about("myappname", 0, ki18n("myAppName"), .....);
		///     KCmdLineArgs.Init(args, &about);
		///     KCmdLineArgs.AddCmdLineOptions( myCmdOptions );
		///     KUniqueApplication.AddCmdLineOptions();
		///     if (!KUniqueApplication.Start()) {
		///        fprintf(stderr, "myAppName is already running!\n");
		///        return 0;
		///     }
		///     KUniqueApplication a;
		///     return a.exec();
		///  }
		///  </pre>
		///  Note that it's not necessary to call start() explicitly. It will be
		///  called automatically before creating KUniqueApplication if it hasn't
		///  been called yet, without any performance impact.
		///  Also note that you MUST call KUniqueApplication.AddCmdLineOptions(),
		///  if you use command line options before start() is called.
		/// <param> name="flags" Optional flags which control how a new instance 
		///  				of the application is started.
		/// </param></remarks>		<return> true if registration is successful.
		///          false if another process was already running.
		///    </return>
		/// 		<short>    Forks and registers with D-Bus.</short>
		public static bool Start(uint flags) {
			return (bool) staticInterceptor.Invoke("start$", "start(KUniqueApplication::StartFlags)", typeof(bool), typeof(uint), flags);
		}
		public static bool Start() {
			return (bool) staticInterceptor.Invoke("start", "start()", typeof(bool));
		}
		/// <remarks>
		///    </remarks>		<short>   </short>
		public static void SetHandleAutoStarted() {
			staticInterceptor.Invoke("setHandleAutoStarted", "setHandleAutoStarted()", typeof(void));
		}
		protected new IKUniqueApplicationSignals Emit {
			get { return (IKUniqueApplicationSignals) Q_EMIT; }
		}
	}

	public interface IKUniqueApplicationSignals : IKApplicationSignals {
	}
}
