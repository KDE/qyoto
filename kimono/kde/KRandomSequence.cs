//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  \class KRandomSequence krandomsequence.h <KRandomSequence>
	///  A class to create a pseudo-random sequence
	///  Given a seed number, this class will produce a sequence of
	///  pseudo-random numbers.  This would typically be used in
	///  applications like games.
	///  In general, you should instantiate a KRandomSequence object and
	///  pass along your seed number in the constructor.  From then on,
	///  simply call getDouble or getLong to obtain the next
	///  number in the sequence.
	/// </remarks>		<author> Sean Harmer <sh@astro.keele.ac.uk>
	///  </author>
	/// 		<short>    \class KRandomSequence krandomsequence.</short>

	[SmokeClass("KRandomSequence")]
	public class KRandomSequence : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KRandomSequence(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KRandomSequence), this);
		}
		/// <remarks>
		///  Creates a pseudo-random sequence based on the seed lngSeed.
		///  A Pseudo-random sequence is different for each seed but can be
		///  reproduced by starting the sequence with the same seed.
		///  If you need a single value which needs to be unpredictable,
		///  you need to use KRandom.Random() instead.
		/// <param> name="lngSeed" Seed to initialize the sequence with.
		///  If lngSeed is 0, the sequence is initialized with a value from
		///  KRandom.Random().
		///    </param></remarks>		<short>    Creates a pseudo-random sequence based on the seed lngSeed.</short>
		public KRandomSequence(long lngSeed) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KRandomSequence$", "KRandomSequence(long)", typeof(void), typeof(long), lngSeed);
		}
		public KRandomSequence() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KRandomSequence", "KRandomSequence()", typeof(void));
		}
		/// <remarks>
		///  Copy constructor
		///    </remarks>		<short>    Copy constructor    </short>
		public KRandomSequence(KRandomSequence a) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KRandomSequence#", "KRandomSequence(const KRandomSequence&)", typeof(void), typeof(KRandomSequence), a);
		}
		/// <remarks>
		///  Restart the sequence based on lngSeed.
		/// <param> name="lngSeed" Seed to initialize the sequence with.
		///  If lngSeed is 0, the sequence is initialized with a value from
		///  KRandom.Random().
		///    </param></remarks>		<short>    Restart the sequence based on lngSeed.</short>
		public void SetSeed(long lngSeed) {
			interceptor.Invoke("setSeed$", "setSeed(long)", typeof(void), typeof(long), lngSeed);
		}
		public void SetSeed() {
			interceptor.Invoke("setSeed", "setSeed()", typeof(void));
		}
		/// <remarks>
		///  Get the next number from the pseudo-random sequence.
		/// </remarks>		<return> a pseudo-random double value between [0,1)
		///    </return>
		/// 		<short>    Get the next number from the pseudo-random sequence.</short>
		public double GetDouble() {
			return (double) interceptor.Invoke("getDouble", "getDouble()", typeof(double));
		}
		/// <remarks>
		///  Get the next number from the pseudo-random sequence.
		/// </remarks>		<return> a pseudo-random integer value between [0, max)
		///  with 0 <= max < 1.000.000
		///    </return>
		/// 		<short>    Get the next number from the pseudo-random sequence.</short>
		public ulong GetLong(ulong max) {
			return (ulong) interceptor.Invoke("getLong$", "getLong(unsigned long)", typeof(ulong), typeof(ulong), max);
		}
		/// <remarks>
		///  Get a boolean from the pseudo-random sequence.
		/// </remarks>		<return> a boolean which is either true or false
		///    </return>
		/// 		<short>    Get a boolean from the pseudo-random sequence.</short>
		public bool GetBool() {
			return (bool) interceptor.Invoke("getBool", "getBool()", typeof(bool));
		}
		/// <remarks>
		///  Modulate the random sequence.
		///  If S(i) is the sequence of numbers that will follow
		///  given the current state after calling modulate(i),
		///  then S(i) != S(j) for i != j and
		///       S(i) == S(j) for i == j.
		///  This can be useful in game situation where "undo" restores
		///  the state of the random sequence. If the game modulates the
		///  random sequence with the move chosen by the player, the
		///  random sequence will be identical whenever the player "redo"-s
		///  his or hers original move, but different when the player
		///  chooses another move.
		///  With this scenario "undo" can no longer be used to repeat a
		///  certain move over and over again until the computer reacts
		///  with a favorable response or to predict the response for a
		///  certain move based on the response to another move.
		/// <param> name="i" the sequence identified
		///    </param></remarks>		<short>    Modulate the random sequence.</short>
		public void Modulate(int i) {
			interceptor.Invoke("modulate$", "modulate(int)", typeof(void), typeof(int), i);
		}
		~KRandomSequence() {
			interceptor.Invoke("~KRandomSequence", "~KRandomSequence()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KRandomSequence", "~KRandomSequence()", typeof(void));
		}
	}
}
