//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  \class KSaveFile ksavefile.h <KSaveFile>
	///  @brief Class to allow for atomic file I/O, as well as utility functions.
	///  The KSaveFile class has been made to write out changes to an existing
	///  file atomically. This means that either <b>ALL</b> changes will be written
	///  to the file, or <b>NO</b> changes have been written, and the original file
	///  (if any) has been unchanged. This is useful if you have lots of 
	///  time-consuming processing to perform during which an interruption could
	///  occur, or if any error in the file structure will cause the entire file
	///  to be corrupt.
	///  When you create a KSaveFile for a given file, a temporary file is instead
	///  created and all your I/O occurs in the save file. Once you call finalize()
	///  the temporary file is renamed to the target file, so that all your changes
	///  happen at once. If abort() is called then the temporary file is removed and
	///  the target file is untouched. KSaveFile derives from QFile so you can use
	///  it just as you would a normal QFile.
	///  This class also includes several static utility functions available that
	///  can help ensure data integrity. See the individual functions for details.
	///  Here is a quick example of how to use KSaveFile:
	///  First we create the KSaveFile and open it.
	///  @code
	///  KSaveFile saveFile;
	///  saveFile.setFileName("/lib/foo/bar.dat");
	///  if ( !saveFile.open() ) {
	///      //Handle error
	///  }
	///  @endcode
	///  At this point the file "/lib/foo/bar.dat" has not been altered in any way.
	///  Now, let's write out some data to the file.
	///  @code
	///  QTextStream stream ( &saveFile );
	///  stream << "Add some data.";
	///  // Perform long processing
	///  stream << "Add some more data.";
	///  stream.flush();
	///  @endcode
	///  Even after writing this data, the target file "/lib/foo/bar.dat" still has
	///  not been altered in any way. Now that we are done writing our data, we can
	///  write out all the changes that we have made by calling finalize().
	///  @code
	///  if ( !saveFile.finalize() ) {
	///      //Handle error
	///  }
	///  @endcode
	///  If a user interruption or error occurred while we were writing out our
	///  changes, we would instead call abort() to cancel all the I/O without
	///  affecting the target file.
	/// </remarks>		<author> Waldo Bastian <bastian@kde.org>
	///  </author>
	/// 		<short>    \class KSaveFile ksavefile.</short>
	/// 		<see> QFile</see>

	[SmokeClass("KSaveFile")]
	public class KSaveFile : QFile, IDisposable {
 		protected KSaveFile(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KSaveFile), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KSaveFile() {
			staticInterceptor = new SmokeInvocationKDE(typeof(KSaveFile), null);
		}
		/// <remarks>
		///  Default constructor.
		///      </remarks>		<short>    Default constructor.</short>
		public KSaveFile() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSaveFile", "KSaveFile()", typeof(void));
		}
		/// <remarks>
		///  Creates a new KSaveFile and sets the target file to <code>filename.</code>
		/// <param> name="filename" the path of the file
		/// </param><param> name="componentData" The KComponentData to use for the temporary file.
		///      </param></remarks>		<short>    Creates a new KSaveFile and sets the target file to <code>filename.</code></short>
		public KSaveFile(string filename, KComponentData componentData) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSaveFile$#", "KSaveFile(const QString&, const KComponentData&)", typeof(void), typeof(string), filename, typeof(KComponentData), componentData);
		}
		public KSaveFile(string filename) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSaveFile$", "KSaveFile(const QString&)", typeof(void), typeof(string), filename);
		}
		/// <remarks>
		///  @brief Set the target filename for the save file.
		///  You must use this to set the filename of the target file if you do
		///  not use the contructor that does so.
		/// <param> name="filename" Name of the target file.
		///      </param></remarks>		<short>    @brief Set the target filename for the save file.</short>
		public new void SetFileName(string filename) {
			interceptor.Invoke("setFileName$", "setFileName(const QString&)", typeof(void), typeof(string), filename);
		}
		/// <remarks>
		///  @brief Returns the name of the target file.
		///  This function returns the name of the target file, or an empty
		///  string if it has not yet been set.
		/// </remarks>		<return> The name of the target file.
		///      </return>
		/// 		<short>    @brief Returns the name of the target file.</short>
		public new string FileName() {
			return (string) interceptor.Invoke("fileName", "fileName() const", typeof(string));
		}
		/// <remarks>
		///  @brief Returns the last error that occurred.
		///  Use this function to check for errors.
		/// </remarks>		<return> The last error that occurred, or QFile.NoError.
		///      </return>
		/// 		<short>    @brief Returns the last error that occurred.</short>
		public new QFile.FileError Error() {
			return (QFile.FileError) interceptor.Invoke("error", "error() const", typeof(QFile.FileError));
		}
		/// <remarks>
		///  @brief Returns a human-readable description of the last error.
		///  Use this function to get a human-readable description of the
		///  last error that occurred.
		/// </remarks>		<return> A string describing the last error that occurred.
		///      </return>
		/// 		<short>    @brief Returns a human-readable description of the last error.</short>
		public new string ErrorString() {
			return (string) interceptor.Invoke("errorString", "errorString() const", typeof(string));
		}
		/// <remarks>
		///  @brief Open the save file.
		///  This function will open the save file by creating a temporary file to write
		///  to. It will also check to ensure that there are sufficient permissions to
		///  write to the target file.
		/// <param> name="flags" Sets the QIODevice.OpenMode. It should contain the write flag, otherwise you
		///  have a save file you cannot save to.
		/// </param></remarks>		<return> true if successful, or false if an error has occurred.
		///      </return>
		/// 		<short>    @brief Open the save file.</short>
		[SmokeMethod("open(QIODevice::OpenMode)")]
		public override bool Open(uint flags) {
			return (bool) interceptor.Invoke("open$", "open(QIODevice::OpenMode)", typeof(bool), typeof(uint), flags);
		}
		[SmokeMethod("open()")]
		public virtual bool Open() {
			return (bool) interceptor.Invoke("open", "open()", typeof(bool));
		}
		/// <remarks>
		///  @brief Discard changes without affecting the target file.
		///  This will discard all changes that have been made to this file.
		///  The target file will not be altered in any way.
		/// </remarks>		<short>    @brief Discard changes without affecting the target file.</short>
		public void Abort() {
			interceptor.Invoke("abort", "abort()", typeof(void));
		}
		~KSaveFile() {
			interceptor.Invoke("~KSaveFile", "~KSaveFile()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KSaveFile", "~KSaveFile()", typeof(void));
		}
		/// <remarks>
		///  @brief Static method to create a backup file before saving.
		///  If empty (the default), the backup will be in the same directory as <code>filename.</code>
		///  The backup type (simple, rcs, or numbered), extension string, and maximum
		///  number of backup files are read from the user's global configuration.
		///  Use simpleBackupFile() or numberedBackupFile() to force one of these
		///  specific backup styles.
		///  You can use this method even if you don't use KSaveFile.
		/// <param> name="filename" the file to backup
		/// </param><param> name="backupDir" optional directory where to save the backup file in.
		/// </param></remarks>		<return> true if successful, or false if an error has occurred.
		///      </return>
		/// 		<short>    @brief Static method to create a backup file before saving.</short>
		public static bool BackupFile(string filename, string backupDir) {
			return (bool) staticInterceptor.Invoke("backupFile$$", "backupFile(const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir);
		}
		public static bool BackupFile(string filename) {
			return (bool) staticInterceptor.Invoke("backupFile$", "backupFile(const QString&)", typeof(bool), typeof(string), filename);
		}
		/// <remarks>
		///  @brief Static method to create a backup file for a given filename.
		///  This function creates a backup file from the given filename.
		///  You can use this method even if you don't use KSaveFile.
		/// <param> name="filename" the file to backup
		/// </param><param> name="backupDir" optional directory where to save the backup file in.
		///  If empty (the default), the backup will be in the same directory as <code>filename.</code>
		/// </param><param> name="backupExtension" the extension to append to <code>filename</code>, "~" by default.
		/// </param></remarks>		<return> true if successful, or false if an error has occurred.
		///      </return>
		/// 		<short>    @brief Static method to create a backup file for a given filename.</short>
		public static bool SimpleBackupFile(string filename, string backupDir, string backupExtension) {
			return (bool) staticInterceptor.Invoke("simpleBackupFile$$$", "simpleBackupFile(const QString&, const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir, typeof(string), backupExtension);
		}
		public static bool SimpleBackupFile(string filename, string backupDir) {
			return (bool) staticInterceptor.Invoke("simpleBackupFile$$", "simpleBackupFile(const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir);
		}
		public static bool SimpleBackupFile(string filename) {
			return (bool) staticInterceptor.Invoke("simpleBackupFile$", "simpleBackupFile(const QString&)", typeof(bool), typeof(string), filename);
		}
		/// <remarks>
		///  @brief Static method to create a backup file for a given filename.
		///  This function creates a series of numbered backup files from the
		///  given filename.
		///  The backup file names will be of the form:
		///      \<name\>.\<number\>\<extension\>
		///  for instance
		///      <pre> chat.3.log </pre>
		///  The new backup file will be have the backup number 1.
		///  Each existing backup file will have its number incremented by 1.
		///  Any backup files with numbers greater than the maximum number
		///  permitted (<code>maxBackups</code>) will be removed.
		///  You can use this method even if you don't use KSaveFile.
		/// <param> name="filename" the file to backup
		/// </param><param> name="backupDir" optional directory where to save the backup file in.
		///  If empty (the default), the backup will be in the same directory as
		///  <code>filename.</code>
		/// </param><param> name="backupExtension" the extension to append to <code>filename</code>,
		///  which is "~" by default.  Do not use an extension containing digits.
		/// </param><param> name="maxBackups" the maximum number of backup files permitted.
		///  For best performance a small number (10) is recommended.
		/// </param></remarks>		<return> true if successful, or false if an error has occurred.
		///      </return>
		/// 		<short>    @brief Static method to create a backup file for a given filename.</short>
		public static bool NumberedBackupFile(string filename, string backupDir, string backupExtension, uint maxBackups) {
			return (bool) staticInterceptor.Invoke("numberedBackupFile$$$$", "numberedBackupFile(const QString&, const QString&, const QString&, const uint)", typeof(bool), typeof(string), filename, typeof(string), backupDir, typeof(string), backupExtension, typeof(uint), maxBackups);
		}
		public static bool NumberedBackupFile(string filename, string backupDir, string backupExtension) {
			return (bool) staticInterceptor.Invoke("numberedBackupFile$$$", "numberedBackupFile(const QString&, const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir, typeof(string), backupExtension);
		}
		public static bool NumberedBackupFile(string filename, string backupDir) {
			return (bool) staticInterceptor.Invoke("numberedBackupFile$$", "numberedBackupFile(const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir);
		}
		public static bool NumberedBackupFile(string filename) {
			return (bool) staticInterceptor.Invoke("numberedBackupFile$", "numberedBackupFile(const QString&)", typeof(bool), typeof(string), filename);
		}
		/// <remarks>
		///  @brief Static method to create an rcs backup file for a given filename.
		///  This function creates a rcs-formatted backup file from the
		///  given filename.
		///  The backup file names will be of the form:
		///      \<name\>,v
		///  for instance
		///      <pre> photo.jpg,v </pre>
		///  The new backup file will be in RCS format.
		///  Each existing backup file will be committed as a new revision.
		///  You can use this method even if you don't use KSaveFile.
		/// <param> name="filename" the file to backup
		/// </param><param> name="backupDir" optional directory where to save the backup file in.
		///  If empty (the default), the backup will be in the same directory as
		///  <code>filename.</code>
		/// </param><param> name="backupMessage" is the RCS commit message for this revision.
		/// </param></remarks>		<return> true if successful, or false if an error has occurred.
		///      </return>
		/// 		<short>    @brief Static method to create an rcs backup file for a given filename.</short>
		public static bool RcsBackupFile(string filename, string backupDir, string backupMessage) {
			return (bool) staticInterceptor.Invoke("rcsBackupFile$$$", "rcsBackupFile(const QString&, const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir, typeof(string), backupMessage);
		}
		public static bool RcsBackupFile(string filename, string backupDir) {
			return (bool) staticInterceptor.Invoke("rcsBackupFile$$", "rcsBackupFile(const QString&, const QString&)", typeof(bool), typeof(string), filename, typeof(string), backupDir);
		}
		public static bool RcsBackupFile(string filename) {
			return (bool) staticInterceptor.Invoke("rcsBackupFile$", "rcsBackupFile(const QString&)", typeof(bool), typeof(string), filename);
		}
		protected new IKSaveFileSignals Emit {
			get { return (IKSaveFileSignals) Q_EMIT; }
		}
	}

	public interface IKSaveFileSignals : IQFileSignals {
	}
}
