//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  A KZipFileEntry represents an file in a zip archive.
	///  </remarks>		<short>    A KZipFileEntry represents an file in a zip archive.</short>

	[SmokeClass("KZipFileEntry")]
	public class KZipFileEntry : KArchiveFile, IDisposable {
 		protected KZipFileEntry(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KZipFileEntry), this);
		}
		/// <remarks>
		///  Creates a new zip file entry. Do not call this, KZip takes care of it.
		///      </remarks>		<short>    Creates a new zip file entry.</short>
		public KZipFileEntry(KZip zip, string name, int access, int date, string user, string group, string symlink, string path, long start, long uncompressedSize, int encoding, long compressedSize) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KZipFileEntry#$$$$$$$$$$$", "KZipFileEntry(KZip*, const QString&, int, int, const QString&, const QString&, const QString&, const QString&, qint64, qint64, int, qint64)", typeof(void), typeof(KZip), zip, typeof(string), name, typeof(int), access, typeof(int), date, typeof(string), user, typeof(string), group, typeof(string), symlink, typeof(string), path, typeof(long), start, typeof(long), uncompressedSize, typeof(int), encoding, typeof(long), compressedSize);
		}
		public int Encoding() {
			return (int) interceptor.Invoke("encoding", "encoding() const", typeof(int));
		}
		public long CompressedSize() {
			return (long) interceptor.Invoke("compressedSize", "compressedSize() const", typeof(long));
		}
		public void SetCompressedSize(long compressedSize) {
			interceptor.Invoke("setCompressedSize$", "setCompressedSize(qint64)", typeof(void), typeof(long), compressedSize);
		}
		public void SetHeaderStart(long headerstart) {
			interceptor.Invoke("setHeaderStart$", "setHeaderStart(qint64)", typeof(void), typeof(long), headerstart);
		}
		public long HeaderStart() {
			return (long) interceptor.Invoke("headerStart", "headerStart() const", typeof(long));
		}
		public ulong Crc32() {
			return (ulong) interceptor.Invoke("crc32", "crc32() const", typeof(ulong));
		}
		public void SetCRC32(ulong crc32) {
			interceptor.Invoke("setCRC32$", "setCRC32(unsigned long)", typeof(void), typeof(ulong), crc32);
		}
		public string Path() {
			return (string) interceptor.Invoke("path", "path() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> the content of this file.
		///  Call data() with care (only once per file), this data isn't cached.
		///      </return>
		/// 		<short>   </short>
		[SmokeMethod("data() const")]
		public override QByteArray Data() {
			return (QByteArray) interceptor.Invoke("data", "data() const", typeof(QByteArray));
		}
		/// <remarks>
		///  This method returns a QIODevice to read the file contents.
		///  This is obviously for reading only.
		///  Note that the ownership of the device is being transferred to the caller,
		///  who will have to delete it.
		///  The returned device auto-opens (in readonly mode), no need to open it.
		///      </remarks>		<short>    This method returns a QIODevice to read the file contents.</short>
		[SmokeMethod("createDevice() const")]
		public override QIODevice CreateDevice() {
			return (QIODevice) interceptor.Invoke("createDevice", "createDevice() const", typeof(QIODevice));
		}
		~KZipFileEntry() {
			interceptor.Invoke("~KZipFileEntry", "~KZipFileEntry()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KZipFileEntry", "~KZipFileEntry()", typeof(void));
		}
	}
}
