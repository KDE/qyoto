//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  Top level widget that provides toolbars, a status line and a frame.
	///  It should be used as a top level (parent-less) widget.
	///  It manages the geometry for all its children, including your
	///  main widget.
	///  Normally, you will inherit from KMainWindow,
	///  then construct (or use some existing) widget as
	///  your main view. You can set only one main view.
	///  You can add as many toolbars as you like. There can be only one menubar
	///  and only one statusbar.
	///  The toolbars, menubar, and statusbar can be created by the
	///  KMainWindow and - unlike the old KMainWindow - may, but do not
	///  have to, be deleted by you. KMainWindow will handle that internally.
	///  Height and width can be operated independently from each other. Simply
	///  define the minimum/maximum height/width of your main widget and
	///  KMainWindow will take this into account. For fixed size windows set
	///  your main widget to a fixed size.
	///  Fixed aspect ratios (heightForWidth()) and fixed width widgets are
	///  not supported.
	///  KMainWindow will set icon, mini icon and caption, which it gets
	///  from KApplication. It provides full session management, and
	///  will save its position, geometry and positions of toolbars and
	///  menubar on logout. If you want to save additional data, reimplement
	///  saveProperties() and (to read them again on next login)
	///  readProperties(). To save special data about your data, reimplement
	///  saveGlobalProperties(). To warn user that application or
	///  windows have unsaved data on close or logout, reimplement
	///  queryClose() and/or queryExit().
	///  There are also kRestoreMainWindows convenience functions which
	///  can restore all your windows on next login.
	///  Note that KMainWindow uses KGlobal.Ref() and KGlobal.Deref() so that closing
	///  the last mainwindow will quit the application unless there is still something
	///  that holds a ref in KGlobal - like a KIO job, or a systray icon.
	/// </remarks>		<author> Reginald Stadlbauer (reggie@kde.org) Stephan Kulow (coolo@kde.org), Matthias Ettrich (ettrich@kde.org), Chris Schlaeger (cs@kde.org), Sven Radej (radej@kde.org). Maintained by David Faure (faure@kde.org)
	///  </author>
	/// 		<short> %KDE top level main window.</short>
	/// 		<see> KApplication</see>

	[SmokeClass("KMainWindow")]
	public class KMainWindow : QMainWindow, IDisposable {
 		protected KMainWindow(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KMainWindow), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KMainWindow() {
			staticInterceptor = new SmokeInvocation(typeof(KMainWindow), null);
		}
		[Q_PROPERTY("bool", "hasMenuBar")]
		public bool HasMenuBar {
			get { return (bool) interceptor.Invoke("hasMenuBar", "hasMenuBar()", typeof(bool)); }
		}
		[Q_PROPERTY("bool", "autoSaveSettings")]
		public bool AutoSaveSettings {
			get { return (bool) interceptor.Invoke("autoSaveSettings", "autoSaveSettings()", typeof(bool)); }
		}
		[Q_PROPERTY("QString", "autoSaveGroup")]
		public string AutoSaveGroup {
			get { return (string) interceptor.Invoke("autoSaveGroup", "autoSaveGroup()", typeof(string)); }
		}
		[Q_PROPERTY("bool", "initialGeometrySet")]
		public bool InitialGeometrySet {
			get { return (bool) interceptor.Invoke("initialGeometrySet", "initialGeometrySet()", typeof(bool)); }
		}
		// KMainWindow* KMainWindow(KMainWindowPrivate& arg1,QWidget* arg2,Qt::WFlags arg3); >>>> NOT CONVERTED
		/// <remarks>
		///  Construct a main window.
		/// <param> name="parent" The widget parent. This is usually 0 but it may also be the window
		///  group leader. In that case, the KMainWindow becomes sort of a
		///  secondary window.
		/// </param><param> name="f" Specify the window flags. The default is none.
		/// </param> Note that a KMainWindow per-default is created with the
		///  WA_DeleteOnClose attribute, i.e. it is automatically destroyed when the
		///  window is closed. If you do not want this behavior, call
		///  setAttribute(Qt.WA_DeleteOnClose, false);
		///  KMainWindows must be created on the heap with 'new', like:
		///  <pre>
		///  KMainWindow kmw = new KMainWindow(...);
		///  kmw.SetObjectName(...);
		///  </pre>
		///  IMPORTANT: For session management and window management to work
		///  properly, all main windows in the application should have a
		///  different name. If you don't do it, KMainWindow will create
		///  a unique name, but it's recommended to explicitly pass a window name that will
		///  also describe the type of the window. If there can be several windows of the same
		///  type, append '#' (hash) to the name, and KMainWindow will replace it with numbers to make
		///  the names unique. For example, for a mail client which has one main window showing
		///  the mails and folders, and which can also have one or more windows for composing
		///  mails, the name for the folders window should be e.g. "mainwindow" and
		///  for the composer windows "composer#".
		///      </remarks>		<short>    Construct a main window.</short>
		public KMainWindow(QWidget parent, uint f) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMainWindow#$", "KMainWindow(QWidget*, Qt::WindowFlags)", typeof(void), typeof(QWidget), parent, typeof(uint), f);
		}
		public KMainWindow(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMainWindow#", "KMainWindow(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KMainWindow() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMainWindow", "KMainWindow()", typeof(void));
		}
		/// <remarks>
		///  Retrieve the standard help menu.
		///  It contains entries for the
		///  help system (activated by F1), an optional "What's This?" entry
		///  (activated by Shift F1), an application specific dialog box,
		///  and an "About KDE" dialog box.
		///  Example (adding a standard help menu to your application):
		///  <pre>
		///  KMenu help = helpMenu( <myTextString> );
		///  menuBar().AddMenu( help );
		///  </pre>
		/// <param> name="aboutAppText" The string that is used in the application
		///         specific dialog box. If you leave this string empty the
		///         information in the global KAboutData of the
		///         application will be used to make a standard dialog box.
		/// </param><param> name="showWhatsThis" Set this to false if you do not want to include
		///         the "What's This" menu entry.
		/// </param></remarks>		<return> A standard help menu.
		///      </return>
		/// 		<short>    Retrieve the standard help menu.</short>
		public KMenu HelpMenu(string aboutAppText, bool showWhatsThis) {
			return (KMenu) interceptor.Invoke("helpMenu$$", "helpMenu(const QString&, bool)", typeof(KMenu), typeof(string), aboutAppText, typeof(bool), showWhatsThis);
		}
		public KMenu HelpMenu(string aboutAppText) {
			return (KMenu) interceptor.Invoke("helpMenu$", "helpMenu(const QString&)", typeof(KMenu), typeof(string), aboutAppText);
		}
		public KMenu HelpMenu() {
			return (KMenu) interceptor.Invoke("helpMenu", "helpMenu()", typeof(KMenu));
		}
		/// <remarks>
		///  Returns the help menu. Creates a standard help menu if none exists yet.
		///  It contains entries for the
		///  help system (activated by F1), an optional "What's This?" entry
		///  (activated by Shift F1), an application specific dialog box,
		///  and an "About KDE" dialog box. You must create the application
		///  specific dialog box yourself. When the "About application"
		///  menu entry is activated, a signal will trigger the
		///  showAboutApplication slot. See showAboutApplication for more
		///  information.
		///  Example (adding a help menu to your application):
		///  <pre>
		///  menuBar().AddMenu( customHelpMenu() );
		///  </pre>
		/// <param> name="showWhatsThis" Set this to <code>false</code> if you do not want to include
		///         the "What's This" menu entry.
		/// </param></remarks>		<return> A standard help menu.
		///      </return>
		/// 		<short>    Returns the help menu.</short>
		public KMenu CustomHelpMenu(bool showWhatsThis) {
			return (KMenu) interceptor.Invoke("customHelpMenu$", "customHelpMenu(bool)", typeof(KMenu), typeof(bool), showWhatsThis);
		}
		public KMenu CustomHelpMenu() {
			return (KMenu) interceptor.Invoke("customHelpMenu", "customHelpMenu()", typeof(KMenu));
		}
		/// <remarks>
		///  Restore the session specified by <code>number.</code>
		///  Returns <code>false</code> if this
		///  fails, otherwise returns <code>true</code> and shows the window.
		///  You should call canBeRestored() first.
		///  If <code>show</code> is true (default), this widget will be shown automatically.
		///      </remarks>		<short>    Restore the session specified by <code>number.</code></short>
		public bool Restore(int number, bool show) {
			return (bool) interceptor.Invoke("restore$$", "restore(int, bool)", typeof(bool), typeof(int), number, typeof(bool), show);
		}
		public bool Restore(int number) {
			return (bool) interceptor.Invoke("restore$", "restore(int)", typeof(bool), typeof(int), number);
		}
		/// <remarks>
		///  Returns a pointer to the menu bar.
		///  If there is no menu bar yet one will be created.
		/// </remarks>		<short>    Returns a pointer to the menu bar.</short>
		public KMenuBar MenuBar() {
			return (KMenuBar) interceptor.Invoke("menuBar", "menuBar()", typeof(KMenuBar));
		}
		/// <remarks>
		///  Returns a pointer to the status bar.
		///  If there is no status bar yet, one will be created.
		///  Note that tooltips for kactions in actionCollection() are not
		///  automatically connected to this statusBar.
		///  See the KActionCollection documentation for more details.
		/// </remarks>		<short>    Returns a pointer to the status bar.</short>
		/// 		<see> KActionCollection</see>
		public KStatusBar StatusBar() {
			return (KStatusBar) interceptor.Invoke("statusBar", "statusBar()", typeof(KStatusBar));
		}
		/// <remarks>
		///  Returns a pointer to the toolbar with the specified name.
		///  This refers to toolbars created dynamically from the XML UI
		///  framework.  If the toolbar does not exist one will be created.
		/// <param> name="name" The internal name of the toolbar. If no name is
		///              specified "mainToolBar" is assumed.
		/// </param></remarks>		<return> A pointer to the toolbar
		/// </return>
		/// 		<short>    Returns a pointer to the toolbar with the specified name.</short>
		public KToolBar ToolBar(string name) {
			return (KToolBar) interceptor.Invoke("toolBar$", "toolBar(const QString&)", typeof(KToolBar), typeof(string), name);
		}
		public KToolBar ToolBar() {
			return (KToolBar) interceptor.Invoke("toolBar", "toolBar()", typeof(KToolBar));
		}
		/// <remarks>
		/// </remarks>		<return> A list of all toolbars for this window
		///      </return>
		/// 		<short>   </short>
		public List<KToolBar> ToolBars() {
			return (List<KToolBar>) interceptor.Invoke("toolBars", "toolBars() const", typeof(List<KToolBar>));
		}
		/// <remarks>
		///  Call this to enable "auto-save" of toolbar/menubar/statusbar settings
		///  (and optionally window size).
		///  If the bars were moved around/shown/hidden when the window is closed,
		///  saveMainWindowSettings( KConfigGroup(KGlobal.Config(), groupName) ) will be called.
		/// <param> name="groupName" a name that identifies this "type of window".
		///  You can have several types of window in the same application.
		/// </param><param> name="saveWindowSize" set it to true to include the window size
		///  when saving.
		/// </param> Typically, you will call setAutoSaveSettings() in your
		///  KMainWindow-inherited class constructor, and it will take care
		///  of restoring and saving automatically. Make sure you call this
		///  _after all_ your bars have been created.
		///  To make sure that KMainWindow propertly obtains the default
		///  size of the window you should do the following:
		///  - Remove hard coded resize() calls in the constructor or main, they
		///    should be removed in favor of letting the automatic resizing
		///    determine the default window size.  Hard coded window sizes will
		///    be wrong for users that have big fonts, use different styles,
		///    long/small translations, large toolbars, and other factors.
		///  - Put the setAutoSaveSettings ( or setupGUI() ) call after all widgets
		///    have been created and placed inside the main window (i.e. for 99% of
		///    apps setCentralWidget())
		///  - Widgets that inherit from QWidget (like game boards) should overload
		///    "QSize sizeHint() const;" to specify a default size rather
		///    than letting QWidget.Adjust use the default size of 0x0.
		///      </remarks>		<short>    Call this to enable "auto-save" of toolbar/menubar/statusbar settings  (and optionally window size).</short>
		public void SetAutoSaveSettings(string groupName, bool saveWindowSize) {
			interceptor.Invoke("setAutoSaveSettings$$", "setAutoSaveSettings(const QString&, bool)", typeof(void), typeof(string), groupName, typeof(bool), saveWindowSize);
		}
		public void SetAutoSaveSettings(string groupName) {
			interceptor.Invoke("setAutoSaveSettings$", "setAutoSaveSettings(const QString&)", typeof(void), typeof(string), groupName);
		}
		public void SetAutoSaveSettings() {
			interceptor.Invoke("setAutoSaveSettings", "setAutoSaveSettings()", typeof(void));
		}
		/// <remarks>
		///  Overload that lets you specify a KConfigGroup.
		///  This allows the settings to be saved into another file than KGlobal.Config().
		/// </remarks>		<short>    Overload that lets you specify a KConfigGroup.</short>
		public void SetAutoSaveSettings(KConfigGroup group, bool saveWindowSize) {
			interceptor.Invoke("setAutoSaveSettings#$", "setAutoSaveSettings(const KConfigGroup&, bool)", typeof(void), typeof(KConfigGroup), group, typeof(bool), saveWindowSize);
		}
		public void SetAutoSaveSettings(KConfigGroup group) {
			interceptor.Invoke("setAutoSaveSettings#", "setAutoSaveSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), group);
		}
		/// <remarks>
		///  Disable the auto-save-settings feature.
		///  You don't normally need to call this, ever.
		///      </remarks>		<short>    Disable the auto-save-settings feature.</short>
		public void ResetAutoSaveSettings() {
			interceptor.Invoke("resetAutoSaveSettings", "resetAutoSaveSettings()", typeof(void));
		}
		/// <remarks>
		///  Read settings for statusbar, menubar and toolbar from their respective
		///  groups in the config file and apply them.
		/// <param> name="config" Config group to read the settings from.
		/// </param><param> name="force" if set, even default settings are re-applied
		///      </param></remarks>		<short>    Read settings for statusbar, menubar and toolbar from their respective  groups in the config file and apply them.</short>
		[SmokeMethod("applyMainWindowSettings(const KConfigGroup&, bool)")]
		public virtual void ApplyMainWindowSettings(KConfigGroup config, bool force) {
			interceptor.Invoke("applyMainWindowSettings#$", "applyMainWindowSettings(const KConfigGroup&, bool)", typeof(void), typeof(KConfigGroup), config, typeof(bool), force);
		}
		[SmokeMethod("applyMainWindowSettings(const KConfigGroup&)")]
		public virtual void ApplyMainWindowSettings(KConfigGroup config) {
			interceptor.Invoke("applyMainWindowSettings#", "applyMainWindowSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		/// <remarks>
		///  Save settings for statusbar, menubar and toolbar to their respective
		///  groups in the config group <code>config.</code>
		/// <param> name="config" Config group to save the settings to.
		///      </param></remarks>		<short>    Save settings for statusbar, menubar and toolbar to their respective  groups in the config group <code>config.</code></short>
		public void SaveMainWindowSettings(KConfigGroup config) {
			interceptor.Invoke("saveMainWindowSettings#", "saveMainWindowSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		/// <remarks>
		///  Used from Konqueror when reusing the main window.
		///      </remarks>		<short>   </short>
		public void IgnoreInitialGeometry() {
			interceptor.Invoke("ignoreInitialGeometry", "ignoreInitialGeometry()", typeof(void));
		}
		/// <remarks>
		///  Returns the path under which this window's D-Bus object is exported.
		/// </remarks>		<short>    Returns the path under which this window's D-Bus object is exported.</short>
		public string DbusName() {
			return (string) interceptor.Invoke("dbusName", "dbusName() const", typeof(string));
		}
		/// <remarks>
		///  Makes a KDE compliant caption (window title).
		/// <param> name="caption" Your caption. <b>Do</b> <b>not</b> include the application name
		///  in this string. It will be added automatically according to the KDE
		///  standard.
		///      </param></remarks>		<short>    Makes a KDE compliant caption (window title).</short>
		[Q_SLOT("void setCaption(const QString&)")]
		[SmokeMethod("setCaption(const QString&)")]
		public virtual void SetCaption(string caption) {
			interceptor.Invoke("setCaption$", "setCaption(const QString&)", typeof(void), typeof(string), caption);
		}
		/// <remarks>
		///  Makes a KDE compliant caption.
		/// <param> name="caption" Your caption. <b>Do</b> <b>not</b> include the application name
		///  in this string. It will be added automatically according to the KDE
		///  standard.
		/// </param><param> name="modified" Specify whether the document is modified. This displays
		///  an additional sign in the title bar, usually "**".
		///      </param></remarks>		<short>    Makes a KDE compliant caption.</short>
		[Q_SLOT("void setCaption(const QString&, bool)")]
		[SmokeMethod("setCaption(const QString&, bool)")]
		public virtual void SetCaption(string caption, bool modified) {
			interceptor.Invoke("setCaption$$", "setCaption(const QString&, bool)", typeof(void), typeof(string), caption, typeof(bool), modified);
		}
		/// <remarks>
		///  Make a plain caption without any modifications.
		/// <param> name="caption" Your caption. This is the string that will be
		///  displayed in the window title.
		///      </param></remarks>		<short>    Make a plain caption without any modifications.</short>
		[Q_SLOT("void setPlainCaption(const QString&)")]
		[SmokeMethod("setPlainCaption(const QString&)")]
		public virtual void SetPlainCaption(string caption) {
			interceptor.Invoke("setPlainCaption$", "setPlainCaption(const QString&)", typeof(void), typeof(string), caption);
		}
		/// <remarks>
		///  Open the help page for the application.
		///   The application name is
		///  used as a key to determine what to display and the system will attempt
		///  to open \<appName\>/index.html.
		///  This method is intended for use by a help button in the toolbar or
		///  components outside the regular help menu. Use helpMenu() when you
		///  want to provide access to the help system from the help menu.
		///  Example (adding a help button to the first toolbar):
		///  <pre>
		///  toolBar(0).AddAction(KIcon("help-contents"), i18n("Help"),
		///                        this, SLOT("appHelpActivated()"));
		///  </pre>
		///      </remarks>		<short>    Open the help page for the application.</short>
		[Q_SLOT("void appHelpActivated()")]
		public void AppHelpActivated() {
			interceptor.Invoke("appHelpActivated", "appHelpActivated()", typeof(void));
		}
		/// <remarks>
		///  Tell the main window that it should save its settings when being closed.
		///  This is part of the auto-save-settings feature.
		///  For everything related to toolbars this happens automatically,
		///  but you have to call setSettingsDirty() in the slot that toggles
		///  the visibility of the statusbar.
		///      </remarks>		<short>    Tell the main window that it should save its settings when being closed.</short>
		[Q_SLOT("void setSettingsDirty()")]
		public void SetSettingsDirty() {
			interceptor.Invoke("setSettingsDirty", "setSettingsDirty()", typeof(void));
		}
		/// <remarks>
		///  Reimplemented to catch QEvent.Polish in order to adjust the object name
		///  if needed, once all constructor code for the main window has run.
		///  Also reimplemented to catch when a QDockWidget is added or removed.
		///      </remarks>		<short>    Reimplemented to catch QEvent.Polish in order to adjust the object name  if needed, once all constructor code for the main window has run.</short>
		[SmokeMethod("event(QEvent*)")]
		protected override bool Event(QEvent arg1) {
			return (bool) interceptor.Invoke("event#", "event(QEvent*)", typeof(bool), typeof(QEvent), arg1);
		}
		/// <remarks>
		///  Reimplemented to call the queryClose() and queryExit() handlers.
		///  We recommend that you reimplement the handlers rather than closeEvent().
		///  If you do it anyway, ensure to call the base implementation to keep
		///  queryExit() running.
		///      </remarks>		<short>    Reimplemented to call the queryClose() and queryExit() handlers.</short>
		[SmokeMethod("closeEvent(QCloseEvent*)")]
		protected override void CloseEvent(QCloseEvent arg1) {
			interceptor.Invoke("closeEvent#", "closeEvent(QCloseEvent*)", typeof(void), typeof(QCloseEvent), arg1);
		}
		/// <remarks>
		///        Called before the very last window is closed, either by the
		///        user or indirectly by the session manager.
		///        It is not recommended to do any user interaction in this
		///        function other than indicating severe errors. Better ask the
		///        user on queryClose() (see below).
		///        A typical usage of queryExit() is to write configuration data back.
		///        Note that the application may continue to run after queryExit()
		///        (the user may have canceled a shutdown), so you should not do any cleanups
		///        here. The purpose of queryExit() is purely to prepare the application
		///        (with possible user interaction) so it can safely be closed later (without
		///        user interaction).
		///        If you need to do serious things on exit (like shutting a
		///        dial-up connection down), connect to the signal
		///  QCoreApplication.AboutToQuit().
		///        Default implementation returns <code>true.</code> Returning <code>false</code> will
		///        cancel the exiting. In the latter case, the last window will
		///        remain visible. If KApplication.SessionSaving() is true, refusing
		///        the exit will also cancel KDE logout.
		/// </remarks>		<short>          Called before the very last window is closed, either by the        user or indirectly by the session manager.</short>
		/// 		<see> queryClose</see>
		/// 		<see> KApplication.SessionSaving</see>
		[SmokeMethod("queryExit()")]
		protected virtual bool QueryExit() {
			return (bool) interceptor.Invoke("queryExit", "queryExit()", typeof(bool));
		}
		/// <remarks>
		///        Called before the window is closed, either by the user or indirectly by
		///        the session manager.
		///        The purpose of this function is to prepare the window in a way that it is
		///        safe to close it, i.e. without the user losing some data.
		///        Default implementation returns true. Returning <code>false</code> will cancel
		///        the closing, and, if KApplication.SessionSaving() is true, it will also
		///        cancel KDE logout.
		///        Reimplement this function to prevent the user from losing data.
		///        Example:
		///        <pre>
		///        switch ( KMessageBox.WarningYesNoCancel( this,
		///                 i18n("Save changes to document foo?")) ) {
		///        case KMessageBox.Yes :
		///          // save document here. If saving fails, return false;
		///          return true;
		///        case KMessageBox.No :
		///          return true;
		///        default: // cancel
		///          return false;
		///        </pre>
		///        Note that you should probably <b>not</b> actually close the document from
		///        within this method, as it may be called by the session manager before the
		///        session is saved. If the document is closed before the session save occurs,
		///        its location might not be properly saved. In addition, the session shutdown
		///        may be canceled, in which case the document should remain open.
		/// </remarks>		<short>          Called before the window is closed, either by the user or indirectly by        the session manager.</short>
		/// 		<see> queryExit</see>
		/// 		<see> KApplication.SessionSaving</see>
		[SmokeMethod("queryClose()")]
		protected virtual bool QueryClose() {
			return (bool) interceptor.Invoke("queryClose", "queryClose()", typeof(bool));
		}
		/// <remarks>
		///  Save your instance-specific properties. The function is
		///  invoked when the session manager requests your application
		///  to save its state.
		///  Please reimplement these function in childclasses.
		///  Note: No user interaction is allowed
		///  in this function!
		///      </remarks>		<short>    Save your instance-specific properties.</short>
		[SmokeMethod("saveProperties(KConfigGroup&)")]
		protected virtual void SaveProperties(KConfigGroup arg1) {
			interceptor.Invoke("saveProperties#", "saveProperties(KConfigGroup&)", typeof(void), typeof(KConfigGroup), arg1);
		}
		/// <remarks>
		///  Read your instance-specific properties.
		///     </remarks>		<short>    Read your instance-specific properties.</short>
		[SmokeMethod("readProperties(const KConfigGroup&)")]
		protected virtual void ReadProperties(KConfigGroup arg1) {
			interceptor.Invoke("readProperties#", "readProperties(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), arg1);
		}
		/// <remarks>
		///  Save your application-wide properties. The function is
		///  invoked when the session manager requests your application
		///  to save its state.
		///  This function is similar to saveProperties() but is only called for
		///  the very first main window, regardless how many main window are open.
		///  Override it if you need to save other data about your documents on
		///  session end. sessionConfig is a config to which that data should be
		///  saved. Normally, you don't need this function. But if you want to save
		///  data about your documents that are not in opened windows you might need
		///  it.
		///  Default implementation does nothing.
		///      </remarks>		<short>    Save your application-wide properties.</short>
		[SmokeMethod("saveGlobalProperties(KConfig*)")]
		protected virtual void SaveGlobalProperties(KConfig sessionConfig) {
			interceptor.Invoke("saveGlobalProperties#", "saveGlobalProperties(KConfig*)", typeof(void), typeof(KConfig), sessionConfig);
		}
		/// <remarks>
		///  The counterpart of saveGlobalProperties().
		///  Read the application-specific properties in again.
		///      </remarks>		<short>    The counterpart of saveGlobalProperties().</short>
		[SmokeMethod("readGlobalProperties(KConfig*)")]
		protected virtual void ReadGlobalProperties(KConfig sessionConfig) {
			interceptor.Invoke("readGlobalProperties#", "readGlobalProperties(KConfig*)", typeof(void), typeof(KConfig), sessionConfig);
		}
		protected void SavePropertiesInternal(KConfig arg1, int arg2) {
			interceptor.Invoke("savePropertiesInternal#$", "savePropertiesInternal(KConfig*, int)", typeof(void), typeof(KConfig), arg1, typeof(int), arg2);
		}
		protected bool ReadPropertiesInternal(KConfig arg1, int arg2) {
			return (bool) interceptor.Invoke("readPropertiesInternal#$", "readPropertiesInternal(KConfig*, int)", typeof(bool), typeof(KConfig), arg1, typeof(int), arg2);
		}
		/// <remarks>
		///  For inherited classes
		///      </remarks>		<short>    For inherited classes      </short>
		protected bool SettingsDirty() {
			return (bool) interceptor.Invoke("settingsDirty", "settingsDirty() const", typeof(bool));
		}
		/// <remarks>
		///  For inherited classes
		///      </remarks>		<short>    For inherited classes      </short>
		protected void SaveWindowSize(KConfigGroup config) {
			interceptor.Invoke("saveWindowSize#", "saveWindowSize(const KConfigGroup&) const", typeof(void), typeof(KConfigGroup), config);
		}
		/// <remarks>
		///  For inherited classes
		///  Note that a -geometry on the command line has priority.
		///      </remarks>		<short>    For inherited classes  Note that a -geometry on the command line has priority.</short>
		protected void RestoreWindowSize(KConfigGroup config) {
			interceptor.Invoke("restoreWindowSize#", "restoreWindowSize(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		protected void ParseGeometry(bool parsewidth) {
			interceptor.Invoke("parseGeometry$", "parseGeometry(bool)", typeof(void), typeof(bool), parsewidth);
		}
		/// <remarks>
		///  This slot does nothing.
		///  It must be reimplemented if you want
		///  to use a custom About Application dialog box. This slot is
		///  connected to the About Application entry in the menu returned
		///  by customHelpMenu.
		///  Example:
		///  <pre>
		///  void MyMainLevel.SetupInterface()
		///  {
		///    ..
		///    menuBar().AddMenu( customHelpMenu() );
		///    ..
		///  }
		///  void MyMainLevel.ShowAboutApplication()
		///  {
		///    <activate your custom dialog>
		///  }
		///  </pre>
		///     </remarks>		<short>    This slot does nothing.</short>
		[Q_SLOT("void showAboutApplication()")]
		[SmokeMethod("showAboutApplication()")]
		protected virtual void ShowAboutApplication() {
			interceptor.Invoke("showAboutApplication", "showAboutApplication()", typeof(void));
		}
		/// <remarks>
		///  This slot should only be called in case you reimplement closeEvent() and
		///  if you are using the "auto-save" feature. In all other cases,
		///  setSettingsDirty() should be called instead to benefit from the delayed
		///  saving.
		///  Example:
		///  <pre>
		///  void MyMainWindow.CloseEvent( QCloseEvent e )
		///  {
		///    // Save settings if auto-save is enabled, and settings have changed
		///    if ( settingsDirty() && autoSaveSettings() )
		///      saveAutoSaveSettings();
		///    ..
		///  }
		///  </pre>
		///     </remarks>		<short>    This slot should only be called in case you reimplement closeEvent() and  if you are using the "auto-save" feature.</short>
		/// 		<see> setAutoSaveSettings</see>
		/// 		<see> setSettingsDirty</see>
		[Q_SLOT("void saveAutoSaveSettings()")]
		protected void SaveAutoSaveSettings() {
			interceptor.Invoke("saveAutoSaveSettings", "saveAutoSaveSettings()", typeof(void));
		}
		~KMainWindow() {
			interceptor.Invoke("~KMainWindow", "~KMainWindow()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KMainWindow", "~KMainWindow()", typeof(void));
		}
		/// <remarks>
		///  <b>Session Management</b>
		///  Try to restore the toplevel widget as defined by the number (1..X).
		///  If the session did not contain so high a number, the configuration
		///  is not changed and <code>false</code> returned.
		///  That means clients could simply do the following:
		///  <pre>
		///  if (qApp.IsSessionRestored()){
		///    int n = 1;
		///    while (KMainWindow.CanBeRestored(n)){
		///      (new childMW).Restore(n);
		///      n++;
		///    }
		///  } else {
		///    // create default application as usual
		///  }
		///  </pre>
		///  Note that QWidget.Show() is called implicitly in restore.
		///  With this you can easily restore all toplevel windows of your
		///  application.
		///  If your application uses different kinds of toplevel
		///  windows, then you can use KMainWindow.ClassNameOfToplevel(n)
		///  to determine the exact type before calling the childMW
		///  constructor in the example from above.
		///  If your client has only one kind of toplevel widgets (which
		///  should be pretty usual) then you should use the RESTORE-macro
		///  for backwards compatibility with 3.1 and 3.0 branches:
		///  <pre>
		///  if (qApp.IsSessionRestored())
		///    RESTORE(childMW)
		///  else {
		///    // create default application as usual
		///  }
		///  </pre>
		///  The macro expands to the term above but is easier to use and
		///  less code to write.
		///  For new code or if you have more than one kind of toplevel
		///  widget (each derived from KMainWindow, of course), you can
		///  use the templated kRestoreMainWindows global functions:
		///  <pre>
		///  if (qApp.IsSessionRestored())
		///    kRestoreMainWindows< childMW1, childMW2, childMW3 >();
		///  else {
		///    // create default application as usual
		///  }
		///  </pre>
		///  Currently, these functions are provided for up to three
		///  template arguments. If you need more, tell us. To help you in
		///  deciding whether or not you can use kRestoreMainWindows, a
		///  define KDE_RESTORE_MAIN_WINDOWS_NUM_TEMPLATE_ARGS is provided.
		/// </remarks>		<short>    <b>Session Management</b> </short>
		/// 		<see> restore</see>
		/// 		<see> classNameOfToplevel</see>
		public static bool CanBeRestored(int number) {
			return (bool) staticInterceptor.Invoke("canBeRestored$", "canBeRestored(int)", typeof(bool), typeof(int), number);
		}
		/// <remarks>
		///  Returns the className() of the <code>number</code> of the toplevel window which
		///  should be restored.
		///  This is only useful if your application uses
		///  different kinds of toplevel windows.
		///      </remarks>		<short>    Returns the className() of the <code>number</code> of the toplevel window which  should be restored.</short>
		public static string ClassNameOfToplevel(int number) {
			return (string) staticInterceptor.Invoke("classNameOfToplevel$", "classNameOfToplevel(int)", typeof(string), typeof(int), number);
		}
		/// <remarks>
		///  List of members of KMainWindow class.
		///      </remarks>		<short>    List of members of KMainWindow class.</short>
		public static List<KMainWindow> MemberList() {
			return (List<KMainWindow>) staticInterceptor.Invoke("memberList", "memberList()", typeof(List<KMainWindow>));
		}
		protected new IKMainWindowSignals Emit {
			get { return (IKMainWindowSignals) Q_EMIT; }
		}
	}

	public interface IKMainWindowSignals : IQMainWindowSignals {
	}
}
