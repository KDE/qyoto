//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  Information about a plugin.
	///  This holds all the information about a plugin there is. It's used for the
	///  user to decide whether he wants to use this plugin or not.
	/// </remarks>		<author> Matthias Kretz <kretz@kde.org>
	///  </author>
	/// 		<short>    Information about a plugin.</short>

	[SmokeClass("KPluginInfo")]
	public class KPluginInfo : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KPluginInfo(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KPluginInfo), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KPluginInfo() {
			staticInterceptor = new SmokeInvocationKDE(typeof(KPluginInfo), null);
		}
		// KPluginInfo::List fromServices(const KService::List& arg1,const KConfigGroup& arg2); >>>> NOT CONVERTED
		// KPluginInfo::List fromServices(const KService::List& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  Read plugin info from <code>filename.</code>
		///  The file should be of the following form:
		///  <pre>
		///            [Desktop Entry]
		///            Encoding=UTF-8
		///            Icon=mypluginicon
		///            Type=Service
		///            ServiceTypes=KPluginInfo
		///            Name=User Visible Name
		///            Comment=Description of what the plugin does
		///            X-KDE-PluginInfo-Author=Author's Name
		///            X-KDE-PluginInfo-Email=author@foo.bar
		///            X-KDE-PluginInfo-Name=internalname
		///            X-KDE-PluginInfo-Version=1.1
		///            X-KDE-PluginInfo-Website=http://www.plugin.org/
		///            X-KDE-PluginInfo-Category=playlist
		///            X-KDE-PluginInfo-Depends=plugin1,plugin3
		///            X-KDE-PluginInfo-License=GPL
		///            X-KDE-PluginInfo-EnabledByDefault=true
		///            </pre>
		///  The Name and Comment fields must always be present.
		///  The "X-KDE-PluginInfo" keys you may add further entries which
		///  will be available using property(). The Website,Category,Require
		///  keys are optional.
		///  For EnabledByDefault look at isPluginEnabledByDefault.
		/// <param> name="filename" The filename of the .desktop file.
		/// </param><param> name="resource" If filename is relative, you need to specify a resource type
		///  (e.g. "service", "apps"... KStandardDirs). Otherwise,
		///  resource isn't used.
		///          </param></remarks>		<short>    Read plugin info from <code>filename.</code></short>
		public KPluginInfo(string filename, string resource) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo$$", "KPluginInfo(const QString&, const char*)", typeof(void), typeof(string), filename, typeof(string), resource);
		}
		public KPluginInfo(string filename) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo$", "KPluginInfo(const QString&)", typeof(void), typeof(string), filename);
		}
		/// <remarks>
		///  Read plugin info from a KService object.
		///  The .desktop file should look like this:
		///  <pre>
		///            [Desktop Entry]
		///            Encoding=UTF-8
		///            Icon=mypluginicon
		///            Type=Service
		///            ServiceTypes=KPluginInfo
		///            X-KDE-PluginInfo-Author=Author's Name
		///            X-KDE-PluginInfo-Email=author@foo.bar
		///            X-KDE-PluginInfo-Name=internalname
		///            X-KDE-PluginInfo-Version=1.1
		///            X-KDE-PluginInfo-Website=http://www.plugin.org/
		///            X-KDE-PluginInfo-Category=playlist
		///            X-KDE-PluginInfo-Depends=plugin1,plugin3
		///            X-KDE-PluginInfo-License=GPL
		///            X-KDE-PluginInfo-EnabledByDefault=true
		///            Name=User Visible Name
		///            Comment=Description of what the plugin does
		///            </pre>
		///  In the first three entries the Icon entry is optional.
		///          </remarks>		<short>    Read plugin info from a KService object.</short>
		public KPluginInfo(KService service) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo#", "KPluginInfo(const KService::Ptr)", typeof(void), typeof(KService), service);
		}
		/// <remarks>
		///  Creates an invalid plugin.
		///  \see isValid
		///          </remarks>		<short>    Creates an invalid plugin.</short>
		public KPluginInfo() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo", "KPluginInfo()", typeof(void));
		}
		/// <remarks>
		/// </remarks>		<return> Whether the plugin should be hidden.
		///          </return>
		/// 		<short>   </short>
		public bool IsHidden() {
			return (bool) interceptor.Invoke("isHidden", "isHidden() const", typeof(bool));
		}
		/// <remarks>
		///  Set whether the plugin is currently loaded.
		/// </remarks>		<short>    Set whether the plugin is currently loaded.</short>
		/// 		<see> isPluginEnabled</see>
		/// 		<see> save</see>
		public void SetPluginEnabled(bool enabled) {
			interceptor.Invoke("setPluginEnabled$", "setPluginEnabled(bool)", typeof(void), typeof(bool), enabled);
		}
		/// <remarks>
		/// </remarks>		<return> Whether the plugin is currently loaded.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> setPluginEnabled</see>
		/// 		<see> load</see>
		public bool IsPluginEnabled() {
			return (bool) interceptor.Invoke("isPluginEnabled", "isPluginEnabled() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> The default value whether the plugin is enabled or not.
		///  Defaults to the value set in the desktop file, or if that isn't set
		///  to false.
		///          </return>
		/// 		<short>   </short>
		public bool IsPluginEnabledByDefault() {
			return (bool) interceptor.Invoke("isPluginEnabledByDefault", "isPluginEnabledByDefault() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> The value associated the the <code>key.</code> You can use it if you
		///          want to read custom values. To do this you need to define
		///          your own servicetype and add it to the ServiceTypes keys.
		///          </return>
		/// 		<short>   </short>
		public QVariant Property(string key) {
			return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), key);
		}
		/// <remarks>
		/// </remarks>		<return> The user visible name of the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> A comment describing the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The iconname for this plugin
		///          </return>
		/// 		<short>   </short>
		public string Icon() {
			return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The file containing the information about the plugin.
		///          </return>
		/// 		<short>   </short>
		public string EntryPath() {
			return (string) interceptor.Invoke("entryPath", "entryPath() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The author of this plugin.
		///          </return>
		/// 		<short>   </short>
		public string Author() {
			return (string) interceptor.Invoke("author", "author() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The email address of the author.
		///          </return>
		/// 		<short>   </short>
		public string Email() {
			return (string) interceptor.Invoke("email", "email() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The category of this plugin (e.g. playlist/skin).
		///          </return>
		/// 		<short>   </short>
		public string Category() {
			return (string) interceptor.Invoke("category", "category() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The internal name of the plugin (for KParts Plugins this is
		///  the same name as set in the .rc file).
		///          </return>
		/// 		<short>   </short>
		public string PluginName() {
			return (string) interceptor.Invoke("pluginName", "pluginName() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The version of the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Version() {
			return (string) interceptor.Invoke("version", "version() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The website of the plugin/author.
		///          </return>
		/// 		<short>   </short>
		public string Website() {
			return (string) interceptor.Invoke("website", "website() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The license keyword of this plugin.
		///          </return>
		/// 		<short>   </short>
		public string License() {
			return (string) interceptor.Invoke("license", "license() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The full license object, according to the license keyword.
		///          It can be used to present friendlier and more detailed
		///          license info to the user, when the license is one of the
		///          widespread within KDE. For other licenses, the license
		///          object will state not very useful, "custom license" info
		///          (this can be identified by KAboutLicense.Key() returning
		///           KAboutData.License_Custom).
		/// </return>
		/// 		<short>   </short>
		/// 		<see> KAboutLicense.ByKeyword</see>
		public KAboutLicense FullLicense() {
			return (KAboutLicense) interceptor.Invoke("fullLicense", "fullLicense() const", typeof(KAboutLicense));
		}
		/// <remarks>
		/// </remarks>		<return> A list of plugins required for this plugin to be enabled. Use
		///          the pluginName in this list.
		///          </return>
		/// 		<short>   </short>
		public List<string> Dependencies() {
			return (List<string>) interceptor.Invoke("dependencies", "dependencies() const", typeof(List<string>));
		}
		/// <remarks>
		/// </remarks>		<return> The KService object for this plugin. You might need it if you
		///          want to read custom values. To do this you need to define
		///          your own servicetype and add it to the ServiceTypes keys.
		///          Then you can use the KService.Property() method to read your
		///          keys.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> property</see>
		public KService Service() {
			return (KService) interceptor.Invoke("service", "service() const", typeof(KService));
		}
		/// <remarks>
		/// </remarks>		<return> A list of Service pointers if the plugin installs one or more
		///          KCModule
		///          </return>
		/// 		<short>   </short>
		public List<KService> KcmServices() {
			return (List<KService>) interceptor.Invoke("kcmServices", "kcmServices() const", typeof(List<KService>));
		}
		/// <remarks>
		///  Set the KConfigGroup to use for load()ing and save()ing the
		///  configuration. This will be overridden by the KConfigGroup passed to
		///  save() or load() (if one is passed).
		///          </remarks>		<short>    Set the KConfigGroup to use for load()ing and save()ing the  configuration.</short>
		public void SetConfig(KConfigGroup config) {
			interceptor.Invoke("setConfig#", "setConfig(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		/// <remarks>
		/// </remarks>		<return> If the KPluginInfo object has a KConfig object set return
		///  it, else returns an invalid KConfigGroup.
		///          </return>
		/// 		<short>   </short>
		public KConfigGroup Config() {
			return (KConfigGroup) interceptor.Invoke("config", "config() const", typeof(KConfigGroup));
		}
		/// <remarks>
		///  Save state of the plugin - enabled or not.
		/// <param> name="config" The KConfigGroup holding the information whether
		///                   plugin is enabled.
		///          </param></remarks>		<short>    Save state of the plugin - enabled or not.</short>
		public void Save(KConfigGroup config) {
			interceptor.Invoke("save#", "save(KConfigGroup)", typeof(void), typeof(KConfigGroup), config);
		}
		public void Save() {
			interceptor.Invoke("save", "save()", typeof(void));
		}
		/// <remarks>
		///  Load the state of the plugin - enabled or not.
		/// <param> name="config" The KConfigGroup holding the information whether
		///                   plugin is enabled.
		///          </param></remarks>		<short>    Load the state of the plugin - enabled or not.</short>
		public void Load(KConfigGroup config) {
			interceptor.Invoke("load#", "load(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		public void Load() {
			interceptor.Invoke("load", "load()", typeof(void));
		}
		/// <remarks>
		///  Restore defaults (enabled or not).
		///          </remarks>		<short>    Restore defaults (enabled or not).</short>
		public void Defaults() {
			interceptor.Invoke("defaults", "defaults()", typeof(void));
		}
		/// <remarks>
		///  Returns whether the object is valid. Treat invalid KPluginInfo objects like you would
		///  treat a null pointer.
		///          </remarks>		<short>    Returns whether the object is valid.</short>
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Creates a KPluginInfo object that shares the data with <pre>copy</pre>.
		///          </remarks>		<short>    Creates a KPluginInfo object that shares the data with \p copy.</short>
		public KPluginInfo(KPluginInfo copy) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo#", "KPluginInfo(const KPluginInfo&)", typeof(void), typeof(KPluginInfo), copy);
		}
		/// <remarks>
		///  Compares two objects whether they share the same data.
		///          </remarks>		<short>    Compares two objects whether they share the same data.</short>
		public override bool Equals(object o) {
			if (!(o is KPluginInfo)) { return false; }
			return this == (KPluginInfo) o;
		}
		public override int GetHashCode() {
			return interceptor.GetHashCode();
		}
		/// <remarks>
		///  Less than relation comparing the categories and if they are the same using the names.
		///          </remarks>		<short>    Less than relation comparing the categories and if they are the same using the names.</short>
		/// <remarks>
		///  Greater than relation comparing the categories and if they are the same using the names.
		///          </remarks>		<short>    Greater than relation comparing the categories and if they are the same using the names.</short>
		~KPluginInfo() {
			interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
		}
		public static bool operator==(KPluginInfo lhs, KPluginInfo rhs) {
			return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
		}
		public static bool operator!=(KPluginInfo lhs, KPluginInfo rhs) {
			return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
		}
		public static bool operator<(KPluginInfo lhs, KPluginInfo rhs) {
			return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
		}
		public static bool operator>(KPluginInfo lhs, KPluginInfo rhs) {
			return (bool) staticInterceptor.Invoke("operator>#", "operator>(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
		}
		/// <remarks>
		/// <param> name="services" The list of services to construct the list of KPluginInfo objects from
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects constructed from a list of
		///  KService objects. If you get a trader offer of the plugins you want
		///  to use you can just pass them to this function.
		/// </return>
		/// 		<short>   </short>
		/// <remarks>
		/// <param> name="files" The list of files to construct the list of KPluginInfo objects from
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects constructed from a list of
		///  filenames. If you make a lookup using, for example,
		///  KStandardDirs.FindAllResources() you pass the list of files to this
		///  function.
		/// </return>
		/// 		<short>   </short>
		public static List<KPluginInfo> FromFiles(List<string> files, KConfigGroup config) {
			return (List<KPluginInfo>) staticInterceptor.Invoke("fromFiles?#", "fromFiles(const QStringList&, const KConfigGroup&)", typeof(List<KPluginInfo>), typeof(List<string>), files, typeof(KConfigGroup), config);
		}
		public static List<KPluginInfo> FromFiles(List<string> files) {
			return (List<KPluginInfo>) staticInterceptor.Invoke("fromFiles?", "fromFiles(const QStringList&)", typeof(List<KPluginInfo>), typeof(List<string>), files);
		}
		/// <remarks>
		/// <param> name="componentName" Use the component name to look up all KParts plugins for it.
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects for the KParts plugins of a
		///  component. You only need the name of the component not a pointer to the
		///  KComponentData object.
		/// </return>
		/// 		<short>   </short>
		public static List<KPluginInfo> FromKPartsInstanceName(string componentName, KConfigGroup config) {
			return (List<KPluginInfo>) staticInterceptor.Invoke("fromKPartsInstanceName$#", "fromKPartsInstanceName(const QString&, const KConfigGroup&)", typeof(List<KPluginInfo>), typeof(string), componentName, typeof(KConfigGroup), config);
		}
		public static List<KPluginInfo> FromKPartsInstanceName(string componentName) {
			return (List<KPluginInfo>) staticInterceptor.Invoke("fromKPartsInstanceName$", "fromKPartsInstanceName(const QString&)", typeof(List<KPluginInfo>), typeof(string), componentName);
		}
	}
}
