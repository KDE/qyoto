//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Collections.Generic;
	/// <remarks>
	///  \class KWordMacroExpander kmacroexpander.h <KMacroExpanderBase>
	///  Abstract base class for simple word macro substitutors. Use this instead of
	///  the functions in the KMacroExpander namespace if speculatively pre-filling
	///  the substitution map would be too expensive.
	///  A typical application:
	///  <pre>
	///  class MyClass {
	///  ...
	///    private:
	///      string m_str;
	///  ...
	///    friend class MyExpander;
	///  }
	///  class MyExpander : public KWordMacroExpander {
	///    public      MyExpander( MyClass _that ), that( _that ) {}
	///    protected:
	///      bool expandMacro( stringstr, List<string>ret );
	///    private:
	///      MyClass that;
	///  }
	///  bool MyExpander.ExpandMacro( stringstr, List<string>ret )
	///  {
	///    if (str == "macro") {
	///      ret += complexOperation( that.M_str );
	///      return true;
	///    }
	///    return false;
	///  }
	///  ... MyClass....(...)
	///  {
	///    string str;
	///    ...
	///    MyExpander mx( this );
	///    mx.expandMacrosShellQuote( str );
	///    ...
	///  }
	///  </pre>
	///  Alternatively MyClass could inherit from KWordMacroExpander directly.
	/// </remarks>		<author> Oswald Buddenhagen <ossi@kde.org>
	///  </author>
	/// 		<short>    \class KWordMacroExpander kmacroexpander.</short>
	[SmokeClass("KWordMacroExpander")]
	public abstract class KWordMacroExpander : KMacroExpanderBase {
 		protected KWordMacroExpander(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KWordMacroExpander), this);
		}
		/// <remarks>
		///  Constructor.
		/// <param> name="c" escape char indicating start of macros, or QChar.Null for none
		///      </param></remarks>		<short>    Constructor.</short>
		public KWordMacroExpander(QChar c) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KWordMacroExpander#", "KWordMacroExpander(QChar)", typeof(void), typeof(QChar), c);
		}
		public KWordMacroExpander() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KWordMacroExpander", "KWordMacroExpander()", typeof(void));
		}
		[SmokeMethod("expandPlainMacro(const QString&, int, QStringList&)")]
		protected override int ExpandPlainMacro(string str, int pos, List<string> ret) {
			return (int) interceptor.Invoke("expandPlainMacro$$?", "expandPlainMacro(const QString&, int, QStringList&)", typeof(int), typeof(string), str, typeof(int), pos, typeof(List<string>), ret);
		}
		[SmokeMethod("expandEscapedMacro(const QString&, int, QStringList&)")]
		protected override int ExpandEscapedMacro(string str, int pos, List<string> ret) {
			return (int) interceptor.Invoke("expandEscapedMacro$$?", "expandEscapedMacro(const QString&, int, QStringList&)", typeof(int), typeof(string), str, typeof(int), pos, typeof(List<string>), ret);
		}
		/// <remarks>
		///  Return substitution list <code>ret</code> for string macro <code>str.</code>
		/// <param> name="str" the macro to expand
		/// </param><param> name="ret" return variable reference. It is guaranteed to be empty
		///   when expandMacro is entered.
		/// </param></remarks>		<return> @c true iff <code>chr</code> was a recognized macro name
		///      </return>
		/// 		<short>    Return substitution list <code>ret</code> for string macro <code>str.</code></short>
		[SmokeMethod("expandMacro(const QString&, QStringList&)")]
		protected abstract bool ExpandMacro(string str, List<string> ret);
	}
}
