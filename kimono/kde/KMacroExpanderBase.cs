//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Collections.Generic;
	/// <remarks>
	///  \class KMacroExpanderBase kmacroexpander.h <KMacroExpanderBase>
	///  Abstract base class for the worker classes behind the KMacroExpander namespace
	///  and the KCharMacroExpander and KWordMacroExpander classes.
	/// </remarks>		<author> Oswald Buddenhagen <ossi@kde.org>
	///  </author>
	/// 		<short>    \class KMacroExpanderBase kmacroexpander.</short>
	[SmokeClass("KMacroExpanderBase")]
	public class KMacroExpanderBase : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KMacroExpanderBase(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KMacroExpanderBase), this);
		}
		/// <remarks>
		///  Constructor.
		/// <param> name="c" escape char indicating start of macros, or char.Null for none
		///      </param></remarks>		<short>    Constructor.</short>
		public KMacroExpanderBase(char c) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMacroExpanderBase#", "KMacroExpanderBase(QChar)", typeof(void), typeof(char), c);
		}
		public KMacroExpanderBase() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMacroExpanderBase", "KMacroExpanderBase()", typeof(void));
		}
		/// <remarks>
		///  Perform safe macro expansion (substitution) on a string.
		/// <param> name="str" the string in which macros are expanded in-place
		///      </param></remarks>		<short>    Perform safe macro expansion (substitution) on a string.</short>
		public void ExpandMacros(StringBuilder str) {
			interceptor.Invoke("expandMacros$", "expandMacros(QString&)", typeof(void), typeof(StringBuilder), str);
		}
		/// <remarks>
		///  Perform safe macro expansion (substitution) on a string for use
		///  in shell commands.
		///  <h3>NIX notes</h3>
		///  Explicitly supported shell constructs:
		///    \ '' "" $'' $"" {} () $(()) ${} $() ``
		///  Implicitly supported shell constructs:
		///    (())
		///  Unsupported shell constructs that will cause problems:
		///   Shortened &quot;<tt>case $v in pat)</tt>&quot; syntax. Use
		///    &quot;<tt>case $v in (pat)</tt>&quot; instead.
		///  The rest of the shell (incl. bash) syntax is simply ignored,
		///  as it is not expected to cause problems.
		///  Note that bash contains a bug which makes macro expansion within 
		///  double quoted substitutions (<tt>"${VAR:-%macro}"</tt>) inherently
		///  insecure.
		///  For security reasons, <b>never</b> put expandos in command line arguments
		///  that are shell commands by themselves -
		///  &quot;<tt>sh -c 'foo \%f'</tt>&quot; is taboo.
		///  &quot;<tt>file=\%f sh -c 'foo "$file"'</tt>&quot; is OK.
		///  <h3>Windows notes</h3>
		///  All quoting syntax supported by KShell is supported here as well.
		///  Additionally, command grouping via parentheses is recognized - note
		///  however, that the parser is much stricter about unquoted parentheses
		///  than cmd itself.
		///  The rest of the cmd syntax is simply ignored, as it is not expected
		///  to cause problems - do not use commands that embed other commands,
		///  though - &quot;<tt>for /f ...</tt>&quot; is taboo.
		/// <param> name="str" the string in which macros are expanded in-place
		/// </param><param> name="pos" the position inside the string at which parsing/substitution
		///   should start, and upon exit where processing stopped
		/// </param></remarks>		<return> false if the string could not be parsed and therefore no safe
		///   substitution was possible. Note that macros will have been processed
		///   up to the point where the error occurred. An unmatched closing paren
		///   or brace outside any shell construct is @em not an error (unlike in
		///   the function below), but still prematurely terminates processing.
		///      </return>
		/// 		<short>    Perform safe macro expansion (substitution) on a string for use  in shell commands.</short>
		public bool ExpandMacrosShellQuote(StringBuilder str, ref int pos) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
			stack[2].s_int = pos;
			interceptor.Invoke("expandMacrosShellQuote$$", "expandMacrosShellQuote(QString&, int&)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			pos = stack[2].s_int;
			return stack[0].s_bool;
		}
		/// <remarks>
		///  Same as above, but always starts at position 0, and unmatched closing
		///  parens and braces are treated as errors.
		///      </remarks>		<short>    Same as above, but always starts at position 0, and unmatched closing  parens and braces are treated as errors.</short>
		public bool ExpandMacrosShellQuote(StringBuilder str) {
			return (bool) interceptor.Invoke("expandMacrosShellQuote$", "expandMacrosShellQuote(QString&)", typeof(bool), typeof(StringBuilder), str);
		}
		/// <remarks>
		///  Set the macro escape character.
		/// <param> name="c" escape char indicating start of macros, or char.Null if none
		///      </param></remarks>		<short>    Set the macro escape character.</short>
		public void SetEscapeChar(char c) {
			interceptor.Invoke("setEscapeChar#", "setEscapeChar(QChar)", typeof(void), typeof(char), c);
		}
		/// <remarks>
		///  Obtain the macro escape character.
		/// </remarks>		<return> escape char indicating start of macros, or char.Null if none
		///      </return>
		/// 		<short>    Obtain the macro escape character.</short>
		public char EscapeChar() {
			return (char) interceptor.Invoke("escapeChar", "escapeChar() const", typeof(char));
		}
		/// <remarks>
		///  This function is called for every single char within the string if
		///  the escape char is char.Null. It should determine whether the
		///  string starting at <code>pos</code> within <code>str</code> is a valid macro and return
		///  the substitution value for it if so.
		/// <param> name="str" the input string
		/// </param><param> name="pos" the offset within <code>str</code>
		/// </param><param> name="ret" return value: the string to substitute for the macro
		/// </param></remarks>		<return> If greater than zero, the number of chars at <code>pos</code> in <code>str</code>
		///   to substitute with <code>ret</code> (i.e., a valid macro was found). If less
		///   than zero, subtract this value from <code>pos</code> (to skip a macro, i.e.,
		///   substitute it with itself). If zero, no macro starts at <code>pos.</code>
		///      </return>
		/// 		<short>    This function is called for every single char within the string if  the escape char is char.Null.</short>
		[SmokeMethod("expandPlainMacro(const QString&, int, QStringList&)")]
		protected virtual int ExpandPlainMacro(string str, int pos, List<string> ret) {
			return (int) interceptor.Invoke("expandPlainMacro$$?", "expandPlainMacro(const QString&, int, QStringList&)", typeof(int), typeof(string), str, typeof(int), pos, typeof(List<string>), ret);
		}
		/// <remarks>
		///  This function is called every time the escape char is found if it is
		///  not char.Null. It should determine whether the
		///  string starting at <code>pos</code> witin <code>str</code> is a valid macro and return
		///  the substitution value for it if so.
		/// <param> name="str" the input string
		/// </param><param> name="pos" the offset within <code>str.</code> Note that this is the position of
		///   the occurrence of the escape char
		/// </param><param> name="ret" return value: the string to substitute for the macro
		/// </param></remarks>		<return> If greater than zero, the number of chars at <code>pos</code> in <code>str</code>
		///   to substitute with <code>ret</code> (i.e., a valid macro was found). If less
		///   than zero, subtract this value from <code>pos</code> (to skip a macro, i.e.,
		///   substitute it with itself). If zero, scanning continues as if no
		///   escape char was encountered at all.
		///      </return>
		/// 		<short>    This function is called every time the escape char is found if it is  not char.Null.</short>
		[SmokeMethod("expandEscapedMacro(const QString&, int, QStringList&)")]
		protected virtual int ExpandEscapedMacro(string str, int pos, List<string> ret) {
			return (int) interceptor.Invoke("expandEscapedMacro$$?", "expandEscapedMacro(const QString&, int, QStringList&)", typeof(int), typeof(string), str, typeof(int), pos, typeof(List<string>), ret);
		}
		~KMacroExpanderBase() {
			interceptor.Invoke("~KMacroExpanderBase", "~KMacroExpanderBase()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KMacroExpanderBase", "~KMacroExpanderBase()", typeof(void));
		}
	}
}
