//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Collections.Generic;
	/// <remarks>
	///  KLocale provides support for country specific stuff like
	///  the national language.
	///  KLocale supports translating, as well as specifying the format
	///  for numbers, currency, time, and date.
	///  Use KGlobal.Locale() to get pointer to the global KLocale object,
	///  containing the applications current locale settings.
	///  For example, to format the date May 17, 1995 in the current locale, use:
	///  <pre>
	///    string date = KGlobal.Locale().FormatDate(QDate(1995,5,17));
	///  </pre>
	/// </remarks>		<author> Stephan Kulow <coolo@kde.org>, Preston Brown <pbrown@kde.org>,
	///  Hans Petter Bieker <bieker@kde.org>, Lukas Tinkl <lukas.tinkl@suse.cz>
	/// </author>
	/// 		<short> class for supporting locale settings and national language.</short>
	[SmokeClass("KLocale")]
	public class KLocale : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KLocale(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KLocale), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KLocale() {
			staticInterceptor = new SmokeInvocation(typeof(KLocale), null);
		}
		/// <remarks>
		///  Various positions for where to place the positive or negative
		///  sign when they are related to a monetary value.
		///    </remarks>		<short>    Various positions for where to place the positive or negative  sign when they are related to a monetary value.</short>
		public enum SignPosition {
			ParensAround = 0,
			BeforeQuantityMoney = 1,
			AfterQuantityMoney = 2,
			BeforeMoney = 3,
			AfterMoney = 4,
		}
		/// <remarks>
		///  Format for date string.
		///    </remarks>		<short>    Format for date string.</short>
		public enum DateFormat {
			ShortDate = 0,
			LongDate = 1,
			FancyShortDate = 2,
			FancyLongDate = 3,
		}
		/// <remarks>
		///  Options for formatting date-time values.
		///    </remarks>		<short>    Options for formatting date-time values.</short>
		public enum DateTimeFormatOption {
			TimeZone = 0x01,
			Seconds = 0x02,
		}
		/// <remarks>
		///  Flags for readDate()
		///    </remarks>		<short>    Flags for readDate()    </short>
		public enum ReadDateFlags {
			NormalFormat = 1,
			ShortFormat = 2,
		}
		/// <remarks>
		///  Flags for readTime()
		///    </remarks>		<short>    Flags for readTime()    </short>
		public enum ReadTimeFlags {
			WithSeconds = 0,
			WithoutSeconds = 1,
		}
		/// <remarks>
		///  The Metric system will give you information in mm, while the
		///  Imperial system will give you information in inches.
		///    </remarks>		<short>    The Metric system will give you information in mm, while the  Imperial system will give you information in inches.</short>
		public enum MeasureSystem {
			Metric = 0,
			Imperial = 1,
		}
		/// <remarks>
		///  Constructs a KLocale with the given catalog name.
		///  The constructor looks for an entry Locale/Language in the
		///  configuration file.
		///  If no config file is specified, it will also look for languages
		///  using the environment variables (KDE_LANG, LC_MESSAGES, LC_ALL, LANG),
		///  as well as the global configuration file. If KLocale is not able to use
		///  any of the specified languages, the default language (en_US) will be
		///  used.
		///  If you specify a configuration file, it has to be valid until
		///  the KLocale object is destroyed.
		/// <param> name="catalog" The name of the main language file
		/// </param><param> name="config" The configuration file to use.
		///    </param></remarks>		<short>    Constructs a KLocale with the given catalog name.</short>
		public KLocale(string catalog, KSharedConfig config) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale$#", "KLocale(const QString&, KSharedConfig::Ptr)", typeof(void), typeof(string), catalog, typeof(KSharedConfig), config);
		}
		public KLocale(string catalog) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale$", "KLocale(const QString&)", typeof(void), typeof(string), catalog);
		}
		public KLocale(string catalog, string language, string country, KConfig config) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale$$$#", "KLocale(const QString&, const QString&, const QString&, KConfig*)", typeof(void), typeof(string), catalog, typeof(string), language, typeof(string), country, typeof(KConfig), config);
		}
		public KLocale(string catalog, string language, string country) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale$$$", "KLocale(const QString&, const QString&, const QString&)", typeof(void), typeof(string), catalog, typeof(string), language, typeof(string), country);
		}
		public KLocale(string catalog, string language) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale$$", "KLocale(const QString&, const QString&)", typeof(void), typeof(string), catalog, typeof(string), language);
		}
		/// <remarks>
		///  Copy constructor.
		///    </remarks>		<short>    Copy constructor.</short>
		public KLocale(KLocale rhs) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLocale#", "KLocale(const KLocale&)", typeof(void), typeof(KLocale), rhs);
		}
		/// <remarks>
		///  Raw translation from message catalogs.
		///  Never use this directly to get message translations. See i18n and ki18n
		///  calls related to KLocalizedString.
		/// <param> name="msg" the message. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="lang" language in which the translation was found. If no translation
		///              was found, KLocale.DefaultLanguage() is reported. If null,
		///              the language is not reported.
		/// </param><param> name="trans" raw translation, or original if not found. If no translation
		///               was found, original message is reported. If null, the
		///               translation is not reported.
		/// </param></remarks>		<short>    Raw translation from message catalogs.</short>
		/// 		<see> KLocalizedString</see>
		public void TranslateRaw(string msg, StringBuilder lang, StringBuilder trans) {
			interceptor.Invoke("translateRaw$$$", "translateRaw(const char*, QString*, QString*) const", typeof(void), typeof(string), msg, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
		}
		/// <remarks>
		///  Raw translation from message catalogs, with given context.
		///  Context + message are used as the lookup key in catalogs.
		///  Never use this directly to get message translations. See i18n and ki18n
		///  calls related to KLocalizedString.
		/// <param> name="ctxt" the context. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="msg" the message. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="lang" language in which the translation was found. If no translation
		///              was found, KLocale.DefaultLanguage() is reported. If null,
		///              the language is not reported.
		/// </param><param> name="trans" raw translation, or original if not found. If no translation
		///               was found, original message is reported. If null, the
		///               translation is not reported.
		/// </param></remarks>		<short>    Raw translation from message catalogs, with given context.</short>
		/// 		<see> KLocalizedString</see>
		public void TranslateRaw(string ctxt, string msg, StringBuilder lang, StringBuilder trans) {
			interceptor.Invoke("translateRaw$$$$", "translateRaw(const char*, const char*, QString*, QString*) const", typeof(void), typeof(string), ctxt, typeof(string), msg, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
		}
		/// <remarks>
		///  Raw translation from message catalogs, with given singular/plural form.
		///  Singular form is used as the lookup key in catalogs.
		///  Never use this directly to get message translations. See i18n and ki18n
		///  calls related to KLocalizedString.
		/// <param> name="singular" the singular form. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="plural" the plural form. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="n" number on which the forms are decided.
		/// </param><param> name="lang" language in which the translation was found. If no translation
		///              was found, KLocale.DefaultLanguage() is reported. If null,
		///              the language is not reported.
		/// </param><param> name="trans" raw translation, or original if not found. If no translation
		///               was found, original message is reported (either plural or
		///               singular, as determined by <code>n</code> ). If null, the
		///               translation is not reported.
		/// </param></remarks>		<short>    Raw translation from message catalogs, with given singular/plural form.</short>
		/// 		<see> KLocalizedString</see>
		public void TranslateRaw(string singular, string plural, ulong n, StringBuilder lang, StringBuilder trans) {
			interceptor.Invoke("translateRaw$$$$$", "translateRaw(const char*, const char*, unsigned long, QString*, QString*) const", typeof(void), typeof(string), singular, typeof(string), plural, typeof(ulong), n, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
		}
		/// <remarks>
		///  Raw translation from message catalogs, with given context and
		///  singular/plural form.
		///  Context + singular form is used as the lookup key in catalogs.
		///  Never use this directly to get message translations. See i18n and ki18n
		///  calls related to KLocalizedString.
		/// <param> name="ctxt" the context. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="singular" the singular form. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="plural" the plural form. Must not be null. Must be UTF-8 encoded.
		/// </param><param> name="n" number on which the forms are decided.
		/// </param><param> name="lang" language in which the translation was found. If no translation
		///              was found, KLocale.DefaultLanguage() is reported. If null,
		///              the language is not reported.
		/// </param><param> name="trans" raw translation, or original if not found. If no translation
		///               was found, original message is reported (either plural or
		///               singular, as determined by <code>n</code> ). If null, the
		///               translation is not reported.
		/// </param></remarks>		<short>    Raw translation from message catalogs, with given context and  singular/plural form.</short>
		/// 		<see> KLocalizedString</see>
		public void TranslateRaw(string ctxt, string singular, string plural, ulong n, StringBuilder lang, StringBuilder trans) {
			interceptor.Invoke("translateRaw$$$$$$", "translateRaw(const char*, const char*, const char*, unsigned long, QString*, QString*) const", typeof(void), typeof(string), ctxt, typeof(string), singular, typeof(string), plural, typeof(ulong), n, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
		}
		/// <remarks>
		///  Changes the current encoding.
		/// <param> name="mibEnum" The mib of the preferred codec
		/// </param></remarks>		<return> True on success.
		///    </return>
		/// 		<short>    Changes the current encoding.</short>
		public bool SetEncoding(int mibEnum) {
			return (bool) interceptor.Invoke("setEncoding$", "setEncoding(int)", typeof(bool), typeof(int), mibEnum);
		}
		/// <remarks>
		///  Returns what a decimal point should look like ("." or "," etc.)
		///  according to the current locale or user settings.
		/// </remarks>		<return> The decimal symbol used by locale.
		///    </return>
		/// 		<short>    Returns what a decimal point should look like (".</short>
		public string DecimalSymbol() {
			return (string) interceptor.Invoke("decimalSymbol", "decimalSymbol() const", typeof(string));
		}
		/// <remarks>
		///  Returns what the thousands separator should look
		///  like ("," or "." etc.)
		///  according to the current locale or user settings.
		/// </remarks>		<return> The thousands separator used by locale.
		///    </return>
		/// 		<short>    Returns what the thousands separator should look  like ("," or ".</short>
		public string ThousandsSeparator() {
			return (string) interceptor.Invoke("thousandsSeparator", "thousandsSeparator() const", typeof(string));
		}
		/// <remarks>
		///  Returns what the symbol denoting currency in the current locale
		///  as as defined by user settings should look like.
		/// </remarks>		<return> The default currency symbol used by locale.
		///    </return>
		/// 		<short>    Returns what the symbol denoting currency in the current locale  as as defined by user settings should look like.</short>
		public string CurrencySymbol() {
			return (string) interceptor.Invoke("currencySymbol", "currencySymbol() const", typeof(string));
		}
		/// <remarks>
		///  Returns what a decimal point should look like ("." or "," etc.)
		///  for monetary values, according to the current locale or user
		///  settings.
		/// </remarks>		<return> The monetary decimal symbol used by locale.
		///    </return>
		/// 		<short>    Returns what a decimal point should look like (".</short>
		public string MonetaryDecimalSymbol() {
			return (string) interceptor.Invoke("monetaryDecimalSymbol", "monetaryDecimalSymbol() const", typeof(string));
		}
		/// <remarks>
		///  Returns what a thousands separator for monetary values should
		///  look like ("," or " " etc.) according to the current locale or
		///  user settings.
		/// </remarks>		<return> The monetary thousands separator used by locale.
		///    </return>
		/// 		<short>    Returns what a thousands separator for monetary values should  look like ("," or " " etc.</short>
		public string MonetaryThousandsSeparator() {
			return (string) interceptor.Invoke("monetaryThousandsSeparator", "monetaryThousandsSeparator() const", typeof(string));
		}
		/// <remarks>
		///  Returns what a positive sign should look like ("+", " ", etc.)
		///  according to the current locale or user settings.
		/// </remarks>		<return> The positive sign used by locale.
		///    </return>
		/// 		<short>    Returns what a positive sign should look like ("+", " ", etc.</short>
		public string PositiveSign() {
			return (string) interceptor.Invoke("positiveSign", "positiveSign() const", typeof(string));
		}
		/// <remarks>
		///  Returns what a negative sign should look like ("-", etc.)
		///  according to the current locale or user settings.
		/// </remarks>		<return> The negative sign used by locale.
		///    </return>
		/// 		<short>    Returns what a negative sign should look like ("-", etc.</short>
		public string NegativeSign() {
			return (string) interceptor.Invoke("negativeSign", "negativeSign() const", typeof(string));
		}
		/// <remarks>
		///  The number of fractional digits to include in numeric/monetary
		///  values (usually 2).
		/// </remarks>		<return> Default number of fractional digits used by locale.
		///    </return>
		/// 		<short>    The number of fractional digits to include in numeric/monetary  values (usually 2).</short>
		public int FracDigits() {
			return (int) interceptor.Invoke("fracDigits", "fracDigits() const", typeof(int));
		}
		/// <remarks>
		///  If and only if the currency symbol precedes a positive value,
		///  this will be true.
		/// </remarks>		<return> Where to print the currency symbol for positive numbers.
		///    </return>
		/// 		<short>    If and only if the currency symbol precedes a positive value,  this will be true.</short>
		public bool PositivePrefixCurrencySymbol() {
			return (bool) interceptor.Invoke("positivePrefixCurrencySymbol", "positivePrefixCurrencySymbol() const", typeof(bool));
		}
		/// <remarks>
		///  If and only if the currency symbol precedes a negative value,
		///  this will be true.
		/// </remarks>		<return> True if the currency symbol precedes negative numbers.
		///    </return>
		/// 		<short>    If and only if the currency symbol precedes a negative value,  this will be true.</short>
		public bool NegativePrefixCurrencySymbol() {
			return (bool) interceptor.Invoke("negativePrefixCurrencySymbol", "negativePrefixCurrencySymbol() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the position of a positive sign in relation to a
		///  monetary value.
		/// </remarks>		<return> Where/how to print the positive sign.
		/// </return>
		/// 		<short>    Returns the position of a positive sign in relation to a  monetary value.</short>
		/// 		<see> SignPosition</see>
		public KLocale.SignPosition PositiveMonetarySignPosition() {
			return (KLocale.SignPosition) interceptor.Invoke("positiveMonetarySignPosition", "positiveMonetarySignPosition() const", typeof(KLocale.SignPosition));
		}
		/// <remarks>
		///  Denotes where to place a negative sign in relation to a
		///  monetary value.
		/// </remarks>		<return> Where/how to print the negative sign.
		/// </return>
		/// 		<short>    Denotes where to place a negative sign in relation to a  monetary value.</short>
		/// 		<see> SignPosition</see>
		public KLocale.SignPosition NegativeMonetarySignPosition() {
			return (KLocale.SignPosition) interceptor.Invoke("negativeMonetarySignPosition", "negativeMonetarySignPosition() const", typeof(KLocale.SignPosition));
		}
		/// <remarks>
		///  Given a double, converts that to a numeric string containing
		///  the localized monetary equivalent.
		///  e.g. given 123456, return "$ 123,456.00".
		/// <param> name="num" The number we want to format
		/// </param><param> name="currency" The currency symbol you want.
		/// </param><param> name="digits" Number of fractional digits, or -1 for the default
		///                value
		/// </param></remarks>		<return> The number of money as a localized string
		/// </return>
		/// 		<short>    Given a double, converts that to a numeric string containing  the localized monetary equivalent.</short>
		/// 		<see> fracDigits</see>
		public string FormatMoney(double num, string currency, int digits) {
			return (string) interceptor.Invoke("formatMoney$$$", "formatMoney(double, const QString&, int) const", typeof(string), typeof(double), num, typeof(string), currency, typeof(int), digits);
		}
		public string FormatMoney(double num, string currency) {
			return (string) interceptor.Invoke("formatMoney$$", "formatMoney(double, const QString&) const", typeof(string), typeof(double), num, typeof(string), currency);
		}
		public string FormatMoney(double num) {
			return (string) interceptor.Invoke("formatMoney$", "formatMoney(double) const", typeof(string), typeof(double), num);
		}
		/// <remarks>
		///  Given a double, converts that to a numeric string containing
		///  the localized numeric equivalent.
		///  e.g. given 123456.78F, return "123,456.78" (for some European country).
		///  If precision isn't specified, 2 is used.
		///  This function is a wrapper that is provided for convenience.
		/// <param> name="num" The number to convert
		/// </param><param> name="precision" Number of fractional digits used.
		/// </param></remarks>		<return> The number as a localized string
		/// </return>
		/// 		<short>    Given a double, converts that to a numeric string containing  the localized numeric equivalent.</short>
		/// 		<see> formatNumber(const</see>
		/// 		<see> bool</see>
		/// 		<see> int)</see>
		public string FormatNumber(double num, int precision) {
			return (string) interceptor.Invoke("formatNumber$$", "formatNumber(double, int) const", typeof(string), typeof(double), num, typeof(int), precision);
		}
		public string FormatNumber(double num) {
			return (string) interceptor.Invoke("formatNumber$", "formatNumber(double) const", typeof(string), typeof(double), num);
		}
		/// <remarks>
		///  Given a string representing a number, converts that to a numeric
		///  string containing the localized numeric equivalent.
		///  e.g. given 123456.78F, return "123,456.78" (for some European country).
		/// <param> name="numStr" The number to format, as a string.
		/// </param><param> name="round" Round fractional digits. (default true)
		/// </param><param> name="precision" Number of fractional digits used for rounding. Unused if round=false. (default 2)
		/// </param></remarks>		<return> The number as a localized string
		///    </return>
		/// 		<short>    Given a string representing a number, converts that to a numeric  string containing the localized numeric equivalent.</short>
		public string FormatNumber(string numStr, bool round, int precision) {
			return (string) interceptor.Invoke("formatNumber$$$", "formatNumber(const QString&, bool, int) const", typeof(string), typeof(string), numStr, typeof(bool), round, typeof(int), precision);
		}
		public string FormatNumber(string numStr, bool round) {
			return (string) interceptor.Invoke("formatNumber$$", "formatNumber(const QString&, bool) const", typeof(string), typeof(string), numStr, typeof(bool), round);
		}
		public string FormatNumber(string numStr) {
			return (string) interceptor.Invoke("formatNumber$", "formatNumber(const QString&) const", typeof(string), typeof(string), numStr);
		}
		/// <remarks>
		///  Given an integer, converts that to a numeric string containing
		///  the localized numeric equivalent.
		///  e.g. given 123456L, return "123,456" (for some European country).
		/// <param> name="num" The number to convert
		/// </param></remarks>		<return> The number as a localized string
		///    </return>
		/// 		<short>    Given an integer, converts that to a numeric string containing  the localized numeric equivalent.</short>
		public string FormatLong(long num) {
			return (string) interceptor.Invoke("formatLong$", "formatLong(long) const", typeof(string), typeof(long), num);
		}
		/// <remarks>
		///  Converts <code>size</code> from bytes to the string representation using the
		///  IEC 60027-2 standard
		///  Example:
		///  formatByteSize(1024) returns "1.0 KiB"
		/// <param> name="size" size in bytes
		/// </param></remarks>		<return> converted size as a string - e.g. 123.4 KiB , 12.0 MiB
		///    </return>
		/// 		<short>    Converts <code>size</code> from bytes to the string representation using the  IEC 60027-2 standard </short>
		public string FormatByteSize(double size) {
			return (string) interceptor.Invoke("formatByteSize$", "formatByteSize(double) const", typeof(string), typeof(double), size);
		}
		/// <remarks>
		///  Given a number of milliseconds, converts that to a string containing
		///  the localized equivalent
		///  e.g. given formatDuration(60000), returns "1.0 minutes"
		/// <param> name="mSec" Time duration in milliseconds
		/// </param></remarks>		<return> converted duration as a string - e.g. "5.5 seconds" "23.0 minutes"
		///    </return>
		/// 		<short>    Given a number of milliseconds, converts that to a string containing  the localized equivalent </short>
		public string FormatDuration(ulong mSec) {
			return (string) interceptor.Invoke("formatDuration$", "formatDuration(unsigned long) const", typeof(string), typeof(ulong), mSec);
		}
		/// <remarks>
		///  Use this to determine whether nouns are declined in
		///  locale's language. This property should remain
		///  read-only (no setter function)
		/// </remarks>		<return> If nouns are declined
		///    </return>
		/// 		<short>    Use this to determine whether nouns are declined in  locale's language.</short>
		public bool NounDeclension() {
			return (bool) interceptor.Invoke("nounDeclension", "nounDeclension() const", typeof(bool));
		}
		/// <remarks>
		///  Returns a string formatted to the current locale's conventions
		///  regarding dates.
		/// <param> name="date" the date to be formatted.
		/// </param><param> name="format" category of date format to use
		/// </param></remarks>		<return> The date as a string
		///    </return>
		/// 		<short>    Returns a string formatted to the current locale's conventions  regarding dates.</short>
		public string FormatDate(QDate date, KLocale.DateFormat format) {
			return (string) interceptor.Invoke("formatDate#$", "formatDate(const QDate&, KLocale::DateFormat) const", typeof(string), typeof(QDate), date, typeof(KLocale.DateFormat), format);
		}
		public string FormatDate(QDate date) {
			return (string) interceptor.Invoke("formatDate#", "formatDate(const QDate&) const", typeof(string), typeof(QDate), date);
		}
		/// <remarks>
		///  Returns a string formatted to the current locale's conventions
		///  regarding both date and time.
		/// <param> name="dateTime" the date and time to be formatted
		/// </param><param> name="format" category of date format to use
		/// </param><param> name="options" additional output options
		/// </param></remarks>		<return> The date and time as a string
		///    </return>
		/// 		<short>    Returns a string formatted to the current locale's conventions  regarding both date and time.</short>
		public string FormatDateTime(QDateTime dateTime, KLocale.DateFormat format, bool includeSecs) {
			return (string) interceptor.Invoke("formatDateTime#$$", "formatDateTime(const QDateTime&, KLocale::DateFormat, bool) const", typeof(string), typeof(QDateTime), dateTime, typeof(KLocale.DateFormat), format, typeof(bool), includeSecs);
		}
		public string FormatDateTime(QDateTime dateTime, KLocale.DateFormat format) {
			return (string) interceptor.Invoke("formatDateTime#$", "formatDateTime(const QDateTime&, KLocale::DateFormat) const", typeof(string), typeof(QDateTime), dateTime, typeof(KLocale.DateFormat), format);
		}
		public string FormatDateTime(QDateTime dateTime) {
			return (string) interceptor.Invoke("formatDateTime#", "formatDateTime(const QDateTime&) const", typeof(string), typeof(QDateTime), dateTime);
		}
		/// <remarks>
		///  Returns a string formatted to the current locale's conventions
		///  regarding both date and time.
		/// <param> name="dateTime" the date and time to be formatted
		/// </param><param> name="format" category of date format to use
		/// </param><param> name="options" additional output options
		/// </param></remarks>		<return> The date and time as a string
		///    </return>
		/// 		<short>    Returns a string formatted to the current locale's conventions  regarding both date and time.</short>
		public string FormatDateTime(KDateTime dateTime, KLocale.DateFormat format, uint options) {
			return (string) interceptor.Invoke("formatDateTime#$$", "formatDateTime(const KDateTime&, KLocale::DateFormat, KLocale::DateTimeFormatOptions) const", typeof(string), typeof(KDateTime), dateTime, typeof(KLocale.DateFormat), format, typeof(uint), options);
		}
		public string FormatDateTime(KDateTime dateTime, KLocale.DateFormat format) {
			return (string) interceptor.Invoke("formatDateTime#$", "formatDateTime(const KDateTime&, KLocale::DateFormat) const", typeof(string), typeof(KDateTime), dateTime, typeof(KLocale.DateFormat), format);
		}
		public string FormatDateTime(KDateTime dateTime) {
			return (string) interceptor.Invoke("formatDateTime#", "formatDateTime(const KDateTime&) const", typeof(string), typeof(KDateTime), dateTime);
		}
		/// <remarks>
		///  Use this to determine whether in dates a possessive form of month
		///  name is preferred ("of January" rather than "January")
		/// </remarks>		<return> If possessive form should be used
		///   </return>
		/// 		<short>    Use this to determine whether in dates a possessive form of month  name is preferred ("of January" rather than "January") </short>
		public bool DateMonthNamePossessive() {
			return (bool) interceptor.Invoke("dateMonthNamePossessive", "dateMonthNamePossessive() const", typeof(bool));
		}
		/// <remarks>
		///  Returns a string formatted to the current locale's conventions
		///  regarding times.
		/// <param> name="pTime" The time to be formatted.
		/// </param><param> name="includeSecs" if true, seconds are included in the output,
		///         otherwise only hours and minutes are formatted.
		/// </param><param> name="isDuration" if true, the given time is a duration, not a clock time.
		///  This means "am/pm" shouldn't be displayed.
		/// </param></remarks>		<return> The time as a string
		///    </return>
		/// 		<short>    Returns a string formatted to the current locale's conventions  regarding times.</short>
		public string FormatTime(QTime pTime, bool includeSecs, bool isDuration) {
			return (string) interceptor.Invoke("formatTime#$$", "formatTime(const QTime&, bool, bool) const", typeof(string), typeof(QTime), pTime, typeof(bool), includeSecs, typeof(bool), isDuration);
		}
		public string FormatTime(QTime pTime, bool includeSecs) {
			return (string) interceptor.Invoke("formatTime#$", "formatTime(const QTime&, bool) const", typeof(string), typeof(QTime), pTime, typeof(bool), includeSecs);
		}
		public string FormatTime(QTime pTime) {
			return (string) interceptor.Invoke("formatTime#", "formatTime(const QTime&) const", typeof(string), typeof(QTime), pTime);
		}
		/// <remarks>
		///  Use this to determine if the user wants a 12 hour clock.
		/// </remarks>		<return> If the user wants 12h clock
		///    </return>
		/// 		<short>    Use this to determine if the user wants a 12 hour clock.</short>
		public bool Use12Clock() {
			return (bool) interceptor.Invoke("use12Clock", "use12Clock() const", typeof(bool));
		}
		/// <remarks>
		///  Use this to determine which day is the first day of the week.
		/// </remarks>		<return> an integer (Monday=1..Sunday=7)
		///    </return>
		/// 		<short>    Use this to determine which day is the first day of the week.</short>
		public int WeekStartDay() {
			return (int) interceptor.Invoke("weekStartDay", "weekStartDay() const", typeof(int));
		}
		/// <remarks>
		///  Returns a pointer to the calendar system object.
		/// </remarks>		<return> the current calendar system instance
		///    </return>
		/// 		<short>    Returns a pointer to the calendar system object.</short>
		public KCalendarSystem Calendar() {
			return (KCalendarSystem) interceptor.Invoke("calendar", "calendar() const", typeof(KCalendarSystem));
		}
		/// <remarks>
		///  Returns the name of the calendar system that is currently being
		///  used by the system.
		/// </remarks>		<return> the name of the calendar system
		///    </return>
		/// 		<short>    Returns the name of the calendar system that is currently being  used by the system.</short>
		public string CalendarType() {
			return (string) interceptor.Invoke("calendarType", "calendarType() const", typeof(string));
		}
		/// <remarks>
		///  Changes the current calendar system to the calendar specified.
		///  Currently "gregorian" and "hijri" are supported. If the calendar
		///  system specified is not found, gregorian will be used.
		/// <param> name="calendarType" the name of the calendar type
		///    </param></remarks>		<short>    Changes the current calendar system to the calendar specified.</short>
		public void SetCalendar(string calendarType) {
			interceptor.Invoke("setCalendar$", "setCalendar(const QString&)", typeof(void), typeof(string), calendarType);
		}
		/// <remarks>
		///  Converts a localized monetary string to a double.
		/// <param> name="numStr" the string we want to convert.
		/// </param><param> name="ok" the boolean that is set to false if it's not a number.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a double
		///    </return>
		/// 		<short>    Converts a localized monetary string to a double.</short>
		public double ReadMoney(string numStr, ref bool ok) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(numStr);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(numStr);
#endif
			stack[2].s_bool = ok;
			interceptor.Invoke("readMoney$$", "readMoney(const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[2].s_bool;
			return stack[0].s_double;
		}
		public double ReadMoney(string numStr) {
			return (double) interceptor.Invoke("readMoney$", "readMoney(const QString&) const", typeof(double), typeof(string), numStr);
		}
		/// <remarks>
		///  Converts a localized numeric string to a double.
		/// <param> name="numStr" the string we want to convert.
		/// </param><param> name="ok" the boolean that is set to false if it's not a number.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a double
		///    </return>
		/// 		<short>    Converts a localized numeric string to a double.</short>
		public double ReadNumber(string numStr, ref bool ok) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(numStr);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(numStr);
#endif
			stack[2].s_bool = ok;
			interceptor.Invoke("readNumber$$", "readNumber(const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[2].s_bool;
			return stack[0].s_double;
		}
		public double ReadNumber(string numStr) {
			return (double) interceptor.Invoke("readNumber$", "readNumber(const QString&) const", typeof(double), typeof(string), numStr);
		}
		/// <remarks>
		///  Converts a localized date string to a QDate.
		///  The bool pointed by ok will be invalid if the date entered was not valid.
		/// <param> name="str" the string we want to convert.
		/// </param><param> name="ok" the boolean that is set to false if it's not a valid date.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a QDate
		///    </return>
		/// 		<short>    Converts a localized date string to a QDate.</short>
		public QDate ReadDate(string str, ref bool ok) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
			stack[2].s_bool = ok;
			interceptor.Invoke("readDate$$", "readDate(const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[2].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QDate) returnValue;
		}
		public QDate ReadDate(string str) {
			return (QDate) interceptor.Invoke("readDate$", "readDate(const QString&) const", typeof(QDate), typeof(string), str);
		}
		/// <remarks>
		///  Converts a localized date string to a QDate, using the specified format.
		///  You will usually not want to use this method.
		///    </remarks>		<short>    Converts a localized date string to a QDate, using the specified format.</short>
		public QDate ReadDate(string intstr, string fmt, ref bool ok) {
			StackItem[] stack = new StackItem[4];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(intstr);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(intstr);
#endif
#if DEBUG
			stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(fmt);
#else
			stack[2].s_class = (IntPtr) GCHandle.Alloc(fmt);
#endif
			stack[3].s_bool = ok;
			interceptor.Invoke("readDate$$$", "readDate(const QString&, const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
			((GCHandle) stack[2].s_class).Free();
#endif
			ok = stack[3].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QDate) returnValue;
		}
		public QDate ReadDate(string intstr, string fmt) {
			return (QDate) interceptor.Invoke("readDate$$", "readDate(const QString&, const QString&) const", typeof(QDate), typeof(string), intstr, typeof(string), fmt);
		}
		/// <remarks>
		///  Converts a localized date string to a QDate.
		///  This method is stricter than readDate(str,&ok): it will either accept
		///  a date in full format or a date in short format, depending on <code>flags.</code>
		/// <param> name="str" the string we want to convert.
		/// </param><param> name="flags" whether the date string is to be in full format or in short format.
		/// </param><param> name="ok" the boolean that is set to false if it's not a valid date.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a QDate
		///    </return>
		/// 		<short>    Converts a localized date string to a QDate.</short>
		public QDate ReadDate(string str, KLocale.ReadDateFlags flags, ref bool ok) {
			StackItem[] stack = new StackItem[4];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
			stack[2].s_int = (int) flags;
			stack[3].s_bool = ok;
			interceptor.Invoke("readDate$$$", "readDate(const QString&, KLocale::ReadDateFlags, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[3].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QDate) returnValue;
		}
		public QDate ReadDate(string str, KLocale.ReadDateFlags flags) {
			return (QDate) interceptor.Invoke("readDate$$", "readDate(const QString&, KLocale::ReadDateFlags) const", typeof(QDate), typeof(string), str, typeof(KLocale.ReadDateFlags), flags);
		}
		/// <remarks>
		///  Converts a localized time string to a QTime.
		///  This method will try to parse it with seconds, then without seconds.
		///  The bool pointed to by <code>ok</code> will be set to false if the time entered was
		///  not valid.
		/// <param> name="str" the string we want to convert.
		/// </param><param> name="ok" the boolean that is set to false if it's not a valid time.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a QTime
		///    </return>
		/// 		<short>    Converts a localized time string to a QTime.</short>
		public QTime ReadTime(string str, ref bool ok) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
			stack[2].s_bool = ok;
			interceptor.Invoke("readTime$$", "readTime(const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[2].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QTime) returnValue;
		}
		public QTime ReadTime(string str) {
			return (QTime) interceptor.Invoke("readTime$", "readTime(const QString&) const", typeof(QTime), typeof(string), str);
		}
		/// <remarks>
		///  Converts a localized time string to a QTime.
		///  This method is stricter than readTime(str,&ok): it will either accept
		///  a time with seconds or a time without seconds.
		///  Use this method when the format is known by the application.
		/// <param> name="str" the string we want to convert.
		/// </param><param> name="flags" whether the time string is expected to contain seconds or not.
		/// </param><param> name="ok" the boolean that is set to false if it's not a valid time.
		///            If <code>ok</code> is 0, it will be ignored
		/// </param></remarks>		<return> The string converted to a QTime
		///    </return>
		/// 		<short>    Converts a localized time string to a QTime.</short>
		public QTime ReadTime(string str, KLocale.ReadTimeFlags flags, ref bool ok) {
			StackItem[] stack = new StackItem[4];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
			stack[2].s_int = (int) flags;
			stack[3].s_bool = ok;
			interceptor.Invoke("readTime$$$", "readTime(const QString&, KLocale::ReadTimeFlags, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[3].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QTime) returnValue;
		}
		public QTime ReadTime(string str, KLocale.ReadTimeFlags flags) {
			return (QTime) interceptor.Invoke("readTime$$", "readTime(const QString&, KLocale::ReadTimeFlags) const", typeof(QTime), typeof(string), str, typeof(KLocale.ReadTimeFlags), flags);
		}
		/// <remarks>
		///  Returns the language code used by this object. The domain AND the
		///  library translation must be available in this language.
		///  defaultLanguage() is returned by default, if no other available.
		///  Use languageCodeToName(language) to get human readable, localized
		///  language name.
		/// </remarks>		<return> the currently used language code
		/// </return>
		/// 		<short>    Returns the language code used by this object.</short>
		/// 		<see> languageCodeToName</see>
		public string Language() {
			return (string) interceptor.Invoke("language", "language() const", typeof(string));
		}
		/// <remarks>
		///  Returns the country code of the country where the user lives.
		///  defaultCountry() is returned by default, if no other available.
		///  Use countryCodeToName(country) to get human readable, localized
		///  country names.
		/// </remarks>		<return> the country code for the user
		/// </return>
		/// 		<short>    Returns the country code of the country where the user lives.</short>
		/// 		<see> countryCodeToName</see>
		public string Country() {
			return (string) interceptor.Invoke("country", "country() const", typeof(string));
		}
		/// <remarks>
		///  Returns the language codes selected by user, ordered by decreasing
		///  priority.
		///  Use languageCodeToName(language) to get human readable, localized
		///  language name.
		/// </remarks>		<return> list of language codes
		/// </return>
		/// 		<short>    Returns the language codes selected by user, ordered by decreasing  priority.</short>
		/// 		<see> languageCodeToName</see>
		public List<string> LanguageList() {
			return (List<string>) interceptor.Invoke("languageList", "languageList() const", typeof(List<string>));
		}
		/// <remarks>
		///  Returns the user's preferred encoding.
		/// </remarks>		<return> The name of the preferred encoding
		/// </return>
		/// 		<short>    Returns the user's preferred encoding.</short>
		/// 		<see> codecForEncoding</see>
		/// 		<see> encodingMib</see>
		public QByteArray Encoding() {
			return (QByteArray) interceptor.Invoke("encoding", "encoding() const", typeof(QByteArray));
		}
		/// <remarks>
		///  Returns the user's preferred encoding.
		/// </remarks>		<return> The Mib of the preferred encoding
		/// </return>
		/// 		<short>    Returns the user's preferred encoding.</short>
		/// 		<see> encoding</see>
		/// 		<see> codecForEncoding</see>
		public int EncodingMib() {
			return (int) interceptor.Invoke("encodingMib", "encodingMib() const", typeof(int));
		}
		/// <remarks>
		///  Returns the user's preferred encoding. Should never be NULL.
		/// </remarks>		<return> The codec for the preferred encoding
		/// </return>
		/// 		<short>    Returns the user's preferred encoding.</short>
		/// 		<see> encoding</see>
		/// 		<see> encodingMib</see>
		public QTextCodec CodecForEncoding() {
			return (QTextCodec) interceptor.Invoke("codecForEncoding", "codecForEncoding() const", typeof(QTextCodec));
		}
		/// <remarks>
		///  Returns the file encoding.
		/// </remarks>		<return> The Mib of the file encoding
		/// </return>
		/// 		<short>    Returns the file encoding.</short>
		/// 		<see> QFile.EncodeName</see>
		/// 		<see> QFile.DecodeName</see>
		public int FileEncodingMib() {
			return (int) interceptor.Invoke("fileEncodingMib", "fileEncodingMib() const", typeof(int));
		}
		/// <remarks>
		///  Changes the current date format.
		///  The format of the date is a string which contains variables that will
		///  be replaced:
		/// 
		/// <li>
		/// %Y with the century (e.g. "19" for "1984")
		/// </li>
		/// 
		/// <li>
		/// %y with the lower 2 digits of the year (e.g. "84" for "1984")
		/// </li>
		/// 
		/// <li>
		/// %n with the month (January="1", December="12")
		/// </li>
		/// 
		/// <li>
		/// %m with the month with two digits (January="01", December="12")
		/// </li>
		/// 
		/// <li>
		/// %e with the day of the month (e.g. "1" on the first of march)
		/// </li>
		/// 
		/// <li>
		/// %d with the day of the month with two digits(e.g. "01" on the first of march)
		/// </li>
		/// 
		/// <li>
		/// %b with the short form of the month (e.g. "Jan" for January)
		/// </li>
		/// 
		/// <li>
		/// %B with the long form of the month (e.g. "January")
		/// </li>
		/// 
		/// <li>
		/// %a with the short form of the weekday (e.g. "Wed" for Wednesday)
		/// </li>
		/// 
		/// <li>
		/// %A with the long form of the weekday (e.g. "Wednesday" for Wednesday)
		/// </li>
		///  Everything else in the format string will be taken as is.
		///  For example, March 20th 1989 with the format "%y:%m:%d" results
		///  in "89:03:20".
		/// <param> name="format" The new date format
		///    </param></remarks>		<short>    Changes the current date format.</short>
		public void SetDateFormat(string format) {
			interceptor.Invoke("setDateFormat$", "setDateFormat(const QString&)", typeof(void), typeof(string), format);
		}
		/// <remarks>
		///  Changes the current short date format.
		///  The format of the date is a string which contains variables that will
		///  be replaced:
		/// 
		/// <li>
		/// %Y with the century (e.g. "19" for "1984")
		/// </li>
		/// 
		/// <li>
		/// %y with the lower 2 digits of the year (e.g. "84" for "1984")
		/// </li>
		/// 
		/// <li>
		/// %n with the month (January="1", December="12")
		/// </li>
		/// 
		/// <li>
		/// %m with the month with two digits (January="01", December="12")
		/// </li>
		/// 
		/// <li>
		/// %e with the day of the month (e.g. "1" on the first of march)
		/// </li>
		/// 
		/// <li>
		/// %d with the day of the month with two digits(e.g. "01" on the first of march)
		/// </li>
		/// 
		/// <li>
		/// %b with the short form of the month (e.g. "Jan" for January)
		/// </li>
		/// 
		/// <li>
		/// %B with the long form of the month (e.g. "January")
		/// </li>
		/// 
		/// <li>
		/// %a with the short form of the weekday (e.g. "Wed" for Wednesday)
		/// </li>
		/// 
		/// <li>
		/// %A with the long form of the weekday (e.g. "Wednesday" for Wednesday)
		/// </li>
		///  Everything else in the format string will be taken as is.
		///  For example, March 20th 1989 with the format "%y:%m:%d" results
		///  in "89:03:20".
		/// <param> name="format" The new short date format
		///    </param></remarks>		<short>    Changes the current short date format.</short>
		public void SetDateFormatShort(string format) {
			interceptor.Invoke("setDateFormatShort$", "setDateFormatShort(const QString&)", typeof(void), typeof(string), format);
		}
		/// <remarks>
		///  Changes the form of month name used in dates.
		/// <param> name="possessive" True if possessive forms should be used
		///    </param></remarks>		<short>    Changes the form of month name used in dates.</short>
		public void SetDateMonthNamePossessive(bool possessive) {
			interceptor.Invoke("setDateMonthNamePossessive$", "setDateMonthNamePossessive(bool)", typeof(void), typeof(bool), possessive);
		}
		/// <remarks>
		///  Changes the current time format.
		///  The format of the time is string a which contains variables that will
		///  be replaced:
		/// 
		/// <li>
		/// %H with the hour in 24h format and 2 digits (e.g. 5pm is "17", 5am is "05")
		/// </li>
		/// 
		/// <li>
		/// %k with the hour in 24h format and one digits (e.g. 5pm is "17", 5am is "5")
		/// </li>
		/// 
		/// <li>
		/// %I with the hour in 12h format and 2 digits (e.g. 5pm is "05", 5am is "05")
		/// </li>
		/// 
		/// <li>
		/// %l with the hour in 12h format and one digits (e.g. 5pm is "5", 5am is "5")
		/// </li>
		/// 
		/// <li>
		/// %M with the minute with 2 digits (e.g. the minute of 07:02:09 is "02")
		/// </li>
		/// 
		/// <li>
		/// %S with the seconds with 2 digits  (e.g. the minute of 07:02:09 is "09")
		/// </li>
		/// 
		/// <li>
		/// %p with pm or am (e.g. 17.00 is "pm", 05.00 is "am")
		/// </li>
		///  Everything else in the format string will be taken as is.
		///  For example, 5.23pm with the format "%H:%M" results
		///  in "17:23".
		/// <param> name="format" The new time format
		///    </param></remarks>		<short>    Changes the current time format.</short>
		public void SetTimeFormat(string format) {
			interceptor.Invoke("setTimeFormat$", "setTimeFormat(const QString&)", typeof(void), typeof(string), format);
		}
		/// <remarks>
		///  Changes how KLocale defines the first day in week.
		/// <param> name="day" first day of the week (Monday=1..Sunday=7) as integer
		///    </param></remarks>		<short>    Changes how KLocale defines the first day in week.</short>
		public void SetWeekStartDay(int day) {
			interceptor.Invoke("setWeekStartDay$", "setWeekStartDay(int)", typeof(void), typeof(int), day);
		}
		/// <remarks>
		///  Returns the currently selected date format.
		/// </remarks>		<return> Current date format.
		/// </return>
		/// 		<short>    Returns the currently selected date format.</short>
		/// 		<see> setDateFormat</see>
		public string dateFormat() {
			return (string) interceptor.Invoke("dateFormat", "dateFormat() const", typeof(string));
		}
		/// <remarks>
		///  Returns the currently selected short date format.
		/// </remarks>		<return> Current short date format.
		/// </return>
		/// 		<short>    Returns the currently selected short date format.</short>
		/// 		<see> setDateFormatShort</see>
		public string DateFormatShort() {
			return (string) interceptor.Invoke("dateFormatShort", "dateFormatShort() const", typeof(string));
		}
		/// <remarks>
		///  Returns the currently selected time format.
		/// </remarks>		<return> Current time format.
		/// </return>
		/// 		<short>    Returns the currently selected time format.</short>
		/// 		<see> setTimeFormat</see>
		public string TimeFormat() {
			return (string) interceptor.Invoke("timeFormat", "timeFormat() const", typeof(string));
		}
		/// <remarks>
		///  Changes the symbol used to identify the decimal pointer.
		/// <param> name="symbol" The new decimal symbol.
		///    </param></remarks>		<short>    Changes the symbol used to identify the decimal pointer.</short>
		public void SetDecimalSymbol(string symbol) {
			interceptor.Invoke("setDecimalSymbol$", "setDecimalSymbol(const QString&)", typeof(void), typeof(string), symbol);
		}
		/// <remarks>
		///  Changes the separator used to group digits when formating numbers.
		/// <param> name="separator" The new thousands separator.
		///    </param></remarks>		<short>    Changes the separator used to group digits when formating numbers.</short>
		public void SetThousandsSeparator(string separator) {
			interceptor.Invoke("setThousandsSeparator$", "setThousandsSeparator(const QString&)", typeof(void), typeof(string), separator);
		}
		/// <remarks>
		///  Changes the sign used to identify a positive number. Normally this is
		///  left blank.
		/// <param> name="sign" Sign used for positive numbers.
		///    </param></remarks>		<short>    Changes the sign used to identify a positive number.</short>
		public void SetPositiveSign(string sign) {
			interceptor.Invoke("setPositiveSign$", "setPositiveSign(const QString&)", typeof(void), typeof(string), sign);
		}
		/// <remarks>
		///  Changes the sign used to identify a negative number.
		/// <param> name="sign" Sign used for negative numbers.
		///    </param></remarks>		<short>    Changes the sign used to identify a negative number.</short>
		public void SetNegativeSign(string sign) {
			interceptor.Invoke("setNegativeSign$", "setNegativeSign(const QString&)", typeof(void), typeof(string), sign);
		}
		/// <remarks>
		///  Changes the sign position used for positive monetary values.
		/// <param> name="signpos" The new sign position
		///    </param></remarks>		<short>    Changes the sign position used for positive monetary values.</short>
		public void SetPositiveMonetarySignPosition(KLocale.SignPosition signpos) {
			interceptor.Invoke("setPositiveMonetarySignPosition$", "setPositiveMonetarySignPosition(KLocale::SignPosition)", typeof(void), typeof(KLocale.SignPosition), signpos);
		}
		/// <remarks>
		///  Changes the sign position used for negative monetary values.
		/// <param> name="signpos" The new sign position
		///    </param></remarks>		<short>    Changes the sign position used for negative monetary values.</short>
		public void SetNegativeMonetarySignPosition(KLocale.SignPosition signpos) {
			interceptor.Invoke("setNegativeMonetarySignPosition$", "setNegativeMonetarySignPosition(KLocale::SignPosition)", typeof(void), typeof(KLocale.SignPosition), signpos);
		}
		/// <remarks>
		///  Changes the position where the currency symbol should be printed for
		///  positive monetary values.
		/// <param> name="prefix" True if the currency symbol should be prefixed instead of
		///  postfixed
		///    </param></remarks>		<short>    Changes the position where the currency symbol should be printed for  positive monetary values.</short>
		public void SetPositivePrefixCurrencySymbol(bool prefix) {
			interceptor.Invoke("setPositivePrefixCurrencySymbol$", "setPositivePrefixCurrencySymbol(bool)", typeof(void), typeof(bool), prefix);
		}
		/// <remarks>
		///  Changes the position where the currency symbol should be printed for
		///  negative monetary values.
		/// <param> name="prefix" True if the currency symbol should be prefixed instead of
		///  postfixed
		///    </param></remarks>		<short>    Changes the position where the currency symbol should be printed for  negative monetary values.</short>
		public void SetNegativePrefixCurrencySymbol(bool prefix) {
			interceptor.Invoke("setNegativePrefixCurrencySymbol$", "setNegativePrefixCurrencySymbol(bool)", typeof(void), typeof(bool), prefix);
		}
		/// <remarks>
		///  Changes the number of digits used when formating numbers.
		/// <param> name="digits" The default number of digits to use.
		///    </param></remarks>		<short>    Changes the number of digits used when formating numbers.</short>
		public void SetFracDigits(int digits) {
			interceptor.Invoke("setFracDigits$", "setFracDigits(int)", typeof(void), typeof(int), digits);
		}
		/// <remarks>
		///  Changes the separator used to group digits when formating monetary values.
		/// <param> name="separator" The new thousands separator.
		///    </param></remarks>		<short>    Changes the separator used to group digits when formating monetary values.</short>
		public void SetMonetaryThousandsSeparator(string separator) {
			interceptor.Invoke("setMonetaryThousandsSeparator$", "setMonetaryThousandsSeparator(const QString&)", typeof(void), typeof(string), separator);
		}
		/// <remarks>
		///  Changes the symbol used to identify the decimal pointer for monetary
		///  values.
		/// <param> name="symbol" The new decimal symbol.
		///    </param></remarks>		<short>    Changes the symbol used to identify the decimal pointer for monetary  values.</short>
		public void SetMonetaryDecimalSymbol(string symbol) {
			interceptor.Invoke("setMonetaryDecimalSymbol$", "setMonetaryDecimalSymbol(const QString&)", typeof(void), typeof(string), symbol);
		}
		/// <remarks>
		///  Changes the current currency symbol.
		/// <param> name="symbol" The new currency symbol
		///    </param></remarks>		<short>    Changes the current currency symbol.</short>
		public void SetCurrencySymbol(string symbol) {
			interceptor.Invoke("setCurrencySymbol$", "setCurrencySymbol(const QString&)", typeof(void), typeof(string), symbol);
		}
		/// <remarks>
		///  Returns the preferred page size for printing.
		/// </remarks>		<return> The preferred page size, cast it to QPrinter.PageSize
		///    </return>
		/// 		<short>    Returns the preferred page size for printing.</short>
		public int PageSize() {
			return (int) interceptor.Invoke("pageSize", "pageSize() const", typeof(int));
		}
		/// <remarks>
		///  Changes the preferred page size when printing.
		/// <param> name="paperFormat" the new preferred page size in the format QPrinter.PageSize
		///    </param></remarks>		<short>    Changes the preferred page size when printing.</short>
		public void SetPageSize(int paperFormat) {
			interceptor.Invoke("setPageSize$", "setPageSize(int)", typeof(void), typeof(int), paperFormat);
		}
		/// <remarks>
		///  Returns which measuring system we use.
		/// </remarks>		<return> The preferred measuring system
		///    </return>
		/// 		<short>    Returns which measuring system we use.</short>
		public KLocale.MeasureSystem measureSystem() {
			return (KLocale.MeasureSystem) interceptor.Invoke("measureSystem", "measureSystem() const", typeof(KLocale.MeasureSystem));
		}
		/// <remarks>
		///  Changes the preferred measuring system.
		/// </remarks>		<return> value The preferred measuring system
		///    </return>
		/// 		<short>    Changes the preferred measuring system.</short>
		public void SetMeasureSystem(KLocale.MeasureSystem value) {
			interceptor.Invoke("setMeasureSystem$", "setMeasureSystem(KLocale::MeasureSystem)", typeof(void), typeof(KLocale.MeasureSystem), value);
		}
		/// <remarks>
		///  Adds another catalog to search for translation lookup.
		///  This function is useful for extern libraries and/or code,
		///  that provide there own messages.
		///  If the catalog does not exist for the chosen language,
		///  it will be ignored and en_US will be used.
		/// <param> name="catalog" The catalog to add.
		///    </param></remarks>		<short>    Adds another catalog to search for translation lookup.</short>
		public void InsertCatalog(string catalog) {
			interceptor.Invoke("insertCatalog$", "insertCatalog(const QString&)", typeof(void), typeof(string), catalog);
		}
		/// <remarks>
		///  Removes a catalog for translation lookup.
		/// <param> name="catalog" The catalog to remove.
		/// </param></remarks>		<short>    Removes a catalog for translation lookup.</short>
		/// 		<see> insertCatalog</see>
		public void RemoveCatalog(string catalog) {
			interceptor.Invoke("removeCatalog$", "removeCatalog(const QString&)", typeof(void), typeof(string), catalog);
		}
		/// <remarks>
		///  Sets the active catalog for translation lookup.
		/// <param> name="catalog" The catalog to activate.
		///    </param></remarks>		<short>    Sets the active catalog for translation lookup.</short>
		public void SetActiveCatalog(string catalog) {
			interceptor.Invoke("setActiveCatalog$", "setActiveCatalog(const QString&)", typeof(void), typeof(string), catalog);
		}
		/// <remarks>
		///  Translates a message as a QTranslator is supposed to.
		///  The parameters are similar to i18n(), but the result
		///  value has other semantics (it can be string())
		/// </remarks>		<short>    Translates a message as a QTranslator is supposed to.</short>
		public string TranslateQt(string context, string sourceText, string comment) {
			return (string) interceptor.Invoke("translateQt$$$", "translateQt(const char*, const char*, const char*) const", typeof(string), typeof(string), context, typeof(string), sourceText, typeof(string), comment);
		}
		/// <remarks>
		///  Provides list of all known language codes.
		///  Use languageCodeToName(language) to get human readable, localized
		///  language names.
		/// </remarks>		<return> list of all language codes
		/// </return>
		/// 		<short>    Provides list of all known language codes.</short>
		/// 		<see> languageCodeToName</see>
		public List<string> AllLanguagesList() {
			return (List<string>) interceptor.Invoke("allLanguagesList", "allLanguagesList() const", typeof(List<string>));
		}
		/// <remarks>
		///  Convert a known language code to a human readable, localized form.
		///  If an unknown language code is supplied, empty string is returned;
		///  this will never happen if the code has been obtained by one of the
		///  KLocale methods.
		/// <param> name="language" the language code
		/// </param></remarks>		<return> the human readable and localized form if the code is known,
		///          empty otherwise
		/// </return>
		/// 		<short>    Convert a known language code to a human readable, localized form.</short>
		/// 		<see> language</see>
		/// 		<see> languageList</see>
		/// 		<see> allLanguagesList</see>
		public string LanguageCodeToName(string language) {
			return (string) interceptor.Invoke("languageCodeToName$", "languageCodeToName(const QString&) const", typeof(string), typeof(string), language);
		}
		/// <remarks>
		///  Provides list of all known country codes.
		///  Use countryCodeToName(country) to get human readable, localized
		///  country names.
		/// </remarks>		<return> a list of all country codes
		/// </return>
		/// 		<short>    Provides list of all known country codes.</short>
		/// 		<see> countryCodeToName</see>
		public List<string> AllCountriesList() {
			return (List<string>) interceptor.Invoke("allCountriesList", "allCountriesList() const", typeof(List<string>));
		}
		/// <remarks>
		///  Convert a known country code to a human readable, localized form.
		///  If an unknown country code is supplied, empty string is returned;
		///  this will never happen if the code has been obtained by one of the
		///  KLocale methods.
		/// <param> name="code" the country code
		/// </param></remarks>		<return> the human readable and localized form of the country name
		/// </return>
		/// 		<short>    Convert a known country code to a human readable, localized form.</short>
		/// 		<see> country</see>
		/// 		<see> allCountriesList</see>
		public string CountryCodeToName(string country) {
			return (string) interceptor.Invoke("countryCodeToName$", "countryCodeToName(const QString&) const", typeof(string), typeof(string), country);
		}
		/// <remarks>
		///  Reports whether evaluation of translation scripts is enabled.
		/// </remarks>		<return> true if script evaluation is enabled, false otherwise.
		///    </return>
		/// 		<short>    Reports whether evaluation of translation scripts is enabled.</short>
		public bool UseTranscript() {
			return (bool) interceptor.Invoke("useTranscript", "useTranscript() const", typeof(bool));
		}
		/// <remarks>
		///  Checks whether or not the active catalog is found for the given language.
		/// <param> name="language" language to check
		///    </param></remarks>		<short>    Checks whether or not the active catalog is found for the given language.</short>
		public bool IsApplicationTranslatedInto(string language) {
			return (bool) interceptor.Invoke("isApplicationTranslatedInto$", "isApplicationTranslatedInto(const QString&)", typeof(bool), typeof(string), language);
		}
		/// <remarks>
		///  Copies the catalogs of this objct to an other KLocale object.
		///    </remarks>		<short>    Copies the catalogs of this objct to an other KLocale object.</short>
		public void CopyCatalogsTo(KLocale locale) {
			interceptor.Invoke("copyCatalogsTo#", "copyCatalogsTo(KLocale*)", typeof(void), typeof(KLocale), locale);
		}
		/// <remarks>
		///  Changes the current country. The current country will be left
		///  unchanged if failed. It will force a reload of the country specific
		///  configuration.
		/// <param> name="country" The ISO 3166 country code.
		/// </param></remarks>		<return> True on success.
		///    </return>
		/// 		<short>    Changes the current country.</short>
		public bool SetCountry(string country, KConfig config) {
			return (bool) interceptor.Invoke("setCountry$#", "setCountry(const QString&, KConfig*)", typeof(bool), typeof(string), country, typeof(KConfig), config);
		}
		/// <remarks>
		///  Changes the current language. The current language will be left
		///  unchanged if failed. It will force a reload of the country specific
		///  configuration as well.
		/// <param> name="language" the language code
		/// </param></remarks>		<return> true on success
		///    </return>
		/// 		<short>    Changes the current language.</short>
		public bool SetLanguage(string language, KConfig config) {
			return (bool) interceptor.Invoke("setLanguage$#", "setLanguage(const QString&, KConfig*)", typeof(bool), typeof(string), language, typeof(KConfig), config);
		}
		/// <remarks>
		///  Changes the list of preferred languages for the locale. The first valid
		///  language in the list will be used, or the default language (en_US)
		///  if none of the specified languages were available.
		/// <param> name="languages" the list of language codes
		/// </param></remarks>		<return> true if one of the specified languages were used
		///    </return>
		/// 		<short>    Changes the list of preferred languages for the locale.</short>
		public bool SetLanguage(List<string> languages) {
			return (bool) interceptor.Invoke("setLanguage?", "setLanguage(const QStringList&)", typeof(bool), typeof(List<string>), languages);
		}
		/// <remarks>
		///  Tries to find a path to the localized file for the given original path.
		///  This is intended mainly for non-text resources (images, sounds, etc.),
		///  whereas text resources should be handled in more specific ways.
		///  The possible localized paths are checked in turn by priority of set
		///  languages, in form of dirname/l10n/ll/basename, where dirname and
		///  basename are those of the original path, and ll is the language code.
		///  KDE core classes which resolve paths internally (e.g. KStandardDirs)
		///  will usually perform this lookup behind the scene.
		///  In general, you should pipe resource paths through this method only
		///  on explicit translators' request, or when a resource is an obvious
		///  candidate for localization (e.g. a splash screen or a custom icon
		///  with some text drawn on it).
		/// <param> name="filePath" path to the original file
		/// </param></remarks>		<return> path to the localized file if found, original path otherwise
		///    </return>
		/// 		<short>   </short>
		public string LocalizedFilePath(string filePath) {
			return (string) interceptor.Invoke("localizedFilePath$", "localizedFilePath(const QString&) const", typeof(string), typeof(string), filePath);
		}
		~KLocale() {
			interceptor.Invoke("~KLocale", "~KLocale()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KLocale", "~KLocale()", typeof(void));
		}
		/// <remarks>
		///  Parses locale string into distinct parts.
		///  The format of locale is language_COUNTRY@modifier.CHARSET
		/// <param> name="locale" the locale string to split
		/// </param><param> name="language" set to the language part of the locale
		/// </param><param> name="country" set to the country part of the locale
		/// </param><param> name="modifier" set to the modifer part of the locale
		/// </param><param> name="charset" set to the charset part of the locale
		///    </param></remarks>		<short>    Parses locale string into distinct parts.</short>
		public static void SplitLocale(string locale, StringBuilder language, StringBuilder country, StringBuilder modifier, StringBuilder charset) {
			staticInterceptor.Invoke("splitLocale$$$$$", "splitLocale(const QString&, QString&, QString&, QString&, QString&)", typeof(void), typeof(string), locale, typeof(StringBuilder), language, typeof(StringBuilder), country, typeof(StringBuilder), modifier, typeof(StringBuilder), charset);
		}
		/// <remarks>
		///  Use this as main catalog for all KLocales, if not the appname
		///  will be used. This function is best to be the very first instruction
		///  in your program's main function as it only has an effect before the
		///  first KLocale object is created.
		/// <param> name="catalog" Catalog to override all other main Catalogs.
		///    </param></remarks>		<short>    Use this as main catalog for  all  KLocales, if not the appname  will be used.</short>
		public static void SetMainCatalog(string catalog) {
			staticInterceptor.Invoke("setMainCatalog$", "setMainCatalog(const char*)", typeof(void), typeof(string), catalog);
		}
		/// <remarks>
		///  Returns the name of the internal language.
		/// </remarks>		<return> Name of the default language
		///    </return>
		/// 		<short>    Returns the name of the internal language.</short>
		public static string DefaultLanguage() {
			return (string) staticInterceptor.Invoke("defaultLanguage", "defaultLanguage()", typeof(string));
		}
		/// <remarks>
		///  Returns the name of the default country.
		/// </remarks>		<return> Name of the default country
		///    </return>
		/// 		<short>    Returns the name of the default country.</short>
		public static string DefaultCountry() {
			return (string) staticInterceptor.Invoke("defaultCountry", "defaultCountry()", typeof(string));
		}
	}
}
