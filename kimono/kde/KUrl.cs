//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;

	/// <remarks>
	///  Represents and parses a URL.
	///  A prototypical URL looks like:
	///  <pre>
	///    protocol://user:password\@hostname:port/path/to/file.ext#reference
	///  </pre>
	///  KUrl handles escaping of URLs. This means that the specification
	///  of a full URL will differ from the corresponding string that would specify a
	///  local file or directory in file-operations like fopen. This is because an URL
	///  doesn't allow certain characters and escapes them. (e.g. '#'."%23", space."%20")
	///  (In a URL the hash-character '#' is used to specify a "reference", i.e. the position
	///  within a document).
	///  The constructor KUrl(string) expects a string properly escaped,
	///  or at least non-ambiguous.
	///  If you have the absolute path you should use KUrl.FromPath(string).
	///  <pre>
	///      KUrl kurl = KUrl.FromPath("/bar/#foo#");
	///      string url = kurl.url();    // . "file:///bar/%23foo%23"
	///  </pre>
	///  If you have the URL of a local file or directory and need the absolute path,
	///  you would use path().
	///  <pre>
	///     KUrl url( "file:///bar/%23foo%23" );
	///     ...
	///     if ( url.isLocalFile() )
	///        string path = url.path();       // . "/bar/#foo#"
	///  </pre>
	///  This must also be considered when you have separated directory and file
	///  strings and need to put them together.
	///  While you can simply concatenate normal path strings, you must take care if
	///  the directory-part is already an escaped URL.
	///  (This might be needed if the user specifies a relative path, and your
	///  program supplies the rest from elsewhere.)
	///  Wrong:
	///  <pre>
	///     string dirUrl = "file:///bar/";
	///     string fileName = "#foo#";
	///     string invalidURL = dirUrl + fileName;   // . "file:///bar/#foo#" won't behave like you would expect.
	///  </pre>
	///  Instead you should use addPath():
	///  Right:
	///  <pre>
	///     KUrl url( "file:///bar/" );
	///     string fileName = "#foo#";
	///     url.addPath( fileName );
	///     string validURL = url.url();    // . "file:///bar/%23foo%23"
	///  </pre>
	///  Also consider that some URLs contain the password, but this shouldn't be
	///  visible. Your program should use prettyUrl() every time it displays a
	///  URL, whether in the GUI or in debug output or...
	///  <pre>
	///     KUrl url( "ftp://name:password@ftp.faraway.org/bar/%23foo%23");
	///     string visibleURL = url.prettyUrl(); // . "ftp://name@ftp.faraway.org/bar/%23foo%23"
	///  </pre>
	///  Note that prettyUrl() doesn't change the character escapes (like "%23").
	///  Otherwise the URL would be invalid and the user wouldn't be able to use it in another
	///  context.
	///  </remarks>		<short>    Represents and parses a URL.</short>

	[SmokeClass("KUrl")]
	public class KUrl : QUrl, IDisposable {
 		protected KUrl(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KUrl), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KUrl() {
			staticInterceptor = new SmokeInvocation(typeof(KUrl), null);
		}
		public enum MimeDataFlags {
			DefaultMimeDataFlags = 0,
			NoTextExport = 1,
		}
		/// <remarks>
		///  Options to be used in adjustPath
		///    </remarks>		<short>    Options to be used in adjustPath    </short>
		public enum AdjustPathOption {
			RemoveTrailingSlash = 0,
			LeaveTrailingSlash = 1,
			AddTrailingSlash = 2,
		}
		/// <remarks>
		///  Options to be used in cleanPath
		///    </remarks>		<short>    Options to be used in cleanPath    </short>
		public enum CleanPathOption {
			SimplifyDirSeparators = 0x00,
			KeepDirSeparators = 0x01,
		}
		/// <remarks>
		///  Option to be used in encodedPathAndQuery
		/// </remarks>		<short>    Option to be used in encodedPathAndQuery </short>
		public enum EncodedPathAndQueryOption {
			PermitEmptyPath = 0x00,
			AvoidEmptyPath = 0x01,
		}
		/// <remarks>
		///  Options for queryItems. Currently, only one option is
		///  defined:
		/// <param> name="CaseInsensitiveKeys" normalize query keys to lowercase.
		/// </param></remarks>		<short>    Options for queryItems.</short>
		public enum QueryItemsOption {
			CaseInsensitiveKeys = 1,
		}
		/// <remarks>
		///  option to be used in fileName and directory
		///    </remarks>		<short>    option to be used in fileName and directory    </short>
		public enum DirectoryOption {
			ObeyTrailingSlash = 0x02,
			AppendTrailingSlash = 0x04,
			IgnoreTrailingSlash = 0x01,
		}
		/// <remarks>
		///  flags to be used in url compartators function like equal, or urlcmp
		/// </remarks>		<short>    flags to be used in url compartators function like equal, or urlcmp </short>
		public enum EqualsOption {
			CompareWithoutTrailingSlash = 0x01,
			CompareWithoutFragment = 0x02,
		}
		// QString encodedPathAndQuery(KUrl::AdjustPathOption arg1,const EncodedPathAndQueryOptions& arg2); >>>> NOT CONVERTED
		// QMap<QString, QString> queryItems(const QueryItemsOptions& arg1); >>>> NOT CONVERTED
		// QString fileName(const DirectoryOptions& arg1); >>>> NOT CONVERTED
		// QString directory(const DirectoryOptions& arg1); >>>> NOT CONVERTED
		//  operator QVariant(); >>>> NOT CONVERTED
		// bool equals(const KUrl& arg1,const EqualsOptions& arg2); >>>> NOT CONVERTED
		// void populateMimeData(QMimeData* arg1,const KUrl::MetaDataMap& arg2,KUrl::MimeDataFlags arg3); >>>> NOT CONVERTED
		// void populateMimeData(QMimeData* arg1,const KUrl::MetaDataMap& arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  Constructs an empty URL.
		///    </remarks>		<short>    Constructs an empty URL.</short>
		public KUrl() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl", "KUrl()", typeof(void));
		}
		/// <remarks>
		///  Usual constructor, to construct from a string.
		/// <param> name="urlOrPath" An encoded URL or a path.
		///    </param></remarks>		<short>    Usual constructor, to construct from a string.</short>
		public KUrl(string urlOrPath) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl$", "KUrl(const QString&)", typeof(void), typeof(string), urlOrPath);
		}
		/// <remarks>
		///  Constructor taking a QByteArray <code>urlOrPath</code>, which is an _encoded_ representation
		///  of the URL, exactly like the usual constructor. This is useful when
		///  then URL, in its encoded form, is strictly ascii.
		/// <param> name="urlOrPath" An encoded URL, or a path.
		///    </param></remarks>		<short>    Constructor taking a QByteArray <code>urlOrPath</code>, which is an _encoded_ representation  of the URL, exactly like the usual constructor.</short>
		public KUrl(QByteArray urlOrPath) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl#", "KUrl(const QByteArray&)", typeof(void), typeof(QByteArray), urlOrPath);
		}
		/// <remarks>
		///  Copy constructor.
		/// <param> name="u" the KUrl to copy
		///    </param></remarks>		<short>    Copy constructor.</short>
		public KUrl(KUrl u) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl#", "KUrl(const KUrl&)", typeof(void), typeof(KUrl), u);
		}
		/// <remarks>
		///  Converts from a QUrl.
		/// <param> name="u" the QUrl
		///    </param></remarks>		<short>    Converts from a QUrl.</short>
		public KUrl(QUrl u) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl#", "KUrl(const QUrl&)", typeof(void), typeof(QUrl), u);
		}
		/// <remarks>
		///  Constructor allowing relative URLs.
		/// <param> name="_baseurl" The base url.
		/// </param><param> name="_rel_url" A relative or absolute URL.
		///  If this is an absolute URL then <code>_baseurl</code> will be ignored.
		///  If this is a relative URL it will be combined with <code>_baseurl.</code>
		///  Note that _rel_url should be encoded too, in any case.
		///  So do NOT pass a path here (use setPath or addPath instead).
		///    </param></remarks>		<short>    Constructor allowing relative URLs.</short>
		public KUrl(KUrl _baseurl, string _rel_url) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUrl#$", "KUrl(const KUrl&, const QString&)", typeof(void), typeof(KUrl), _baseurl, typeof(string), _rel_url);
		}
		/// <remarks>
		///  Returns the protocol for the URL (i.e., file, http, etc.), lowercased.
		/// </remarks>		<short>    Returns the protocol for the URL (i.</short>
		/// 		<see> QUrl.Scheme</see>
		public string Protocol() {
			return (string) interceptor.Invoke("protocol", "protocol() const", typeof(string));
		}
		/// <remarks>
		///  Sets the protocol for the URL (i.e., file, http, etc.)
		/// <param> name="proto" the new protocol of the URL (without colon)
		///    </param></remarks>		<short>    Sets the protocol for the URL (i.</short>
		public void SetProtocol(string proto) {
			interceptor.Invoke("setProtocol$", "setProtocol(const QString&)", typeof(void), typeof(string), proto);
		}
		/// <remarks>
		///  Returns the decoded user name (login, user id, ...) included in the URL.
		/// </remarks>		<return> the user name or string() if there is no user name
		///    </return>
		/// 		<short>    Returns the decoded user name (login, user id, .</short>
		public string User() {
			return (string) interceptor.Invoke("user", "user() const", typeof(string));
		}
		/// <remarks>
		///  Sets the user name (login, user id, ...) included in the URL.
		///  Special characters in the user name will appear encoded in the URL.
		/// <param> name="user" the name of the user or string() to remove the user
		///    </param></remarks>		<short>    Sets the user name (login, user id, .</short>
		public void SetUser(string user) {
			interceptor.Invoke("setUser$", "setUser(const QString&)", typeof(void), typeof(string), user);
		}
		/// <remarks>
		///  Test to see if this URL has a user name included in it.
		/// </remarks>		<return> true if the URL has an non-empty user name
		///    </return>
		/// 		<short>    Test to see if this URL has a user name included in it.</short>
		public bool HasUser() {
			return (bool) interceptor.Invoke("hasUser", "hasUser() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the decoded password (corresponding to user()) included in the URL.
		/// </remarks>		<return> the password or string() if it does not exist
		/// </return>
		/// 		<short>    Returns the decoded password (corresponding to user()) included in the URL.</short>
		public string Pass() {
			return (string) interceptor.Invoke("pass", "pass() const", typeof(string));
		}
		/// <remarks>
		///  Sets the password (corresponding to user()) included in the URL.
		///  Special characters in the password will appear encoded in the URL.
		///  Note that a password can only appear in a URL string if you also set
		///  a user.
		/// <param> name="pass" the password to set or string() to remove the password
		/// </param></remarks>		<short>    Sets the password (corresponding to user()) included in the URL.</short>
		/// 		<see> setUser</see>
		/// 		<see> hasUser</see>
		public void SetPass(string pass) {
			interceptor.Invoke("setPass$", "setPass(const QString&)", typeof(void), typeof(string), pass);
		}
		/// <remarks>
		///  Test to see if this URL has a password included in it.
		/// </remarks>		<return> true if there is a non-empty password set
		/// </return>
		/// 		<short>    Test to see if this URL has a password included in it.</short>
		public bool HasPass() {
			return (bool) interceptor.Invoke("hasPass", "hasPass() const", typeof(bool));
		}
		/// <remarks>
		///  Test to see if this URL has a hostname included in it.
		/// </remarks>		<return> true if the URL has a host
		/// </return>
		/// 		<short>    Test to see if this URL has a hostname included in it.</short>
		public bool HasHost() {
			return (bool) interceptor.Invoke("hasHost", "hasHost() const", typeof(bool));
		}
		/// <remarks>
		/// <param> name="trailing" use to add or remove a trailing slash to/from the path. see adjustPath
		/// </param></remarks>		<return> The current decoded path. This does not include the query. Can
		///          be string() if no path is set.
		///    </return>
		/// 		<short>   </short>
		public string Path(KUrl.AdjustPathOption trailing) {
			return (string) interceptor.Invoke("path$", "path(KUrl::AdjustPathOption) const", typeof(string), typeof(KUrl.AdjustPathOption), trailing);
		}
		public new string Path() {
			return (string) interceptor.Invoke("path", "path() const", typeof(string));
		}
		/// <remarks>
		/// <param> name="trailing" use to add or remove a trailing slash to/from the local path. see adjustPath
		/// </param></remarks>		<return> The current local path. Can
		///    be string() if no path is set.
		///    </return>
		/// 		<short>   </short>
		public string ToLocalFile(KUrl.AdjustPathOption trailing) {
			return (string) interceptor.Invoke("toLocalFile$", "toLocalFile(KUrl::AdjustPathOption) const", typeof(string), typeof(KUrl.AdjustPathOption), trailing);
		}
		public new string ToLocalFile() {
			return (string) interceptor.Invoke("toLocalFile", "toLocalFile() const", typeof(string));
		}
		public new void SetPath(string path) {
			interceptor.Invoke("setPath$", "setPath(const QString&)", typeof(void), typeof(string), path);
		}
		/// <remarks>
		///  Test to see if this URL has a path is included in it.
		/// </remarks>		<return> true if there is a path
		/// </return>
		/// 		<short>    Test to see if this URL has a path is included in it.</short>
		public bool HasPath() {
			return (bool) interceptor.Invoke("hasPath", "hasPath() const", typeof(bool));
		}
		/// <remarks>
		///  Resolves "." and ".." components in path.
		///  Some servers seem not to like the removal of extra '/'
		///  even though it is against the specification in RFC 2396.
		/// <param> name="options" use KeepDirSeparators if you don't want to remove consecutive
		///                 occurrences of directory separator
		///    </param></remarks>		<short>    Resolves ".</short>
		public void CleanPath(KUrl.CleanPathOption options) {
			interceptor.Invoke("cleanPath$", "cleanPath(const KUrl::CleanPathOption&)", typeof(void), typeof(KUrl.CleanPathOption), options);
		}
		public void CleanPath() {
			interceptor.Invoke("cleanPath", "cleanPath()", typeof(void));
		}
		/// <remarks>
		///  Add or remove a trailing slash to/from the path.
		///  If the URL has no path, then no '/' is added
		///  anyway. And on the other side: If the path is "/", then this
		///  character won't be stripped. Reason: "ftp://weis\@host" means something
		///  completely different than "ftp://weis\@host/". So adding or stripping
		///  the '/' would really alter the URL, while "ftp://host/path" and
		///  "ftp://host/path/" mean the same directory.
		/// <param> name="trailing" RemoveTrailingSlash strips any trailing '/' and
		///                   AddTrailingSlash adds  a trailing '/' if there is none yet
		///    </param></remarks>		<short>    Add or remove a trailing slash to/from the path.</short>
		public void AdjustPath(KUrl.AdjustPathOption trailing) {
			interceptor.Invoke("adjustPath$", "adjustPath(KUrl::AdjustPathOption)", typeof(void), typeof(KUrl.AdjustPathOption), trailing);
		}
		/// <remarks>
		///  This is useful for HTTP. It looks first for '?' and decodes then.
		///  The encoded path is the concatenation of the current path and the query.
		/// <param> name="_txt" the new path and query.
		///    </param></remarks>		<short>    This is useful for HTTP.</short>
		public void SetEncodedPathAndQuery(string _txt) {
			interceptor.Invoke("setEncodedPathAndQuery$", "setEncodedPathAndQuery(const QString&)", typeof(void), typeof(string), _txt);
		}
		/// <remarks>
		///  Returns the encoded path and the query.
		/// <param> name="trailing" add or remove a trailing '/', see adjustPath
		/// </param><param> name="options" a set of flags from EncodedPathAndQueryOption
		/// </param>   </remarks>		<return> The concatenation of the encoded path , '?' and the encoded query.
		/// </return>
		/// 		<short>    Returns the encoded path and the query.</short>
		public string EncodedPathAndQuery(KUrl.AdjustPathOption trailing) {
			return (string) interceptor.Invoke("encodedPathAndQuery$", "encodedPathAndQuery(KUrl::AdjustPathOption) const", typeof(string), typeof(KUrl.AdjustPathOption), trailing);
		}
		public string EncodedPathAndQuery() {
			return (string) interceptor.Invoke("encodedPathAndQuery", "encodedPathAndQuery() const", typeof(string));
		}
		/// <remarks>
		/// <param> name="query" This is considered to be encoded. This has a good reason:
		///  The query may contain the 0 character.
		/// </param> The query should start with a '?'. If it doesn't '?' is prepended.
		///    </remarks>		<short>   </short>
		public void SetQuery(string query) {
			interceptor.Invoke("setQuery$", "setQuery(const QString&)", typeof(void), typeof(string), query);
		}
		/// <remarks>
		///  Returns the query of the URL.
		///  The query may contain the 0 character.
		///  If a query is present it always starts with a '?'.
		///  A single '?' means an empty query.
		///  An empty string means no query.
		/// </remarks>		<return> The encoded query, or string() if there is none.
		///    </return>
		/// 		<short>    Returns the query of the URL.</short>
		public string Query() {
			return (string) interceptor.Invoke("query", "query() const", typeof(string));
		}
		/// <remarks>
		///  The reference is <b>never</b> decoded automatically.
		/// </remarks>		<return> the undecoded reference, or string() if there is none
		///    </return>
		/// 		<short>    The reference is @em never decoded automatically.</short>
		public string Ref() {
			return (string) interceptor.Invoke("ref", "ref() const", typeof(string));
		}
		/// <remarks>
		///  Sets the reference part (everything after '#').
		///  If you have an encoded fragment already (as a QByteArray), you can call setFragment directly.
		/// <param> name="fragment" the encoded reference (or string() to remove it).
		///    </param></remarks>		<short>    Sets the reference part (everything after '#').</short>
		public void SetRef(string fragment) {
			interceptor.Invoke("setRef$", "setRef(const QString&)", typeof(void), typeof(string), fragment);
		}
		/// <remarks>
		///  Checks whether the URL has a reference part.
		/// </remarks>		<return> true if the URL has a reference part. In a URL like
		///          http://www.kde.org/kdebase.tar#tar:/README it would
		///          return true, too.
		///    </return>
		/// 		<short>    Checks whether the URL has a reference part.</short>
		public bool HasRef() {
			return (bool) interceptor.Invoke("hasRef", "hasRef() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the HTML reference (the part of the URL after "#").
		/// </remarks>		<return> The HTML-style reference.
		/// </return>
		/// 		<short>    Returns the HTML reference (the part of the URL after "#").</short>
		/// 		<see> split</see>
		/// 		<see> hasSubUrl</see>
		/// 		<see> encodedHtmlRef</see>
		public string HtmlRef() {
			return (string) interceptor.Invoke("htmlRef", "htmlRef() const", typeof(string));
		}
		/// <remarks>
		///  Returns the HTML reference (the part of the URL after "#") in
		///  encoded form.
		/// </remarks>		<return> The HTML-style reference in its original form.
		///    </return>
		/// 		<short>    Returns the HTML reference (the part of the URL after "#") in  encoded form.</short>
		public string EncodedHtmlRef() {
			return (string) interceptor.Invoke("encodedHtmlRef", "encodedHtmlRef() const", typeof(string));
		}
		/// <remarks>
		///  Sets the HTML-style reference.
		/// <param> name="_ref" The new reference. This is considered to be <b>not</b> encoded in
		///          contrast to setRef(). Use string() to remove it.
		/// </param></remarks>		<short>    Sets the HTML-style reference.</short>
		/// 		<see> htmlRef</see>
		public void SetHTMLRef(string _ref) {
			interceptor.Invoke("setHTMLRef$", "setHTMLRef(const QString&)", typeof(void), typeof(string), _ref);
		}
		/// <remarks>
		///  Checks whether there is a HTML reference.
		/// </remarks>		<return> true if the URL has an HTML-style reference.
		/// </return>
		/// 		<short>    Checks whether there is a HTML reference.</short>
		/// 		<see> htmlRef</see>
		public bool HasHTMLRef() {
			return (bool) interceptor.Invoke("hasHTMLRef", "hasHTMLRef() const", typeof(bool));
		}
		/// <remarks>
		///  Checks whether the file is local.
		/// </remarks>		<return> true if the file is a plain local file and has no filter protocols
		///          attached to it.
		///    </return>
		/// 		<short>    Checks whether the file is local.</short>
		public bool IsLocalFile() {
			return (bool) interceptor.Invoke("isLocalFile", "isLocalFile() const", typeof(bool));
		}
		/// <remarks>
		///  Adds encoding information to url by adding a "charset" parameter. If there
		///  is already a charset parameter, it will be replaced.
		/// <param> name="encoding" the encoding to add or string() to remove the
		///                  encoding.
		///    </param></remarks>		<short>    Adds encoding information to url by adding a "charset" parameter.</short>
		public void SetFileEncoding(string encoding) {
			interceptor.Invoke("setFileEncoding$", "setFileEncoding(const QString&)", typeof(void), typeof(string), encoding);
		}
		/// <remarks>
		///  Returns encoding information from url, the content of the "charset"
		///  parameter.
		/// </remarks>		<return> An encoding suitable for QTextCodec.CodecForName()
		///          or string() if not encoding was specified.
		///    </return>
		/// 		<short>    Returns encoding information from url, the content of the "charset"  parameter.</short>
		public string FileEncoding() {
			return (string) interceptor.Invoke("fileEncoding", "fileEncoding() const", typeof(string));
		}
		/// <remarks>
		///  Checks whether the URL has any sub URLs. See split()
		///  for examples for sub URLs.
		/// </remarks>		<return> true if the file has at least one sub URL.
		/// </return>
		/// 		<short>    Checks whether the URL has any sub URLs.</short>
		/// 		<see> split</see>
		public bool HasSubUrl() {
			return (bool) interceptor.Invoke("hasSubUrl", "hasSubUrl() const", typeof(bool));
		}
		/// <remarks>
		///  Adds to the current path.
		///  Assumes that the current path is a directory. <code>_txt</code> is appended to the
		///  current path. The function adds '/' if needed while concatenating.
		///  This means it does not matter whether the current path has a trailing
		///  '/' or not. If there is none, it becomes appended. If <code>_txt</code>
		///  has a leading '/' then this one is stripped.
		/// <param> name="txt" The text to add. It is considered to be decoded.
		///    </param></remarks>		<short>    Adds to the current path.</short>
		public void AddPath(string txt) {
			interceptor.Invoke("addPath$", "addPath(const QString&)", typeof(void), typeof(string), txt);
		}
		/// <remarks>
		///  Returns the list of query items as a map mapping keys to values.
		///  This does the same as QUrl.QueryItems(), except that it
		///  decodes "+" into " " in the value, supports CaseInsensitiveKeys,
		///  and returns a different data type.
		/// <param> name="options" any of QueryItemsOption <em>or</em>ed together.
		/// </param></remarks>		<return> the map of query items or the empty map if the url has no
		///  query items.
		///    </return>
		/// 		<short>    Returns the list of query items as a map mapping keys to values.</short>
		/// <remarks>
		///  Returns the value of a certain query item.
		///  This does the same as QUrl.QueryItemValue(), except that it
		///  decodes "+" into " " in the value.
		/// <param> name="item" Item whose value we want
		/// </param></remarks>		<return> the value of the given query item name or string() if the
		///  specified item does not exist.
		///    </return>
		/// 		<short>    Returns the value of a certain query item.</short>
		public string QueryItem(string item) {
			return (string) interceptor.Invoke("queryItem$", "queryItem(const QString&) const", typeof(string), typeof(string), item);
		}
		/// <remarks>
		///  Add an additional query item.
		///  To replace an existing query item, the item should first be
		///  removed with removeQueryItem()
		/// <param> name="_item" Name of item to add
		/// </param><param> name="_value" Value of item to add
		///    </param></remarks>		<short>    Add an additional query item.</short>
		public new void AddQueryItem(string _item, string _value) {
			interceptor.Invoke("addQueryItem$$", "addQueryItem(const QString&, const QString&)", typeof(void), typeof(string), _item, typeof(string), _value);
		}
		/// <remarks>
		///  Sets the filename of the path.
		///  In comparison to addPath() this function does not assume that the current
		///  path is a directory. This is only assumed if the current path ends with '/'.
		///  Any reference is reset.
		/// <param> name="_txt" The filename to be set. It is considered to be decoded. If the
		///              current path ends with '/' then <code>_txt</code> int just appended, otherwise
		///              all text behind the last '/' in the current path is erased and
		///              <code>_txt</code> is appended then. It does not matter whether <code>_txt</code> starts
		///              with '/' or not.
		///    </param></remarks>		<short>    Sets the filename of the path.</short>
		public void SetFileName(string _txt) {
			interceptor.Invoke("setFileName$", "setFileName(const QString&)", typeof(void), typeof(string), _txt);
		}
		/// <remarks>
		///  Returns the filename of the path.
		/// <param> name="options" a set of DirectoryOption flags.  (StripTrailingSlashFromResult has no effect)
		/// </param></remarks>		<return> The filename of the current path. The returned string is decoded. Null
		///          if there is no file (and thus no path).
		///    </return>
		/// 		<short>    Returns the filename of the path.</short>
		/// <remarks>
		///  Returns the directory of the path.
		/// <param> name="options" a set of DirectoryOption flags
		/// </param></remarks>		<return> The directory part of the current path. Everything between the last and the second last '/'
		///          is returned. For example <tt>file:///hallo/torben/</tt> would return "/hallo/torben/" while
		///          <tt>file:///hallo/torben</tt> would return "hallo/". The returned string is decoded.
		///          string() is returned when there is no path.
		///    </return>
		/// 		<short>    Returns the directory of the path.</short>
		/// <remarks>
		///  Set the directory to <code>dir</code>, leaving the filename empty.
		///    </remarks>		<short>    Set the directory to <code>dir</code>, leaving the filename empty.</short>
		public void SetDirectory(string dir) {
			interceptor.Invoke("setDirectory$", "setDirectory(const QString&)", typeof(void), typeof(string), dir);
		}
		/// <remarks>
		///  Changes the directory by descending into the given directory.
		///  It is assumed the current URL represents a directory.
		///  If <code>dir</code> starts with a "/" the
		///  current URL will be "protocol://host/dir" otherwise <code>_dir</code> will
		///  be appended to the path. <code>_dir</code> can be ".."
		///  This function won't strip protocols. That means that when you are in
		///  file:///dir/dir2/my.tgz#tar:/ and you do cd("..") you will
		///  still be in file:///dir/dir2/my.tgz#tar:/
		/// <param> name="_dir" the directory to change to
		/// </param></remarks>		<return> true if successful
		///    </return>
		/// 		<short>    Changes the directory by descending into the given directory.</short>
		public bool Cd(string _dir) {
			return (bool) interceptor.Invoke("cd$", "cd(const QString&)", typeof(bool), typeof(string), _dir);
		}
		/// <remarks>
		///  Returns the URL as string, with all escape sequences intact,
		///  encoded in a given charset.
		///  This is used in particular for encoding URLs in UTF-8 before using them
		///  in a drag and drop operation.
		///  Please note that the string returned by url() will include
		///  the password of the URL. If you want to show the URL to the
		///  user, use prettyUrl().
		/// <param> name="trailing" use to add or remove a trailing slash to/from the path. See adjustPath
		/// </param></remarks>		<return> The complete URL, with all escape sequences intact, encoded
		///  in a given charset.
		/// </return>
		/// 		<short>    Returns the URL as string, with all escape sequences intact,  encoded in a given charset.</short>
		/// 		<see> prettyUrl</see>
		public string Url(KUrl.AdjustPathOption trailing) {
			return (string) interceptor.Invoke("url$", "url(KUrl::AdjustPathOption) const", typeof(string), typeof(KUrl.AdjustPathOption), trailing);
		}
		public string Url() {
			return (string) interceptor.Invoke("url", "url() const", typeof(string));
		}
		/// <remarks>
		///  Returns the URL as string in human-friendly format.
		///  Example:
		///  <pre>
		///  http://localhost:8080/test.cgi?test=hello world&name=fred
		///  </pre>
		/// <param> name="trailing" use to add or remove a trailing slash to/from the path. see adjustPath.
		/// </param></remarks>		<return> A human readable URL, with no non-necessary encodings/escaped
		///  characters. Password will not be shown.
		/// </return>
		/// 		<short>    Returns the URL as string in human-friendly format.</short>
		/// 		<see> url</see>
		public string PrettyUrl(KUrl.AdjustPathOption trailing) {
			return (string) interceptor.Invoke("prettyUrl$", "prettyUrl(KUrl::AdjustPathOption) const", typeof(string), typeof(KUrl.AdjustPathOption), trailing);
		}
		public string PrettyUrl() {
			return (string) interceptor.Invoke("prettyUrl", "prettyUrl() const", typeof(string));
		}
		/// <remarks>
		///  Return the URL as a string, which will be either the URL (as prettyUrl
		///  would return) or, when the URL is a local file without query or ref,
		///  the path.
		///  Use this method, to display URLs to the user.
		///  You can give the result of pathOrUrl back to the KUrl constructor, it accepts
		///  both paths and urls.
		/// </remarks>		<return> the new KUrl
		///    </return>
		/// 		<short>    Return the URL as a string, which will be either the URL (as prettyUrl  would return) or, when the URL is a local file without query or ref,  the path.</short>
		public string PathOrUrl() {
			return (string) interceptor.Invoke("pathOrUrl", "pathOrUrl() const", typeof(string));
		}
		/// <remarks>
		///  Returns the URL as a string, using the standard conventions for mime data
		///  (drag-n-drop or copy-n-paste).
		///  Internally used by KUrl.List.FromMimeData, which is probably what you want to use instead.
		///    </remarks>		<short>    Returns the URL as a string, using the standard conventions for mime data  (drag-n-drop or copy-n-paste).</short>
		public string ToMimeDataString() {
			return (string) interceptor.Invoke("toMimeDataString", "toMimeDataString() const", typeof(string));
		}
		/// <remarks>
		///  This function is useful to implement the "Up" button in a file manager for example.
		///  cd() never strips a sub-protocol. That means that if you are in
		///  file:///home/x.tgz#gzip:/#tar:/ and hit the up button you expect to see
		///  file:///home. The algorithm tries to go up on the right-most URL. If that is not
		///  possible it strips the right most URL. It continues stripping URLs.
		/// </remarks>		<return> a URL that is a level higher
		///    </return>
		/// 		<short>    This function is useful to implement the "Up" button in a file manager for example.</short>
		public KUrl UpUrl() {
			return (KUrl) interceptor.Invoke("upUrl", "upUrl() const", typeof(KUrl));
		}
		public override bool Equals(object o) {
			if (!(o is KUrl)) { return false; }
			return this == (KUrl) o;
		}
		public override int GetHashCode() {
			return interceptor.GetHashCode();
		}
		/// <remarks>
		///  Converts this KUrl to a QVariant, this allows to use KUrl
		///  in QVariant() constructor
		///    </remarks>		<short>    Converts this KUrl to a QVariant, this allows to use KUrl  in QVariant() constructor    </short>
		/// <remarks>
		///  Compares this url with <code>u.</code>
		/// <param> name="u" the URL to compare this one with.
		/// </param><param> name="options" a set of EqualsOption flags
		/// </param></remarks>		<return> true if both urls are the same
		/// </return>
		/// 		<short>    Compares this url with <code>u.</code></short>
		/// 		<see> operator==.</see>
		/// 		<see> This</see>
		/// 		<see> function</see>
		/// 		<see> should</see>
		/// 		<see> be</see>
		/// 		<see> used</see>
		/// 		<see> if</see>
		/// 		<see> you</see>
		/// 		<see> want</see>
		/// 		<see> to</see>
		/// 		<see> ignore</see>
		/// 		<see> trailing</see>
		/// 		<see> characters.</see>
		public bool Equals(KUrl u) {
			return (bool) interceptor.Invoke("equals#", "equals(const KUrl&) const", typeof(bool), typeof(KUrl), u);
		}
		/// <remarks>
		///  Checks whether the given URL is parent of this URL.
		///  For instance, ftp://host/dir/ is a parent of ftp://host/dir/subdir/subsubdir/.
		///    </remarks>		<return> true if this url is a parent of <code>u</code> (or the same URL as <code>u</code>)
		/// </return>
		/// 		<short>    Checks whether the given URL is parent of this URL.</short>
		public bool IsParentOf(KUrl u) {
			return (bool) interceptor.Invoke("isParentOf#", "isParentOf(const KUrl&) const", typeof(bool), typeof(KUrl), u);
		}
		/// <remarks>
		///  Adds URL data into the given QMimeData.
		///  By default, populateMimeData also exports the URL as plain text, for e.g. dropping
		///  onto a text editor.
		///  But in some cases this might not be wanted, e.g. if adding other mime data
		///  which provides better plain text data.
		///  WARNING: do not call this method multiple times, use KUrl.List.PopulateMimeData instead.
		/// <param> name="mimeData" the QMimeData instance used to drag or copy this URL
		/// </param><param> name="metaData" KIO metadata shipped in the mime data, which is used for instance to
		///  set a correct HTTP referrer (some websites require it for downloading e.g. an image)
		/// </param><param> name="flags" set NoTextExport to prevent setting plain/text data into <code>mimeData</code>
		///  In such a case, setExportAsText( false ) should be called.
		///    </param></remarks>		<short>    Adds URL data into the given QMimeData.</short>
		public void PopulateMimeData(QMimeData mimeData) {
			interceptor.Invoke("populateMimeData#", "populateMimeData(QMimeData*) const", typeof(void), typeof(QMimeData), mimeData);
		}
		~KUrl() {
			interceptor.Invoke("~KUrl", "~KUrl()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KUrl", "~KUrl()", typeof(void));
		}
		public static bool operator==(KUrl lhs, KUrl _u) {
			return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KUrl&) const", typeof(bool), typeof(KUrl), lhs, typeof(KUrl), _u);
		}
		public static bool operator!=(KUrl lhs, KUrl _u) {
			return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KUrl&) const", typeof(bool), typeof(KUrl), lhs, typeof(KUrl), _u);
		}
		public static bool operator==(KUrl lhs, string _u) {
			return (bool) staticInterceptor.Invoke("operator==$", "operator==(const QString&) const", typeof(bool), typeof(KUrl), lhs, typeof(string), _u);
		}
		public static bool operator!=(KUrl lhs, string _u) {
			return !(bool) staticInterceptor.Invoke("operator==$", "operator==(const QString&) const", typeof(bool), typeof(KUrl), lhs, typeof(string), _u);
		}
		/// <remarks>
		///  Splits nested URLs like file:///home/weis/kde.tgz#gzip:/#tar:/kdebase
		///  A URL like http://www.kde.org#tar:/kde/README.hml#ref1 will be split in
		///  http://www.kde.org and tar:/kde/README.html#ref1.
		///  That means in turn that "#ref1" is an HTML-style reference and not a new sub URL.
		///  Since HTML-style references mark
		///  a certain position in a document this reference is appended to every URL.
		///  The idea behind this is that browsers, for example, only look at the first URL while
		///  the rest is not of interest to them.
		/// <param> name="_url" The URL that has to be split.
		/// </param></remarks>		<return> An empty list on error or the list of split URLs.
		/// </return>
		/// 		<short>    Splits nested URLs like file:///home/weis/kde.</short>
		/// 		<see> hasSubUrl</see>
		public static List<KUrl> Split(string _url) {
			return (List<KUrl>) staticInterceptor.Invoke("split$", "split(const QString&)", typeof(List<KUrl>), typeof(string), _url);
		}
		/// <remarks>
		///  Splits nested URLs like file:///home/weis/kde.tgz#gzip:/#tar:/kdebase
		///  A URL like http://www.kde.org#tar:/kde/README.hml#ref1 will be split in
		///  http://www.kde.org and tar:/kde/README.html#ref1.
		///  That means in turn that "#ref1" is an HTML-style reference and not a new sub URL.
		///  Since HTML-style references mark
		///  a certain position in a document this reference is appended to every URL.
		///  The idea behind this is that browsers, for example, only look at the first URL while
		///  the rest is not of interest to them.
		/// <param> name="_url" The URL that has to be split.
		/// </param></remarks>		<return> An empty list on error or the list of split URLs.
		/// </return>
		/// 		<short>    Splits nested URLs like file:///home/weis/kde.</short>
		/// 		<see> hasSubUrl</see>
		public static List<KUrl> Split(KUrl _url) {
			return (List<KUrl>) staticInterceptor.Invoke("split#", "split(const KUrl&)", typeof(List<KUrl>), typeof(KUrl), _url);
		}
		/// <remarks>
		///  Reverses split(). Only the first URL may have a reference. This reference
		///  is considered to be HTML-like and is appended at the end of the resulting
		///  joined URL.
		/// <param> name="_list" the list to join
		/// </param></remarks>		<return> the joined URL
		///    </return>
		/// 		<short>    Reverses split().</short>
		public static KUrl Join(List<KUrl> _list) {
			return (KUrl) staticInterceptor.Invoke("join?", "join(const KUrl::List&)", typeof(KUrl), typeof(List<KUrl>), _list);
		}
		/// <remarks>
		///  Creates a KUrl object from a string representing an absolute path.
		///  KUrl url( somePath ) does the same, but this method is more explicit
		///  and avoids the path-or-url detection in the KUrl constructor.
		/// <param> name="text" the path
		/// </param></remarks>		<return> the new KUrl
		///    </return>
		/// 		<short>    Creates a KUrl object from a string representing an absolute path.</short>
		public static KUrl FromPath(string text) {
			return (KUrl) staticInterceptor.Invoke("fromPath$", "fromPath(const QString&)", typeof(KUrl), typeof(string), text);
		}
		/// <remarks>
		///  Creates a KUrl from a string, using the standard conventions for mime data
		///  (drag-n-drop or copy-n-paste).
		///  Internally used by KUrl.List.FromMimeData, which is probably what you want to use instead.
		///    </remarks>		<short>    Creates a KUrl from a string, using the standard conventions for mime data  (drag-n-drop or copy-n-paste).</short>
		public static KUrl FromMimeDataByteArray(QByteArray str) {
			return (KUrl) staticInterceptor.Invoke("fromMimeDataByteArray#", "fromMimeDataByteArray(const QByteArray&)", typeof(KUrl), typeof(QByteArray), str);
		}
		/// <remarks>
		///  Convenience function.
		///  Returns whether '_url' is likely to be a "relative" URL instead of
		///  an "absolute" URL.
		/// <param> name="_url" URL to examine
		/// </param></remarks>		<return> true when the URL is likely to be "relative", false otherwise.
		///    </return>
		/// 		<short>    Convenience function.</short>
		public static bool IsRelativeUrl(string _url) {
			return (bool) staticInterceptor.Invoke("isRelativeUrl$", "isRelativeUrl(const QString&)", typeof(bool), typeof(string), _url);
		}
		/// <remarks>
		///  Convenience function
		///  Returns a "relative URL" based on <code>base_url</code> that points to <code>url.</code>
		///  If no "relative URL" can be created, e.g. because the protocol
		///  and/or hostname differ between <code>base_url</code> and <code>url</code> an absolute
		///  URL is returned.
		///  Note that if <code>base_url</code> represents a directory, it should contain
		///  a trailing slash.
		/// <param> name="base_url" the URL to derive from
		/// </param><param> name="url" new URL
		/// </param></remarks>		<short>    Convenience function </short>
		/// 		<see> adjustPath</see>
		public static string RelativeUrl(KUrl base_url, KUrl url) {
			return (string) staticInterceptor.Invoke("relativeUrl##", "relativeUrl(const KUrl&, const KUrl&)", typeof(string), typeof(KUrl), base_url, typeof(KUrl), url);
		}
		/// <remarks>
		///  Convenience function
		///  Returns a relative path based on <code>base_dir</code> that points to <code>path.</code>
		/// <param> name="base_dir" the base directory to derive from
		/// </param><param> name="path" the new target directory
		/// </param><param> name="isParent" A pointer to a boolean which, if provided, will be set to reflect
		///  whether <code>path</code> has <code>base_dir</code> is a parent dir.
		///    </param></remarks>		<short>    Convenience function </short>
		public static string RelativePath(string base_dir, string path, ref bool isParent) {
			StackItem[] stack = new StackItem[4];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(base_dir);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(base_dir);
#endif
#if DEBUG
			stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(path);
#else
			stack[2].s_class = (IntPtr) GCHandle.Alloc(path);
#endif
			stack[3].s_bool = isParent;
			staticInterceptor.Invoke("relativePath$$$", "relativePath(const QString&, const QString&, bool*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
			((GCHandle) stack[2].s_class).Free();
#endif
			isParent = stack[3].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (string) returnValue;
		}
		public static string RelativePath(string base_dir, string path) {
			return (string) staticInterceptor.Invoke("relativePath$$", "relativePath(const QString&, const QString&)", typeof(string), typeof(string), base_dir, typeof(string), path);
		}
	}
}
