//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  This class is intended to be used with the KCmdLineArgs class, which
	///  provides convenient and powerful command line argument parsing and
	///  handling functionality.
	/// </remarks>		<short> Class that holds command line options. </short>
	/// 		<see> KCmdLineArgs</see>
	/// 		<see> for</see>
	/// 		<see> additional</see>
	/// 		<see> usage</see>
	/// 		<see> information</see>

	[SmokeClass("KCmdLineOptions")]
	public class KCmdLineOptions : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KCmdLineOptions(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KCmdLineOptions), this);
		}
		/// <remarks>
		///  Constructor.
		///      </remarks>		<short>    Constructor.</short>
		public KCmdLineOptions() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCmdLineOptions", "KCmdLineOptions()", typeof(void));
		}
		/// <remarks>
		///  Copy constructor.
		///      </remarks>		<short>    Copy constructor.</short>
		public KCmdLineOptions(KCmdLineOptions options) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCmdLineOptions#", "KCmdLineOptions(const KCmdLineOptions&)", typeof(void), typeof(KCmdLineOptions), options);
		}
		/// <remarks>
		///  Add command line option, by providing its name, description, and
		///  possibly a default value. These will print out when <i>myapp --help</i>
		///  is called on the command line.
		///  Note that if the option name begins with "no" that you will need to test
		///  for the name without the "no" and the result will be the inverse of what
		///  is specified. i.e. if "nofoo" is the name of the option and
		///  <i>myapp --nofoo</i> is called:
		///  @code
		///  KCmdLineArgs.ParsedArgs().IsSet("foo"); // false
		///  @endcode
		/// <param> name="name" option name
		/// </param><param> name="description" option description, made available for translation;
		///                     can be left off
		/// </param><param> name="defaultValue" default option value, when the value is not specified
		///                      on the command line; can be left off
		///      </param></remarks>		<short>    Add command line option, by providing its name, description, and  possibly a default value.</short>
		public KCmdLineOptions Add(QByteArray name, KLocalizedString description, QByteArray defaultValue) {
			return (KCmdLineOptions) interceptor.Invoke("add###", "add(const QByteArray&, const KLocalizedString&, const QByteArray&)", typeof(KCmdLineOptions), typeof(QByteArray), name, typeof(KLocalizedString), description, typeof(QByteArray), defaultValue);
		}
		public KCmdLineOptions Add(QByteArray name, KLocalizedString description) {
			return (KCmdLineOptions) interceptor.Invoke("add##", "add(const QByteArray&, const KLocalizedString&)", typeof(KCmdLineOptions), typeof(QByteArray), name, typeof(KLocalizedString), description);
		}
		public KCmdLineOptions Add(QByteArray name) {
			return (KCmdLineOptions) interceptor.Invoke("add#", "add(const QByteArray&)", typeof(KCmdLineOptions), typeof(QByteArray), name);
		}
		/// <remarks>
		///  Add all options from another KCmdLineOptions object.
		/// <param> name="options" options to add
		///      </param></remarks>		<short>    Add all options from another KCmdLineOptions object.</short>
		public KCmdLineOptions Add(KCmdLineOptions options) {
			return (KCmdLineOptions) interceptor.Invoke("add#", "add(const KCmdLineOptions&)", typeof(KCmdLineOptions), typeof(KCmdLineOptions), options);
		}
		~KCmdLineOptions() {
			interceptor.Invoke("~KCmdLineOptions", "~KCmdLineOptions()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KCmdLineOptions", "~KCmdLineOptions()", typeof(void));
		}
	}
}
