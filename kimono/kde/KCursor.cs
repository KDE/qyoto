//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	/// </remarks>		<author> Kurt Granroth <granroth@kde.org>
	///  </author>
	/// 		<short> A set of convenience methods for auto-hiding cursors on widgets. </short>

	[SmokeClass("KCursor")]
	public class KCursor : QCursor, IDisposable {
 		protected KCursor(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KCursor), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KCursor() {
			staticInterceptor = new SmokeInvocation(typeof(KCursor), null);
		}
		/// <remarks>
		///  Attempts to load the requested <code>name</code> cursor from the current theme.
		///  If it fails, it falls back to the Qt.CursorShape provided as the
		///  second parameter. This allows one to access cursors that may be in a
		///  theme but not in the Qt.CursorShape enum.
		/// <param> name="name" the name of the cursor to try and load
		/// </param><param> name="fallback" the cursor to load if <code>name</code> cursor can not be loaded
		///      </param></remarks>		<short>    Attempts to load the requested <code>name</code> cursor from the current theme.</short>
		public KCursor(string name, Qt.CursorShape fallback) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCursor$$", "KCursor(const QString&, Qt::CursorShape)", typeof(void), typeof(string), name, typeof(Qt.CursorShape), fallback);
		}
		~KCursor() {
			interceptor.Invoke("~KCursor", "~KCursor()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KCursor", "~KCursor()", typeof(void));
		}
		/// <remarks>
		///  Sets auto-hiding the cursor for widget <code>w.</code> Enabling it will result in
		///  the cursor being hidden when
		/// 
		/// <li>
		/// a key-event happens
		/// </li>
		/// 
		/// <li>
		/// there are no key-events for a configured time-frame (see
		///  setHideCursorDelay())
		/// </li>
		///  The cursor will be shown again when the focus is lost or a mouse-event
		///  happens.
		///  Side effect: when enabling auto-hide, mouseTracking is enabled for the
		///  specified widget, because it's needed to get mouse-move-events. So
		///  don't disable mouseTracking for a widget while using auto-hide for it.
		///  When disabling auto-hide, mouseTracking will be disabled, so if you need
		///  mouseTracking after disabling auto-hide, you have to reenable
		///  mouseTracking.
		///  If you want to use auto-hiding for widgets that don't take focus, e.g.
		///  a QCanvasView, then you have to pass all key-events that should trigger
		///  auto-hiding to autoHideEventFilter().
		///      </remarks>		<short>    Sets auto-hiding the cursor for widget <code>w.</code></short>
		public static void SetAutoHideCursor(QWidget w, bool enable, bool customEventFilter) {
			staticInterceptor.Invoke("setAutoHideCursor#$$", "setAutoHideCursor(QWidget*, bool, bool)", typeof(void), typeof(QWidget), w, typeof(bool), enable, typeof(bool), customEventFilter);
		}
		public static void SetAutoHideCursor(QWidget w, bool enable) {
			staticInterceptor.Invoke("setAutoHideCursor#$", "setAutoHideCursor(QWidget*, bool)", typeof(void), typeof(QWidget), w, typeof(bool), enable);
		}
		/// <remarks>
		///  Sets the delay time in milliseconds for auto-hiding. When no keyboard
		///  events arrive for that time-frame, the cursor will be hidden.
		///  Default is 5000, i.e. 5 seconds.
		///      </remarks>		<short>    Sets the delay time in milliseconds for auto-hiding.</short>
		public static void SetHideCursorDelay(int ms) {
			staticInterceptor.Invoke("setHideCursorDelay$", "setHideCursorDelay(int)", typeof(void), typeof(int), ms);
		}
		/// <remarks>
		///  Default is 5000, i.e. 5 seconds.
		///      </remarks>		<return> the current auto-hide delay time.
		/// </return>
		/// 		<short>   </short>
		public static int HideCursorDelay() {
			return (int) staticInterceptor.Invoke("hideCursorDelay", "hideCursorDelay()", typeof(int));
		}
		/// <remarks>
		///  KCursor has to install an eventFilter over the widget you want to
		///  auto-hide. If you have an own eventFilter() on that widget and stop
		///  some events by returning true, you might break auto-hiding, because
		///  KCursor doesn't get those events.
		///  In this case, you need to call setAutoHideCursor( widget, true, true );
		///  to tell KCursor not to install an eventFilter. Then you call this method
		///  from the beginning of your eventFilter, for example:
		///  <pre>
		///  edit = new KEdit( this, "some edit widget" );
		///  edit.InstallEventFilter( this );
		///  KCursor.SetAutoHideCursor( edit, true, true );
		///  [...]
		///  bool YourClass.EventFilter( QObject o, QEvent e )
		///  {
		///      if ( o == edit ) // only that widget where you enabled auto-hide!
		///          KCursor.AutoHideEventFilter( o, e );
		///      // now you can do your own event-processing
		///      [...]
		///  }
		///  </pre>
		///  Note that you must not call KCursor.AutoHideEventFilter() when you
		///  didn't enable or after disabling auto-hiding.
		///      </remarks>		<short>    KCursor has to install an eventFilter over the widget you want to  auto-hide.</short>
		public static void AutoHideEventFilter(QObject arg1, QEvent arg2) {
			staticInterceptor.Invoke("autoHideEventFilter##", "autoHideEventFilter(QObject*, QEvent*)", typeof(void), typeof(QObject), arg1, typeof(QEvent), arg2);
		}
	}
}
