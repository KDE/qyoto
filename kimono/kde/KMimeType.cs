//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;
	/// <remarks>
	///  Represent a mime type, like "text/plain", and the data that is associated
	///  with it.
	///  The starting point you need is often the static methods.
	///  KMimeType inherits KServiceType because "text/plain" can be used to find
	///  services (apps and components) "which can open text/plain".
	/// </remarks>		<short>    Represent a mime type, like "text/plain", and the data that is associated  with it.</short>
	/// 		<see> KServiceType</see>
	[SmokeClass("KMimeType")]
	public class KMimeType : KServiceType, IDisposable {
 		protected KMimeType(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KMimeType), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KMimeType() {
			staticInterceptor = new SmokeInvocation(typeof(KMimeType), null);
		}
		public enum FindByNameOption {
			DontResolveAlias = 0,
			ResolveAliases = 1,
		}
		// KMimeType* KMimeType(KMimeTypePrivate& arg1); >>>> NOT CONVERTED
		// KMimeType* KMimeType(KMimeTypePrivate& arg1,const QString& arg2,const QString& arg3); >>>> NOT CONVERTED
		/// <remarks>
		///  Return the filename of the icon associated with the mimetype.
		///  Use KIconLoader.LoadMimeTypeIcon to load the icon.
		///  The url argument is unused, but is provided so that KMimeType-derived classes
		///  can use it (e.g. KFolderType uses the URL to return one out of 2 icons)
		/// </remarks>		<return> The path to the icon associated with this MIME type.
		///      </return>
		/// 		<short>    Return the filename of the icon associated with the mimetype.</short>
		public string IconName(KUrl url) {
			return (string) interceptor.Invoke("iconName#", "iconName(const KUrl&) const", typeof(string), typeof(KUrl), url);
		}
		public string IconName() {
			return (string) interceptor.Invoke("iconName", "iconName() const", typeof(string));
		}
		/// <remarks>
		///  Returns the descriptive comment associated with the MIME type.
		///  The url argument is unused, but provided so that KMimeType derived classes
		///  can use it.
		/// </remarks>		<return> The descriptive comment associated with the MIME type, if any.
		///      </return>
		/// 		<short>    Returns the descriptive comment associated with the MIME type.</short>
		public string Comment(KUrl url) {
			return (string) interceptor.Invoke("comment#", "comment(const KUrl&) const", typeof(string), typeof(KUrl), url);
		}
		public new string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		///  Retrieve the list of patterns associated with the MIME Type.
		/// </remarks>		<return> a list of file globs that describe the file names
		///          (or, usually, the extensions) of files with this mime type
		///      </return>
		/// 		<short>    Retrieve the list of patterns associated with the MIME Type.</short>
		public List<string> Patterns() {
			return (List<string>) interceptor.Invoke("patterns", "patterns() const", typeof(List<string>));
		}
		public bool IsDefault() {
			return (bool) interceptor.Invoke("isDefault", "isDefault() const", typeof(bool));
		}
		/// <remarks>
		///  If this mimetype is a subclass of one or more other mimetypes,
		///  return the list of those mimetypes.
		///  For instance a application/javascript is a special kind of text/plain,
		///  so the definition of application/javascript says
		///       sub-class-of type="text/plain"
		///  Another example: application/x-shellscript is a subclass of two other mimetypes,
		///  application/x-executable and text/plain.
		///  (Note that this notion doesn't map to the servicetype inheritance mechanism,
		///  since an application that handles the specific type doesn't necessarily handle
		///  the base type. The opposite is true though.)
		/// </remarks>		<return> the list of parent mimetypes
		/// </return>
		/// 		<short>    If this mimetype is a subclass of one or more other mimetypes,  return the list of those mimetypes.</short>
		public List<string> ParentMimeTypes() {
			return (List<string>) interceptor.Invoke("parentMimeTypes", "parentMimeTypes() const", typeof(List<string>));
		}
		/// <remarks>
		///  Return all parent mimetypes of this mimetype, direct or indirect.
		///  This includes the parent(s) of its parent(s), etc.
		///  If this mimetype is an alias, the list also contains the canonical
		///  name for this mimetype.
		///  The usual reason to use this method is to look for a setting which
		///  is stored per mimetype (like PreviewJob does).
		/// </remarks>		<short>    Return all parent mimetypes of this mimetype, direct or indirect.</short>
		public List<string> AllParentMimeTypes() {
			return (List<string>) interceptor.Invoke("allParentMimeTypes", "allParentMimeTypes() const", typeof(List<string>));
		}
		/// <remarks>
		///  Do not use name()=="somename" anymore, to check for a given mimetype.
		///  For mimetype inheritance to work, use is("somename") instead.
		///  Warning, do not use inherits(), that's the servicetype inheritance concept!
		///  is() also supports mimetype aliases.
		///      </remarks>		<short>    Do not use name()=="somename" anymore, to check for a given mimetype.</short>
		public bool Is(string mimeTypeName) {
			return (bool) interceptor.Invoke("is$", "is(const QString&) const", typeof(bool), typeof(string), mimeTypeName);
		}
		/// <remarks>
		///  The stream must already be positionned at the correct offset
		///      </remarks>		<short>   </short>
		public KMimeType(QDataStream str, int offset) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMimeType#$", "KMimeType(QDataStream&, int)", typeof(void), typeof(QDataStream), str, typeof(int), offset);
		}
		/// <remarks>
		///  Construct a mimetype and take all information from an XML file.
		/// <param> name="fullpath" the path to the xml that describes the mime type
		/// </param><param> name="name" the name of the mimetype (usually the end of the path)
		/// </param><param> name="comment" the comment associated with the mimetype
		///      </param></remarks>		<short>    Construct a mimetype and take all information from an XML file.</short>
		public KMimeType(string fullpath, string name, string comment) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMimeType$$$", "KMimeType(const QString&, const QString&, const QString&)", typeof(void), typeof(string), fullpath, typeof(string), name, typeof(string), comment);
		}
		/// <remarks>
		///  The stream must already be positioned at the correct offset
		///      </remarks>		<short>   </short>
		/// <remarks>
		///  Construct a mimetype and take all information from an XML file.
		/// <param> name="fullpath" the path to the xml that describes the mime type
		/// </param><param> name="name" the name of the mimetype (usually the end of the path)
		/// </param><param> name="comment" the comment associated with the mimetype
		///      </param></remarks>		<short>    Construct a mimetype and take all information from an XML file.</short>
		protected void SetPatterns(List<string> patterns) {
			interceptor.Invoke("setPatterns?", "setPatterns(const QStringList&)", typeof(void), typeof(List<string>), patterns);
		}
		protected void SetParentMimeType(string parent) {
			interceptor.Invoke("setParentMimeType$", "setParentMimeType(const QString&)", typeof(void), typeof(string), parent);
		}
		protected void InternalClearData() {
			interceptor.Invoke("internalClearData", "internalClearData()", typeof(void));
		}
		~KMimeType() {
			interceptor.Invoke("~KMimeType", "~KMimeType()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KMimeType", "~KMimeType()", typeof(void));
		}
		/// <remarks>
		///  Return the filename of the icon associated with the mimetype, for a given url.
		///  Use KIconLoader.LoadMimeTypeIcon to load the icon.
		/// <param> name="url" URL for the file
		/// </param><param> name="mode" the mode of the file. The mode may modify the icon
		///               with overlays that show special properties of the
		///               icon. Use 0 for default
		/// </param></remarks>		<return> the name of the icon. The name of a default icon if there is no icon
		///          for the mime type
		///      </return>
		/// 		<short>    Return the filename of the icon associated with the mimetype, for a given url.</short>
		public static string IconNameForUrl(KUrl url, long mode) {
			return (string) staticInterceptor.Invoke("iconNameForUrl#$", "iconNameForUrl(const KUrl&, mode_t)", typeof(string), typeof(KUrl), url, typeof(long), mode);
		}
		public static string IconNameForUrl(KUrl url) {
			return (string) staticInterceptor.Invoke("iconNameForUrl#", "iconNameForUrl(const KUrl&)", typeof(string), typeof(KUrl), url);
		}
		/// <remarks>
		///  Return the "favicon" (see http://www.favicon.com) for the given <code>url</code>,
		///  if available. Does NOT attempt to download the favicon, it only returns
		///  one that is already available.
		///  If unavailable, returns string().
		/// <param> name="url" the URL of the favicon
		/// </param></remarks>		<return> the name of the favicon, or string()
		///      </return>
		/// 		<short>    Return the "favicon" (see http://www.</short>
		public static string FavIconForUrl(KUrl url) {
			return (string) staticInterceptor.Invoke("favIconForUrl#", "favIconForUrl(const KUrl&)", typeof(string), typeof(KUrl), url);
		}
		/// <remarks>
		///  Retrieve a pointer to the mime type <code>name</code> .
		///  <b>Very</b> <b>important</b>: Don't store the result in a KMimeType !
		///  Also note that you get a new KMimeType pointer every time you call this.
		///  Don't ever write code that compares mimetype pointers, compare names instead.
		/// <param> name="name" the name of the mime type
		/// </param></remarks>		<return> the pointer to the KMimeType with the given <code>name</code>, or
		///          0 if not found
		/// </return>
		/// 		<short>    Retrieve a pointer to the mime type <code>name</code> .</short>
		/// 		<see> KServiceType.ServiceType</see>
		public static KMimeType MimeType(string name, KMimeType.FindByNameOption options) {
			return (KMimeType) staticInterceptor.Invoke("mimeType$$", "mimeType(const QString&, KMimeType::FindByNameOption)", typeof(KMimeType), typeof(string), name, typeof(KMimeType.FindByNameOption), options);
		}
		public static KMimeType MimeType(string name) {
			return (KMimeType) staticInterceptor.Invoke("mimeType$", "mimeType(const QString&)", typeof(KMimeType), typeof(string), name);
		}
		/// <remarks>
		///  Finds a KMimeType with the given <code>url.</code>
		///  This function looks at mode_t first.
		///  If that does not help it
		///  looks at the extension.  This is fine for FTP, FILE, TAR and
		///  friends, but is not for HTTP ( cgi scripts! ). You should use
		///  KRun instead, but this function returns immediately while
		///  KRun is async. If no extension matches, then
		///  the file contents will be examined if the URL is a local file, or
		///  "application/octet-stream" is returned otherwise.
		/// <param> name="url" Is the right most URL with a filesystem protocol. It
		///         is up to you to find out about that if you have a nested
		///         URL.  For example
		///         "http://localhost/mist.gz#gzip:/decompress" would have to
		///         pass the "http://..." URL part, while
		///         "file:/tmp/x.tar#tar:/src/test.gz#gzip:/decompress" would
		///         have to pass the "tar:/..." part of the URL, since gzip is
		///         a filter protocol and not a filesystem protocol.
		/// </param><param> name="mode" the mode of the file (used, for example, to identify
		///               executables)
		/// </param><param> name="is_local_file" true if the file is local; false if not, or if you don't know.
		/// </param><param> name="fast_mode" If set to true no disk access is allowed to
		///         find out the mimetype. The result may be suboptimal, but
		///         it is <b>fast</b>.
		/// </param><param> name="accuracy" if set, the accuracy of the result, between 0 and 100.
		///         For instance, when the extension was used to determine the mimetype,
		///         the accuracy is set to 80, as per the shared-mime spec.
		///         Some 'magic' rules (used when !fast_mode) have an accuracy > 80
		///         (and have priority over the filename, others are < 80).
		/// </param></remarks>		<return> A pointer to the matching mimetype. 0 is never returned.
		///  @em Very @em Important: Don't store the result in a KMimeType* !
		///      </return>
		/// 		<short>    Finds a KMimeType with the given <code>url.</code></short>
		public static KMimeType FindByUrl(KUrl url, long mode, bool is_local_file, bool fast_mode, ref int accuracy) {
			StackItem[] stack = new StackItem[6];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(url);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(url);
#endif
			stack[2].s_long = mode;
			stack[3].s_bool = is_local_file;
			stack[4].s_bool = fast_mode;
			stack[5].s_int = accuracy;
			staticInterceptor.Invoke("findByUrl#$$$$", "findByUrl(const KUrl&, mode_t, bool, bool, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			accuracy = stack[5].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (KMimeType) returnValue;
		}
		public static KMimeType FindByUrl(KUrl url, long mode, bool is_local_file, bool fast_mode) {
			return (KMimeType) staticInterceptor.Invoke("findByUrl#$$$", "findByUrl(const KUrl&, mode_t, bool, bool)", typeof(KMimeType), typeof(KUrl), url, typeof(long), mode, typeof(bool), is_local_file, typeof(bool), fast_mode);
		}
		public static KMimeType FindByUrl(KUrl url, long mode, bool is_local_file) {
			return (KMimeType) staticInterceptor.Invoke("findByUrl#$$", "findByUrl(const KUrl&, mode_t, bool)", typeof(KMimeType), typeof(KUrl), url, typeof(long), mode, typeof(bool), is_local_file);
		}
		public static KMimeType FindByUrl(KUrl url, long mode) {
			return (KMimeType) staticInterceptor.Invoke("findByUrl#$", "findByUrl(const KUrl&, mode_t)", typeof(KMimeType), typeof(KUrl), url, typeof(long), mode);
		}
		public static KMimeType FindByUrl(KUrl url) {
			return (KMimeType) staticInterceptor.Invoke("findByUrl#", "findByUrl(const KUrl&)", typeof(KMimeType), typeof(KUrl), url);
		}
		/// <remarks>
		///  Finds a KMimeType with the given <code>url.</code>
		///  This function looks at mode_t first.
		///  If that does not help it
		///  looks at the extension.  This is fine for FTP, FILE, TAR and
		///  friends, but is not for HTTP ( cgi scripts! ). You should use
		///  KRun instead, but this function returns immediately while
		///  KRun is async. If no extension matches, then
		///  the file contents will be examined if the URL is a local file, or
		///  "application/octet-stream" is returned otherwise.
		///  Equivalent to
		///  <pre>
		///  KUrl u;
		///  u.setPath(path);
		///  return findByUrl( u, mode, true, fast_mode );
		///  </pre>
		/// <param> name="path" the path to the file
		/// </param><param> name="mode" the mode of the file (used, for example, to identify
		///               executables)
		/// </param><param> name="fast_mode" If set to true no disk access is allowed to
		///         find out the mimetype. The result may be suboptimal, but
		///         it is <b>fast</b>.
		/// </param><param> name="accuracy" If not a null pointer, accuracy is set to the
		///           accuracy of the match (which is in the range 0..100)
		/// </param></remarks>		<return> A pointer to the matching mimetype. 0 is never returned.
		///      </return>
		/// 		<short>    Finds a KMimeType with the given <code>url.</code></short>
		public static KMimeType FindByPath(string path, long mode, bool fast_mode, ref int accuracy) {
			StackItem[] stack = new StackItem[5];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(path);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(path);
#endif
			stack[2].s_long = mode;
			stack[3].s_bool = fast_mode;
			stack[4].s_int = accuracy;
			staticInterceptor.Invoke("findByPath$$$$", "findByPath(const QString&, mode_t, bool, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			accuracy = stack[4].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (KMimeType) returnValue;
		}
		public static KMimeType FindByPath(string path, long mode, bool fast_mode) {
			return (KMimeType) staticInterceptor.Invoke("findByPath$$$", "findByPath(const QString&, mode_t, bool)", typeof(KMimeType), typeof(string), path, typeof(long), mode, typeof(bool), fast_mode);
		}
		public static KMimeType FindByPath(string path, long mode) {
			return (KMimeType) staticInterceptor.Invoke("findByPath$$", "findByPath(const QString&, mode_t)", typeof(KMimeType), typeof(string), path, typeof(long), mode);
		}
		public static KMimeType FindByPath(string path) {
			return (KMimeType) staticInterceptor.Invoke("findByPath$", "findByPath(const QString&)", typeof(KMimeType), typeof(string), path);
		}
		/// <remarks>
		///  Tries to find out the MIME type of a data chunk by looking for
		///  certain magic numbers and characteristic strings in it.
		/// <param> name="data" the data to examine
		/// </param><param> name="accuracy" If not a null pointer, accuracy is set to the
		///           accuracy of the match (which is in the range 0..100)
		/// </param></remarks>		<return> a pointer to the KMimeType. @c 0 if the
		///          type can not be found this way.
		///      </return>
		/// 		<short>    Tries to find out the MIME type of a data chunk by looking for  certain magic numbers and characteristic strings in it.</short>
		public static KMimeType FindByContent(QByteArray data, ref int accuracy) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(data);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(data);
#endif
			stack[2].s_int = accuracy;
			staticInterceptor.Invoke("findByContent#$", "findByContent(const QByteArray&, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			accuracy = stack[2].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (KMimeType) returnValue;
		}
		public static KMimeType FindByContent(QByteArray data) {
			return (KMimeType) staticInterceptor.Invoke("findByContent#", "findByContent(const QByteArray&)", typeof(KMimeType), typeof(QByteArray), data);
		}
		/// <remarks>
		///  Tries to find out the MIME type of filename/url and a data chunk.
		///  Whether to trust the extension or the data depends on the results of both approaches,
		///  and is determined automatically.
		///  This method is useful for instance in the get() method of kioslaves, and anywhere else
		///  where a filename is associated with some data which is available immediately.
		/// <param> name="name" the filename or url representing this data.
		///  Only used for the extension, not used as a local filename.
		/// </param><param> name="data" the data to examine when the extension isn't conclusive in itself
		/// </param><param> name="mode" the mode of the file (used, for example, to identify executables)
		/// </param><param> name="accuracy" If not a null pointer, accuracy is set to the
		///           accuracy of the match (which is in the range 0..100)
		///      </param></remarks>		<short>    Tries to find out the MIME type of filename/url and a data chunk.</short>
		public static KMimeType FindByNameAndContent(string name, QByteArray data, long mode, ref int accuracy) {
			StackItem[] stack = new StackItem[5];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(name);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(name);
#endif
#if DEBUG
			stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(data);
#else
			stack[2].s_class = (IntPtr) GCHandle.Alloc(data);
#endif
			stack[3].s_long = mode;
			stack[4].s_int = accuracy;
			staticInterceptor.Invoke("findByNameAndContent$#$$", "findByNameAndContent(const QString&, const QByteArray&, mode_t, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
			((GCHandle) stack[2].s_class).Free();
#endif
			accuracy = stack[4].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (KMimeType) returnValue;
		}
		public static KMimeType FindByNameAndContent(string name, QByteArray data, long mode) {
			return (KMimeType) staticInterceptor.Invoke("findByNameAndContent$#$", "findByNameAndContent(const QString&, const QByteArray&, mode_t)", typeof(KMimeType), typeof(string), name, typeof(QByteArray), data, typeof(long), mode);
		}
		public static KMimeType FindByNameAndContent(string name, QByteArray data) {
			return (KMimeType) staticInterceptor.Invoke("findByNameAndContent$#", "findByNameAndContent(const QString&, const QByteArray&)", typeof(KMimeType), typeof(string), name, typeof(QByteArray), data);
		}
		/// <remarks>
		///  Tries to find out the MIME type of a file by looking for
		///  certain magic numbers and characteristic strings in it.
		///  This function is similar to the previous one. Note that the
		///  file name is not used for determining the file type, it is just
		///  used for loading the file's contents.
		/// <param> name="fileName" the path to the file
		/// </param><param> name="accuracy" If not a null pointer, accuracy is set to the
		///           accuracy of the match (which is in the range 0..100)
		/// </param></remarks>		<return> a pointer to the KMimeType, or the default mimetype
		///          (application/octet-stream) if the file cannot be opened.
		///      </return>
		/// 		<short>    Tries to find out the MIME type of a file by looking for  certain magic numbers and characteristic strings in it.</short>
		public static KMimeType FindByFileContent(string fileName, ref int accuracy) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(fileName);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(fileName);
#endif
			stack[2].s_int = accuracy;
			staticInterceptor.Invoke("findByFileContent$$", "findByFileContent(const QString&, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			accuracy = stack[2].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (KMimeType) returnValue;
		}
		public static KMimeType FindByFileContent(string fileName) {
			return (KMimeType) staticInterceptor.Invoke("findByFileContent$", "findByFileContent(const QString&)", typeof(KMimeType), typeof(string), fileName);
		}
		/// <remarks>
		///  Returns whether a file has an internal format that is not human readable.
		///  This is much more generic than "not mime.Is(text/plain)".
		///  Many application file formats (like rtf and postscript) are based on text,
		///  but text that the user should rarely ever see.
		///      </remarks>		<short>    Returns whether a file has an internal format that is not human readable.</short>
		public static bool IsBinaryData(string fileName) {
			return (bool) staticInterceptor.Invoke("isBinaryData$", "isBinaryData(const QString&)", typeof(bool), typeof(string), fileName);
		}
		/// <remarks>
		///  Returns whether a buffer has an internal format that is not human readable.
		///  This is much more generic than "not mime.Is(text/plain)".
		///  Many application file formats (like rtf and postscript) are based on text,
		///  but text that the user should rarely ever see.
		///      </remarks>		<short>    Returns whether a buffer has an internal format that is not human readable.</short>
		public static bool IsBufferBinaryData(QByteArray data) {
			return (bool) staticInterceptor.Invoke("isBufferBinaryData#", "isBufferBinaryData(const QByteArray&)", typeof(bool), typeof(QByteArray), data);
		}
		/// <remarks>
		///  Get all the mimetypes.
		///  Useful for showing the list of
		///  available mimetypes.
		///  More memory consuming than the ones above, don't use unless
		///  really necessary.
		/// </remarks>		<return> the list of all existing KMimeTypes
		///      </return>
		/// 		<short>    Get all the mimetypes.</short>
		public static List<KMimeType> AllMimeTypes() {
			return (List<KMimeType>) staticInterceptor.Invoke("allMimeTypes", "allMimeTypes()", typeof(List<KMimeType>));
		}
		/// <remarks>
		///  Returns the name of the default mimetype.
		///  Always application/octet-stream, but this method exists
		///  for performance purposes.
		/// </remarks>		<return> the name of the default mime type, always
		///          "application/octet-stream"
		///      </return>
		/// 		<short>    Returns the name of the default mimetype.</short>
		public static string DefaultMimeType() {
			return (string) staticInterceptor.Invoke("defaultMimeType", "defaultMimeType()", typeof(string));
		}
		/// <remarks>
		///  Returns the default mimetype.
		///  Always application/octet-stream.
		///  This can be used to check the result of mimeType(name).
		/// </remarks>		<return> the "application/octet-stream" mimetype pointer.
		///      </return>
		/// 		<short>    Returns the default mimetype.</short>
		public static KMimeType DefaultMimeTypePtr() {
			return (KMimeType) staticInterceptor.Invoke("defaultMimeTypePtr", "defaultMimeTypePtr()", typeof(KMimeType));
		}
		/// <remarks>
		///  Determines the extension from a filename (or full path) using the mimetype database.
		///  This allows to extract "tar.bz2" for foo.tar.bz2
		///  but still return "txt" for my.doc.with.dots.txt
		///      </remarks>		<short>    Determines the extension from a filename (or full path) using the mimetype database.</short>
		public static string ExtractKnownExtension(string fileName) {
			return (string) staticInterceptor.Invoke("extractKnownExtension$", "extractKnownExtension(const QString&)", typeof(string), typeof(string), fileName);
		}
	}
}
