//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	/// <remarks>
	///  A base class for entries in an KArchive.
	/// </remarks>		<short> Base class for the archive-file's directory structure. </short>
	/// 		<see> KArchiveFile</see>
	/// 		<see> KArchiveDirectory</see>
	[SmokeClass("KArchiveEntry")]
	public class KArchiveEntry : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KArchiveEntry(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KArchiveEntry), this);
		}
		/// <remarks>
		///  Creates a new entry.
		/// <param> name="archive" the entries archive
		/// </param><param> name="name" the name of the entry
		/// </param><param> name="access" the permissions in unix format
		/// </param><param> name="date" the date (in seconds since 1970)
		/// </param><param> name="user" the user that owns the entry
		/// </param><param> name="group" the group that owns the entry
		/// </param><param> name="symlink" the symlink, or string()
		///      </param></remarks>		<short>    Creates a new entry.</short>
		public KArchiveEntry(KArchive archive, string name, int access, int date, string user, string group, string symlink) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KArchiveEntry#$$$$$$", "KArchiveEntry(KArchive*, const QString&, int, int, const QString&, const QString&, const QString&)", typeof(void), typeof(KArchive), archive, typeof(string), name, typeof(int), access, typeof(int), date, typeof(string), user, typeof(string), group, typeof(string), symlink);
		}
		/// <remarks>
		///  Creation date of the file.
		/// </remarks>		<return> the creation date
		///      </return>
		/// 		<short>    Creation date of the file.</short>
		public QDateTime Datetime() {
			return (QDateTime) interceptor.Invoke("datetime", "datetime() const", typeof(QDateTime));
		}
		/// <remarks>
		///  Creation date of the file.
		/// </remarks>		<return> the creation date in seconds since 1970
		///      </return>
		/// 		<short>    Creation date of the file.</short>
		public int Date() {
			return (int) interceptor.Invoke("date", "date() const", typeof(int));
		}
		/// <remarks>
		///  Name of the file without path.
		/// </remarks>		<return> the file name without path
		///      </return>
		/// 		<short>    Name of the file without path.</short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  The permissions and mode flags as returned by the stat() function
		///  in st_mode.
		/// </remarks>		<return> the permissions
		///      </return>
		/// 		<short>    The permissions and mode flags as returned by the stat() function  in st_mode.</short>
		public long Permissions() {
			return (long) interceptor.Invoke("permissions", "permissions() const", typeof(long));
		}
		/// <remarks>
		///  User who created the file.
		/// </remarks>		<return> the owner of the file
		///      </return>
		/// 		<short>    User who created the file.</short>
		public string User() {
			return (string) interceptor.Invoke("user", "user() const", typeof(string));
		}
		/// <remarks>
		///  Group of the user who created the file.
		/// </remarks>		<return> the group of the file
		///      </return>
		/// 		<short>    Group of the user who created the file.</short>
		public string Group() {
			return (string) interceptor.Invoke("group", "group() const", typeof(string));
		}
		/// <remarks>
		///  Symlink if there is one.
		/// </remarks>		<return> the symlink, or string()
		///      </return>
		/// 		<short>    Symlink if there is one.</short>
		public string SymLinkTarget() {
			return (string) interceptor.Invoke("symLinkTarget", "symLinkTarget() const", typeof(string));
		}
		/// <remarks>
		///  Checks whether the entry is a file.
		/// </remarks>		<return> true if this entry is a file
		///      </return>
		/// 		<short>    Checks whether the entry is a file.</short>
		[SmokeMethod("isFile() const")]
		public virtual bool IsFile() {
			return (bool) interceptor.Invoke("isFile", "isFile() const", typeof(bool));
		}
		/// <remarks>
		///  Checks whether the entry is a directory.
		/// </remarks>		<return> true if this entry is a directory
		///      </return>
		/// 		<short>    Checks whether the entry is a directory.</short>
		[SmokeMethod("isDirectory() const")]
		public virtual bool IsDirectory() {
			return (bool) interceptor.Invoke("isDirectory", "isDirectory() const", typeof(bool));
		}
		protected KArchive Archive() {
			return (KArchive) interceptor.Invoke("archive", "archive() const", typeof(KArchive));
		}
		~KArchiveEntry() {
			interceptor.Invoke("~KArchiveEntry", "~KArchiveEntry()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KArchiveEntry", "~KArchiveEntry()", typeof(void));
		}
	}
}
