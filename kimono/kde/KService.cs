//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;

	/// <remarks>
	///  Represent a service, like an application or plugin
	///  bound to one or several mimetypes (or servicetypes) as written
	///  in its desktop entry file.
	///  The starting point you need is often the static methods, like createInstance().
	///  The types of service a plugin provides is taken from the accompanying desktop file
	///  where the 'ServiceTypes=' field is used.
	///  For a tutorial on how to build a plugin-loading mechanism and how to write plugins
	///  in general, see http://developer.kde.org/documentation/tutorials/developing-a-plugin-structure/index.html#developing_plugins
	///  (todo: port to kde4, create techbase article)
	/// </remarks>		<author> Torben Weis
	///  </author>
	/// 		<short>    Represent a service, like an application or plugin  bound to one or several mimetypes (or servicetypes) as written  in its desktop entry file.</short>
	/// 		<see> KServiceType</see>
	/// 		<see> KServiceGroup</see>

	[SmokeClass("KService")]
	public class KService : KSycocaEntry, IDisposable {
 		protected KService(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KService), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KService() {
			staticInterceptor = new SmokeInvocation(typeof(KService), null);
		}
		/// <remarks>
		///  Describes the DBUS Startup type of the service.
		/// 
		/// <li>
		/// None - This service has no DBUS support
		/// </li>
		/// 
		/// <li>
		/// Unique - This service provides a unique DBUS service.
		///               The service name is equal to the desktopEntryName.
		/// </li>
		/// 
		/// <li>
		/// Multi - This service provides a DBUS service which can be run
		///              with multiple instances in parallel. The service name of
		///              an instance is equal to the desktopEntryName + "-" +
		///              the PID of the process.
		/// </li>
		/// 
		/// <li>
		/// Wait - This service has no DBUS support, the launcher will wait
		///             till it is finished.
		///      
		/// </li></remarks>		<short>    Describes the DBUS Startup type of the service.</short>
		public enum DBUSStartupType_t {
			DBUS_None = 0,
			DBUS_Unique = 1,
			DBUS_Multi = 2,
			DBUS_Wait = 3,
		}
		// KService::Ptr serviceByName(const QString& arg1); >>>> NOT CONVERTED
		// KService::Ptr serviceByDesktopPath(const QString& arg1); >>>> NOT CONVERTED
		// KService::Ptr serviceByDesktopName(const QString& arg1); >>>> NOT CONVERTED
		// KService::Ptr serviceByMenuId(const QString& arg1); >>>> NOT CONVERTED
		// KService::Ptr serviceByStorageId(const QString& arg1); >>>> NOT CONVERTED
		// template <T>  T* createInstance(const KService::Ptr& arg1,QObject* arg2,const QStringList& arg3,int* arg4); >>>> NOT CONVERTED
		// template <T>  T* createInstance(const KService::Ptr& arg1,QObject* arg2,const QStringList& arg3); >>>> NOT CONVERTED
		// template <T>  T* createInstance(const KService::Ptr& arg1,QObject* arg2); >>>> NOT CONVERTED
		// template <T>  T* createInstance(const KService::Ptr& arg1); >>>> NOT CONVERTED
		// template <T, class ServiceIterator>  T* createInstance(ServiceIterator arg1,ServiceIterator arg2,QObject* arg3,const QStringList& arg4,int* arg5); >>>> NOT CONVERTED
		// template <T, class ServiceIterator>  T* createInstance(ServiceIterator arg1,ServiceIterator arg2,QObject* arg3,const QStringList& arg4); >>>> NOT CONVERTED
		// template <T, class ServiceIterator>  T* createInstance(ServiceIterator arg1,ServiceIterator arg2,QObject* arg3); >>>> NOT CONVERTED
		// template <T, class ServiceIterator>  T* createInstance(ServiceIterator arg1,ServiceIterator arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  Construct a temporary service with a given name, exec-line and icon.
		/// <param> name="name" the name of the service
		/// </param><param> name="exec" the executable
		/// </param><param> name="icon" the name of the icon
		///      </param></remarks>		<short>    Construct a temporary service with a given name, exec-line and icon.</short>
		public KService(string name, string exec, string icon) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KService$$$", "KService(const QString&, const QString&, const QString&)", typeof(void), typeof(string), name, typeof(string), exec, typeof(string), icon);
		}
		/// <remarks>
		///  Construct a service and take all information from a config file.
		/// <param> name="fullpath" Full path to the config file.
		///      </param></remarks>		<short>    Construct a service and take all information from a config file.</short>
		public KService(string fullpath) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KService$", "KService(const QString&)", typeof(void), typeof(string), fullpath);
		}
		/// <remarks>
		///  Construct a service and take all information from a desktop file.
		/// <param> name="config" the desktop file to read
		///      </param></remarks>		<short>    Construct a service and take all information from a desktop file.</short>
		public KService(KDesktopFile config) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KService#", "KService(const KDesktopFile*)", typeof(void), typeof(KDesktopFile), config);
		}
		/// <remarks>
		///  Construct a service from a stream.
		///  The stream must already be positionned at the correct offset.
		///      </remarks>		<short>   </short>
		public KService(QDataStream str, int offset) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KService#$", "KService(QDataStream&, int)", typeof(void), typeof(QDataStream), str, typeof(int), offset);
		}
		/// <remarks>
		///  Services are either applications (executables) or dlopened libraries (plugins).
		/// </remarks>		<return> true if this service is an application, i.e. it has Type=Application in its
		///  .desktop file and exec() will not be empty.
		///      </return>
		/// 		<short>    Services are either applications (executables) or dlopened libraries (plugins).</short>
		public bool IsApplication() {
			return (bool) interceptor.Invoke("isApplication", "isApplication() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the name of the service.
		/// </remarks>		<return> the name of the service,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the name of the service.</short>
		[SmokeMethod("name() const")]
		public override string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  Returns the executable.
		/// </remarks>		<return> the command that the service executes,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the executable.</short>
		public string Exec() {
			return (string) interceptor.Invoke("exec", "exec() const", typeof(string));
		}
		/// <remarks>
		///  Returns the name of the service's library.
		/// </remarks>		<return> the name of the library that contains the service's
		///          implementation, or string() if not set
		///      </return>
		/// 		<short>    Returns the name of the service's library.</short>
		public string Library() {
			return (string) interceptor.Invoke("library", "library() const", typeof(string));
		}
		/// <remarks>
		///  Returns the name of the icon.
		/// </remarks>		<return> the icon associated with the service,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the name of the icon.</short>
		public string Icon() {
			return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
		}
		/// <remarks>
		///  Checks whethe the service should be run in a terminal.
		/// </remarks>		<return> true if the service is to be run in a terminal.
		///      </return>
		/// 		<short>    Checks whethe the service should be run in a terminal.</short>
		public bool Terminal() {
			return (bool) interceptor.Invoke("terminal", "terminal() const", typeof(bool));
		}
		/// <remarks>
		///  Returns any options associated with the terminal the service
		///  runs in, if it requires a terminal.
		///  The service must be a tty-oriented program.
		/// </remarks>		<return> the terminal options,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns any options associated with the terminal the service  runs in, if it requires a terminal.</short>
		public string TerminalOptions() {
			return (string) interceptor.Invoke("terminalOptions", "terminalOptions() const", typeof(string));
		}
		/// <remarks>
		///  Checks whether the service runs with a different user id.
		/// </remarks>		<return> true if the service has to be run under a different uid.
		/// </return>
		/// 		<short>    Checks whether the service runs with a different user id.</short>
		/// 		<see> username</see>
		public bool SubstituteUid() {
			return (bool) interceptor.Invoke("substituteUid", "substituteUid() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the user name, if the service runs with a
		///  different user id.
		/// </remarks>		<return> the username under which the service has to be run,
		///          or string() if not set
		/// </return>
		/// 		<short>    Returns the user name, if the service runs with a  different user id.</short>
		/// 		<see> substututeUida</see>
		public string Username() {
			return (string) interceptor.Invoke("username", "username() const", typeof(string));
		}
		/// <remarks>
		///  Returns the path to the location where the service desktop entry
		///  is stored.
		///  This is a relative path if the desktop entry was found in any
		///  of the locations pointed to by $KDEDIRS (e.g. "Internet/kppp.desktop")
		///  It is a full path if the desktop entry originates from another
		///  location.
		/// </remarks>		<return> the path of the service's desktop file,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the path to the location where the service desktop entry  is stored.</short>
		public string DesktopEntryPath() {
			return (string) interceptor.Invoke("desktopEntryPath", "desktopEntryPath() const", typeof(string));
		}
		/// <remarks>
		///  Returns the filename of the service desktop entry without any
		///  extension. E.g. "kppp"
		/// </remarks>		<return> the name of the desktop entry without path or extension,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the filename of the service desktop entry without any  extension.</short>
		public string DesktopEntryName() {
			return (string) interceptor.Invoke("desktopEntryName", "desktopEntryName() const", typeof(string));
		}
		/// <remarks>
		///  Returns the menu ID of the service desktop entry.
		///  The menu ID is used to add or remove the entry to a menu.
		/// </remarks>		<return> the menu ID
		///      </return>
		/// 		<short>    Returns the menu ID of the service desktop entry.</short>
		public string MenuId() {
			return (string) interceptor.Invoke("menuId", "menuId() const", typeof(string));
		}
		/// <remarks>
		///  Returns a normalized ID suitable for storing in configuration files.
		///  It will be based on the menu-id when available and otherwise falls
		///  back to desktopEntryPath()
		/// </remarks>		<return> the storage ID
		///      </return>
		/// 		<short>    Returns a normalized ID suitable for storing in configuration files.</short>
		public string StorageId() {
			return (string) interceptor.Invoke("storageId", "storageId() const", typeof(string));
		}
		/// <remarks>
		///  Returns the DBUSStartupType supported by this service.
		/// </remarks>		<return> the DBUSStartupType supported by this service
		///      </return>
		/// 		<short>    Returns the DBUSStartupType supported by this service.</short>
		public KService.DBUSStartupType_t DBUSStartupType() {
			return (KService.DBUSStartupType_t) interceptor.Invoke("DBUSStartupType", "DBUSStartupType() const", typeof(KService.DBUSStartupType_t));
		}
		/// <remarks>
		///  Returns the working directory to run the program in.
		/// </remarks>		<return> the working directory to run the program in,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the working directory to run the program in.</short>
		public string Path() {
			return (string) interceptor.Invoke("path", "path() const", typeof(string));
		}
		/// <remarks>
		///  Returns the descriptive comment for the service, if there is one.
		/// </remarks>		<return> the descriptive comment for the service, or string()
		///          if not set
		///      </return>
		/// 		<short>    Returns the descriptive comment for the service, if there is one.</short>
		public string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		///  Returns the generic name for the service, if there is one
		///  (e.g. "Mail Client").
		/// </remarks>		<return> the generic name,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the generic name for the service, if there is one  (e.</short>
		public string GenericName() {
			return (string) interceptor.Invoke("genericName", "genericName() const", typeof(string));
		}
		/// <remarks>
		///  Returns the untranslated (US English) generic name
		///  for the service, if there is one
		///  (e.g. "Mail Client").
		/// </remarks>		<return> the generic name,
		///          or string() if not set
		///      </return>
		/// 		<short>    Returns the untranslated (US English) generic name  for the service, if there is one  (e.</short>
		public string UntranslatedGenericName() {
			return (string) interceptor.Invoke("untranslatedGenericName", "untranslatedGenericName() const", typeof(string));
		}
		/// <remarks>
		///  Returns a list of descriptive keywords the service, if there are any.
		/// </remarks>		<return> the list of keywords
		///      </return>
		/// 		<short>    Returns a list of descriptive keywords the service, if there are any.</short>
		public List<string> Keywords() {
			return (List<string>) interceptor.Invoke("keywords", "keywords() const", typeof(List<string>));
		}
		/// <remarks>
		///  Returns a list of VFolder categories.
		/// </remarks>		<return> the list of VFolder categories
		///      </return>
		/// 		<short>    Returns a list of VFolder categories.</short>
		public List<string> Categories() {
			return (List<string>) interceptor.Invoke("categories", "categories() const", typeof(List<string>));
		}
		/// <remarks>
		///  Returns the service types that this service supports.
		/// </remarks>		<return> the list of service types that are supported
		///  Note that this doesn't include inherited servicetypes or mimetypes,
		///  only the service types listed in the .desktop file.
		///      </return>
		/// 		<short>    Returns the service types that this service supports.</short>
		public List<string> ServiceTypes() {
			return (List<string>) interceptor.Invoke("serviceTypes", "serviceTypes() const", typeof(List<string>));
		}
		/// <remarks>
		///  Checks whether the service supports this service type
		/// <param> name="serviceTypePtr" The name of the service type you are
		///         interested in determining whether this service supports.
		/// </param></remarks>		<return> true if the service type you specified is supported, otherwise false.
		///      </return>
		/// 		<short>    Checks whether the service supports this service type </short>
		public bool HasServiceType(string serviceTypePtr) {
			return (bool) interceptor.Invoke("hasServiceType$", "hasServiceType(const QString&) const", typeof(bool), typeof(string), serviceTypePtr);
		}
		/// <remarks>
		///  Checks whether the mime supports this mime type
		/// <param> name="mimeTypePtr" The name of the mime type you are
		///         interested in determining whether this service supports.
		/// </param> Note that if you only have the name of the mime type, you have to look it up
		///  with KMimeType.MimeType( mimetype ) and use .data() on the result (this is
		///  because KService doesn't know KMimeType for dependency reasons)
		///  Warning this method will fail to return true if this KService isn't from ksycoca
		///  (i.e. it was created with a full path or a KDesktopFile) and the mimetype
		///  isn't explicited listed in the .desktop file but a parent mimetype is.
		///  For this reason you should generally get KServices with KMimeTypeTrader
		///  or one of the KService.ServiceBy methods.
		/// </remarks>		<return> true if the mime type you specified is supported, otherwise false.
		///      </return>
		/// 		<short>    Checks whether the mime supports this mime type </short>
		public bool HasMimeType(KServiceType mimeTypePtr) {
			return (bool) interceptor.Invoke("hasMimeType#", "hasMimeType(const KServiceType*) const", typeof(bool), typeof(KServiceType), mimeTypePtr);
		}
		/// <remarks>
		///  Set to true if it is allowed to use this service as the default (main)
		///  action for the files it supports (e.g. Left Click in a file manager, or KRun in general).
		///  If not, then this service is only available in RMB popups, so it must
		///  be selected explicitly by the user in order to be used.
		///  Note that servicemenus supersede this functionality though, at least in konqueror.
		/// </remarks>		<return> true if the service may be used as the default (main) handler
		///      </return>
		/// 		<short>    Set to true if it is allowed to use this service as the default (main)  action for the files it supports (e.</short>
		public bool AllowAsDefault() {
			return (bool) interceptor.Invoke("allowAsDefault", "allowAsDefault() const", typeof(bool));
		}
		/// <remarks>
		///  Checks whether this service can handle several files as
		///  startup arguments.
		/// </remarks>		<return> true if multiple files may be passed to this service at
		///  startup. False if only one file at a time may be passed.
		///      </return>
		/// 		<short>    Checks whether this service can handle several files as  startup arguments.</short>
		public bool AllowMultipleFiles() {
			return (bool) interceptor.Invoke("allowMultipleFiles", "allowMultipleFiles() const", typeof(bool));
		}
		/// <remarks>
		///  What preference to associate with this service initially (before
		///  the user has had any chance to define a profile for it).
		///  The bigger the value, the most preferred the service is.
		/// </remarks>		<return> the service preference level of the service
		///      </return>
		/// 		<short>    What preference to associate with this service initially (before  the user has had any chance to define a profile for it).</short>
		public int InitialPreference() {
			return (int) interceptor.Invoke("initialPreference", "initialPreference() const", typeof(int));
		}
		/// <remarks>
		///  Whether the entry should be suppressed in menus.
		/// </remarks>		<return> true to suppress this service
		///      </return>
		/// 		<short>    Whether the entry should be suppressed in menus.</short>
		public bool NoDisplay() {
			return (bool) interceptor.Invoke("noDisplay", "noDisplay() const", typeof(bool));
		}
		/// <remarks>
		///  Name of the application this service belongs to.
		///  (Useful for e.g. plugins)
		/// </remarks>		<return> the parent application, or string() if not set
		///      </return>
		/// 		<short>    Name of the application this service belongs to.</short>
		public string ParentApp() {
			return (string) interceptor.Invoke("parentApp", "parentApp() const", typeof(string));
		}
		/// <remarks>
		///  Returns the requested property. Some often used properties
		///  have convenience access functions like exec(),
		///  serviceTypes etc.
		///  It depends upon the serviceTypes() of this service which
		///  properties a service can have.
		/// <param> name="_name" the name of the property
		/// </param></remarks>		<return> the property, or invalid if not found
		/// </return>
		/// 		<short>    Returns the requested property.</short>
		/// 		<see> KServiceType</see>
		public QVariant Property(string _name) {
			return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), _name);
		}
		/// <remarks>
		///  Returns the requested property.
		/// <param> name="_name" the name of the property
		/// </param><param> name="t" the assumed type of the property
		/// </param></remarks>		<return> the property, or invalid if not found
		/// </return>
		/// 		<short>    Returns the requested property.</short>
		/// 		<see> KServiceType</see>
		public QVariant Property(string _name, QVariant.TypeOf t) {
			return (QVariant) interceptor.Invoke("property$$", "property(const QString&, QVariant::Type) const", typeof(QVariant), typeof(string), _name, typeof(QVariant.TypeOf), t);
		}
		/// <remarks>
		///  Returns the list of all properties that this service can have.
		///  That means, that some of these properties may be empty.
		/// </remarks>		<return> the list of supported properties
		///      </return>
		/// 		<short>    Returns the list of all properties that this service can have.</short>
		public List<string> PropertyNames() {
			return (List<string>) interceptor.Invoke("propertyNames", "propertyNames() const", typeof(List<string>));
		}
		/// <remarks>
		///  Checks whether the service is valid.
		/// </remarks>		<return> true if the service is valid (e.g. name is not empty)
		///      </return>
		/// 		<short>    Checks whether the service is valid.</short>
		[SmokeMethod("isValid() const")]
		public override bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Returns a path that can be used for saving changes to this
		///  service
		/// </remarks>		<return> path that can be used for saving changes to this service
		///      </return>
		/// 		<short>    Returns a path that can be used for saving changes to this  service </short>
		public string LocateLocal() {
			return (string) interceptor.Invoke("locateLocal", "locateLocal() const", typeof(string));
		}
		/// <remarks>
		///  Load the service from a stream.
		///      </remarks>		<short>   </short>
		[SmokeMethod("load(QDataStream&)")]
		public override void Load(QDataStream arg1) {
			interceptor.Invoke("load#", "load(QDataStream&)", typeof(void), typeof(QDataStream), arg1);
		}
		/// <remarks>
		///  Save the service to a stream.
		///      </remarks>		<short>   </short>
		[SmokeMethod("save(QDataStream&)")]
		public override void Save(QDataStream arg1) {
			interceptor.Invoke("save#", "save(QDataStream&)", typeof(void), typeof(QDataStream), arg1);
		}
		/// <remarks>
		///  Set the menu id
		///      </remarks>		<short>   </short>
		public void SetMenuId(string menuId) {
			interceptor.Invoke("setMenuId$", "setMenuId(const QString&)", typeof(void), typeof(string), menuId);
		}
		/// <remarks>
		///  Sets whether to use a terminal or not
		///      </remarks>		<short>   </short>
		public void SetTerminal(bool b) {
			interceptor.Invoke("setTerminal$", "setTerminal(bool)", typeof(void), typeof(bool), b);
		}
		/// <remarks>
		///  Sets the terminal options to use
		///      </remarks>		<short>   </short>
		public void SetTerminalOptions(string options) {
			interceptor.Invoke("setTerminalOptions$", "setTerminalOptions(const QString&)", typeof(void), typeof(string), options);
		}
		protected List<string> AccessServiceTypes() {
			return (List<string>) interceptor.Invoke("accessServiceTypes", "accessServiceTypes()", typeof(List<string>));
		}
		~KService() {
			interceptor.Invoke("~KService", "~KService()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KService", "~KService()", typeof(void));
		}
		/// <remarks>
		///  Find a service by name, i.e. the translated Name field. You should
		///  never use this method with a literal name as argument, since the name
		///  is translated Name field of the desktop file. See serviceByStorageId instead.
		/// <param> name="_name" the name to search
		/// </param></remarks>		<return> a pointer to the requested service or 0 if the service is
		///          unknown.
		///  @em Very @em important: Don't store the result in a KService* !
		///      </return>
		/// 		<short>    Find a service by name, i.</short>
		/// <remarks>
		///  Find a service based on its path as returned by desktopEntryPath().
		///  It's usually better to use serviceByStorageId() instead.
		/// <param> name="_path" the path of the configuration file
		/// </param></remarks>		<return> a pointer to the requested service or 0 if the service is
		///          unknown.
		///  @em Very @em important: Don't store the result in a KService* !
		///      </return>
		/// 		<short>    Find a service based on its path as returned by desktopEntryPath().</short>
		/// <remarks>
		///  Find a service by the name of its desktop file, not depending on
		///  its actual location (as long as it's under the applnk or service
		///  directories). For instance "konqbrowser" or "kcookiejar". Note that
		///  the ".desktop" extension is implicit.
		///  This is the recommended method (safe even if the user moves stuff)
		///  but note that it assumes that no two entries have the same filename.
		/// <param> name="_name" the name of the configuration file
		/// </param></remarks>		<return> a pointer to the requested service or 0 if the service is
		///          unknown.
		///  @em Very @em important: Don't store the result in a KService* !
		///      </return>
		/// 		<short>    Find a service by the name of its desktop file, not depending on  its actual location (as long as it's under the applnk or service  directories).</short>
		/// <remarks>
		///  Find a service by its menu-id
		/// <param> name="_menuId" the menu id of the service
		/// </param></remarks>		<return> a pointer to the requested service or 0 if the service is
		///          unknown.
		///  @em Very @em important: Don't store the result in a KService* !
		///      </return>
		/// 		<short>    Find a service by its menu-id </short>
		/// <remarks>
		///  Find a service by its storage-id or desktop-file path. This
		///  function will try very hard to find a matching service.
		/// <param> name="_storageId" the storage id or desktop-file path of the service
		/// </param></remarks>		<return> a pointer to the requested service or 0 if the service is
		///          unknown.
		///  @em Very @em important: Don't store the result in a KService* !
		///      </return>
		/// 		<short>    Find a service by its storage-id or desktop-file path.</short>
		/// <remarks>
		///  Returns the whole list of services.
		///   Useful for being able to
		///  to display them in a list box, for example.
		///  More memory consuming than the ones above, don't use unless
		///  really necessary.
		/// </remarks>		<return> the list of all services
		///      </return>
		/// 		<short>    Returns the whole list of services.</short>
		public static List<KService> AllServices() {
			return (List<KService>) staticInterceptor.Invoke("allServices", "allServices()", typeof(List<KService>));
		}
		/// <remarks>
		///  Returns a path that can be used to create a new KService based
		///  on <code>suggestedName.</code>
		/// <param> name="showInMenu" true, if the service should be shown in the KDE menu
		///         false, if the service should be hidden from the menu
		/// </param><param> name="suggestedName" name to base the file on, if a service with such
		///         name already exists, a prefix will be added to make it unique.
		/// </param><param> name="menuId" If provided, menuId will be set to the menu id to use for
		///         the KService
		/// </param><param> name="reservedMenuIds" If provided, the path and menu id will be chosen
		///         in such a way that the new menu id does not conflict with any
		///         of the reservedMenuIds
		/// </param></remarks>		<return> The path to use for the new KService.
		///      </return>
		/// 		<short>    Returns a path that can be used to create a new KService based  on <code>suggestedName.</code></short>
		public static string NewServicePath(bool showInMenu, string suggestedName, StringBuilder menuId, List<string> reservedMenuIds) {
			return (string) staticInterceptor.Invoke("newServicePath$$$?", "newServicePath(bool, const QString&, QString*, const QStringList*)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName, typeof(StringBuilder), menuId, typeof(List<string>), reservedMenuIds);
		}
		public static string NewServicePath(bool showInMenu, string suggestedName, StringBuilder menuId) {
			return (string) staticInterceptor.Invoke("newServicePath$$$", "newServicePath(bool, const QString&, QString*)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName, typeof(StringBuilder), menuId);
		}
		public static string NewServicePath(bool showInMenu, string suggestedName) {
			return (string) staticInterceptor.Invoke("newServicePath$$", "newServicePath(bool, const QString&)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName);
		}
		/// <remarks>
		///  This template allows to load the library for the specified service and ask the
		///  factory to create an instance of the given template type.
		/// <param> name="service" The service describing the library to open
		/// </param><param> name="parent" The parent object (see QObject constructor)
		/// </param><param> name="args" A list of string arguments, passed to the factory and possibly
		///              to the component (see KLibFactory)
		/// </param><param> name="error" see KLibLoader
		/// </param></remarks>		<return> A pointer to the newly created object or a null pointer if the
		///          factory was unable to create an object of the given type.
		///      </return>
		/// 		<short>    This template allows to load the library for the specified service and ask the  factory to create an instance of the given template type.</short>
		/// <remarks>
		///  This template allows to create a component from a list of services,
		///  usually coming from a trader query. You probably want to use KServiceTypeTrader instead.
		/// <param> name="begin" The start iterator to the service describing the library to open
		/// </param><param> name="end" The end iterator to the service describing the library to open
		/// </param><param> name="parent" The parent object (see QObject constructor)
		/// </param><param> name="args" A list of string arguments, passed to the factory and possibly
		///              to the component (see KLibFactory)
		/// </param><param> name="error" see KLibLoader
		/// </param></remarks>		<return> A pointer to the newly created object or a null pointer if the
		///          factory was unable to create an object of the given type.
		///      </return>
		/// 		<short>    This template allows to create a component from a list of services,  usually coming from a trader query.</short>
	}
}
