//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  This class holds a KAboutData object or only a component name, a KStandardDirs object and a
	///  KSharedConfig object. Those objects normally are different per component but the same per
	///  instance of one component.
	///  The application component data can always be accessed using KGlobal.MainComponent() (or the
	///  convenience function KGlobal.Dirs() and KGlobal.Config()) while the
	///  component data of the currently active component (mainly used for KParts) can be accessed using
	///  KGlobal.ActiveComponent().
	/// </remarks>		<author> Matthias Kretz <kretz@kde.org>
	///  </author>
	/// 		<short> Per component data. </short>

	[SmokeClass("KComponentData")]
	public class KComponentData : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KComponentData(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KComponentData), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KComponentData() {
			staticInterceptor = new SmokeInvocation(typeof(KComponentData), null);
		}
		public enum MainComponentRegistration {
			RegisterAsMainComponent = 0,
			SkipMainComponentRegistration = 1,
		}
		// const KSharedConfig::Ptr& config(); >>>> NOT CONVERTED
		/// <remarks>
		///  Creates an invalid KComponentData object.
		/// </remarks>		<short>    Creates an invalid KComponentData object.</short>
		/// 		<see> isValid</see>
		public KComponentData() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData", "KComponentData()", typeof(void));
		}
		/// <remarks>
		///  Copy constructor.
		///  It does not copy the data. The data is shared between the old and new objects.
		///      </remarks>		<short>    Copy constructor.</short>
		public KComponentData(KComponentData arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData#", "KComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), arg1);
		}
		/// <remarks>
		///  Returns whether two KComponentData objects reference the same data.
		///      </remarks>		<short>    Returns whether two KComponentData objects reference the same data.</short>
		public override bool Equals(object o) {
			if (!(o is KComponentData)) { return false; }
			return this == (KComponentData) o;
		}
		public override int GetHashCode() {
			return interceptor.GetHashCode();
		}
		/// <remarks>
		///  Constructor.
		/// <param> name="componentName" the name of the component.
		/// </param><param> name="catalogName" the name of the translation catalog;
		///                     if left empty <code>componentName</code> is used
		/// </param><param> name="registerAsMain" whether to register the component as the main component
		///                        of the application. This has no effect, if the application
		///                        already has a main component.
		/// </param></remarks>		<short>    Constructor.</short>
		/// 		<see> KGlobal.MainComponent</see>
		public KComponentData(QByteArray componentName, QByteArray catalogName, KComponentData.MainComponentRegistration registerAsMain) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData##$", "KComponentData(const QByteArray&, const QByteArray&, KComponentData::MainComponentRegistration)", typeof(void), typeof(QByteArray), componentName, typeof(QByteArray), catalogName, typeof(KComponentData.MainComponentRegistration), registerAsMain);
		}
		public KComponentData(QByteArray componentName, QByteArray catalogName) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData##", "KComponentData(const QByteArray&, const QByteArray&)", typeof(void), typeof(QByteArray), componentName, typeof(QByteArray), catalogName);
		}
		public KComponentData(QByteArray componentName) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData#", "KComponentData(const QByteArray&)", typeof(void), typeof(QByteArray), componentName);
		}
		/// <remarks>
		///  Constructor.
		///  A copy of the aboutData object is made.
		/// <param> name="aboutData" data about this component
		/// </param><param> name="registerAsMain" whether to register the component as the main component
		///                        of the application. This has no effect, if the application
		///                        already has a main component.
		/// </param></remarks>		<short>    Constructor.</short>
		/// 		<see> KGlobal.MainComponent</see>
		/// 		<see> KAboutData</see>
		public KComponentData(KAboutData aboutData, KComponentData.MainComponentRegistration registerAsMain) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData#$", "KComponentData(const KAboutData&, KComponentData::MainComponentRegistration)", typeof(void), typeof(KAboutData), aboutData, typeof(KComponentData.MainComponentRegistration), registerAsMain);
		}
		public KComponentData(KAboutData aboutData) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KComponentData#", "KComponentData(const KAboutData&)", typeof(void), typeof(KAboutData), aboutData);
		}
		/// <remarks>
		///  Returns whether this is a valid object.
		///  Don't call any functions on invalid objects, that will crash. Assignment (and of course
		///  destruction) is the only valid operation you may do.
		///      </remarks>		<short>    Returns whether this is a valid object.</short>
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the application standard dirs object.
		/// </remarks>		<return> The KStandardDirs of the application.
		///      </return>
		/// 		<short>    Returns the application standard dirs object.</short>
		public KStandardDirs Dirs() {
			return (KStandardDirs) interceptor.Invoke("dirs", "dirs() const", typeof(KStandardDirs));
		}
		/// <remarks>
		///  Returns the general config object ("appnamerc").
		/// </remarks>		<return> the KConfig object for the component.
		///      </return>
		/// 		<short>    Returns the general config object ("appnamerc").</short>
		/// <remarks>
		///  Returns the about data of this component.
		/// </remarks>		<return> The about data of the component. If none has been set in the
		///          constructor but a component name was set, a default constructed
		///          KAboutData object is returned.
		///      </return>
		/// 		<short>    Returns the about data of this component.</short>
		public KAboutData AboutData() {
			return (KAboutData) interceptor.Invoke("aboutData", "aboutData() const", typeof(KAboutData));
		}
		/// <remarks>
		///  Returns the name of the component.
		/// </remarks>		<return> The component name.
		///      </return>
		/// 		<short>    Returns the name of the component.</short>
		public string ComponentName() {
			return (string) interceptor.Invoke("componentName", "componentName() const", typeof(string));
		}
		/// <remarks>
		///  Returns the name of the translation catalog.
		/// </remarks>		<return> The catalog name.
		///      </return>
		/// 		<short>    Returns the name of the translation catalog.</short>
		public string CatalogName() {
			return (string) interceptor.Invoke("catalogName", "catalogName() const", typeof(string));
		}
		/// <remarks>
		///  Set name of default config file.
		/// <param> name="name" the name of the default config file
		///      </param></remarks>		<short>    Set name of default config file.</short>
		protected void SetConfigName(string name) {
			interceptor.Invoke("setConfigName$", "setConfigName(const QString&)", typeof(void), typeof(string), name);
		}
		~KComponentData() {
			interceptor.Invoke("~KComponentData", "~KComponentData()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KComponentData", "~KComponentData()", typeof(void));
		}
		public static bool operator==(KComponentData lhs, KComponentData arg1) {
			return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KComponentData&) const", typeof(bool), typeof(KComponentData), lhs, typeof(KComponentData), arg1);
		}
		public static bool operator!=(KComponentData lhs, KComponentData arg1) {
			return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KComponentData&) const", typeof(bool), typeof(KComponentData), lhs, typeof(KComponentData), arg1);
		}
	}
}
