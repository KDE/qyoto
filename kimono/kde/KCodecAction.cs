//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	/// <remarks>
	///   This action shows up a submenu with a list of the available codecs on the system.
	///   See <see cref="IKCodecActionSignals"></see> for signals emitted by KCodecAction
	/// </remarks>		<short> Action for selecting one of several QTextCodec. </short>
	[SmokeClass("KCodecAction")]
	public class KCodecAction : KSelectAction, IDisposable {
 		protected KCodecAction(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KCodecAction), this);
		}
		[Q_PROPERTY("QString", "codecName")]
		public string CodecName {
			get { return (string) interceptor.Invoke("currentCodecName", "currentCodecName()", typeof(string)); }
			set { interceptor.Invoke("setCurrentCodec$", "setCurrentCodec(QString)", typeof(void), typeof(string), value); }
		}
		[Q_PROPERTY("int", "codecMib")]
		public int CodecMib {
			get { return (int) interceptor.Invoke("currentCodecMib", "currentCodecMib()", typeof(int)); }
		}
		public KCodecAction(QObject parent, bool showAutoOptions) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction#$", "KCodecAction(QObject*, bool)", typeof(void), typeof(QObject), parent, typeof(bool), showAutoOptions);
		}
		public KCodecAction(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction#", "KCodecAction(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public KCodecAction(string text, QObject parent, bool showAutoOptions) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction$#$", "KCodecAction(const QString&, QObject*, bool)", typeof(void), typeof(string), text, typeof(QObject), parent, typeof(bool), showAutoOptions);
		}
		public KCodecAction(string text, QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction$#", "KCodecAction(const QString&, QObject*)", typeof(void), typeof(string), text, typeof(QObject), parent);
		}
		public KCodecAction(KIcon icon, string text, QObject parent, bool showAutoOptions) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction#$#$", "KCodecAction(const KIcon&, const QString&, QObject*, bool)", typeof(void), typeof(KIcon), icon, typeof(string), text, typeof(QObject), parent, typeof(bool), showAutoOptions);
		}
		public KCodecAction(KIcon icon, string text, QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCodecAction#$#", "KCodecAction(const KIcon&, const QString&, QObject*)", typeof(void), typeof(KIcon), icon, typeof(string), text, typeof(QObject), parent);
		}
		public int MibForName(string codecName, ref bool ok) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(codecName);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(codecName);
#endif
			stack[2].s_bool = ok;
			interceptor.Invoke("mibForName$$", "mibForName(const QString&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			ok = stack[2].s_bool;
			return stack[0].s_int;
		}
		public int MibForName(string codecName) {
			return (int) interceptor.Invoke("mibForName$", "mibForName(const QString&) const", typeof(int), typeof(string), codecName);
		}
		public QTextCodec CodecForMib(int mib) {
			return (QTextCodec) interceptor.Invoke("codecForMib$", "codecForMib(int) const", typeof(QTextCodec), typeof(int), mib);
		}
		public QTextCodec CurrentCodec() {
			return (QTextCodec) interceptor.Invoke("currentCodec", "currentCodec() const", typeof(QTextCodec));
		}
		public bool SetCurrentCodec(QTextCodec codec) {
			return (bool) interceptor.Invoke("setCurrentCodec#", "setCurrentCodec(QTextCodec*)", typeof(bool), typeof(QTextCodec), codec);
		}
		public bool SetCurrentCodec(string codecName) {
			return (bool) interceptor.Invoke("setCurrentCodec$", "setCurrentCodec(const QString&)", typeof(bool), typeof(string), codecName);
		}
		/// <remarks>
		///  Applicable only if showAutoOptions in c'tor was true
		/// </remarks>		<return> KEncodingDetector.None if specific encoding is selected, not autodetection, otherwise... you know it!
		///          </return>
		/// 		<short>    Applicable only if showAutoOptions in c'tor was true </short>
		public KEncodingDetector.AutoDetectScript CurrentAutoDetectScript() {
			return (KEncodingDetector.AutoDetectScript) interceptor.Invoke("currentAutoDetectScript", "currentAutoDetectScript() const", typeof(KEncodingDetector.AutoDetectScript));
		}
		/// <remarks>
		///  Applicable only if showAutoOptions in c'tor was true
		///  KEncodingDetector.SemiautomaticDetection means 'Default' item
		///          </remarks>		<short>    Applicable only if showAutoOptions in c'tor was true </short>
		public bool SetCurrentAutoDetectScript(KEncodingDetector.AutoDetectScript arg1) {
			return (bool) interceptor.Invoke("setCurrentAutoDetectScript$", "setCurrentAutoDetectScript(KEncodingDetector::AutoDetectScript)", typeof(bool), typeof(KEncodingDetector.AutoDetectScript), arg1);
		}
		[Q_SLOT("void actionTriggered(QAction*)")]
		[SmokeMethod("actionTriggered(QAction*)")]
		protected override void ActionTriggered(QAction arg1) {
			interceptor.Invoke("actionTriggered#", "actionTriggered(QAction*)", typeof(void), typeof(QAction), arg1);
		}
		~KCodecAction() {
			interceptor.Invoke("~KCodecAction", "~KCodecAction()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KCodecAction", "~KCodecAction()", typeof(void));
		}
		protected new IKCodecActionSignals Emit {
			get { return (IKCodecActionSignals) Q_EMIT; }
		}
	}

	public interface IKCodecActionSignals : IKSelectActionSignals {
		/// <remarks>
		///  Specific (proper) codec was selected
		///          </remarks>		<short>    Specific (proper) codec was selected          </short>
		[Q_SIGNAL("void triggered(QTextCodec*)")]
		void Triggered(QTextCodec codec);
		/// <remarks>
		///  Specific (proper) codec was selected
		/// </remarks>		<return> codec name
		///          </return>
		/// 		<short>    Specific (proper) codec was selected </short>
		[Q_SIGNAL("void triggered(QString)")]
		void Triggered(string arg1);
		/// <remarks>
		///  Autodetection has been selected.
		///  emits KEncodingDetector.SemiautomaticDetection if Default was selected.
		///  Applicable only if showAutoOptions in c'tor was true
		///          </remarks>		<short>    Autodetection has been selected.</short>
		[Q_SIGNAL("void triggered(KEncodingDetector::AutoDetectScript)")]
		void Triggered(KEncodingDetector.AutoDetectScript arg1);
		/// <remarks>
		///  If showAutoOptions==true, then better handle triggered(KEncodingDetector.AutoDetectScript) signal
		///          </remarks>		<short>    If showAutoOptions==true, then better handle triggered(KEncodingDetector.AutoDetectScript) signal          </short>
		[Q_SIGNAL("void defaultItemTriggered()")]
		void DefaultItemTriggered();
	}
}
