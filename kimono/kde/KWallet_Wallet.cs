//Auto-generated by kalyptus. DO NOT EDIT.
namespace KWallet {
	using Kimono;
	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;
	/// <remarks>
	///  KDE Wallet
	///  This class implements a generic system-wide Wallet for KDE.  This is the
	///  ONLY public interface.
	///  See <see cref="IWalletSignals"></see> for signals emitted by Wallet
	/// </remarks>		<author> George Staikos <staikos@kde.org>
	/// </author>
	/// 		<short> KDE Wallet Class.</short>
	[SmokeClass("KWallet::Wallet")]
	public class Wallet : QObject, IDisposable {
 		protected Wallet(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Wallet), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static Wallet() {
			staticInterceptor = new SmokeInvocation(typeof(Wallet), null);
		}
		public enum EntryType {
			Unknown = 0,
			Password = 1,
			Stream = 2,
			Map = 3,
			Unused = 0xffff,
		}
		public enum OpenType {
			Synchronous = 0,
			Asynchronous = 1,
			Path = 2,
			OpenTypeUnused = 0xff,
		}
		/// <remarks>
		///   This syncs the wallet file on disk with what is in memory.
		///   You don't normally need to use this.  It happens
		///   automatically on close.
		/// </remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     This syncs the wallet file on disk with what is in memory.</short>
		[SmokeMethod("sync()")]
		public virtual int Sync() {
			return (int) interceptor.Invoke("sync", "sync()", typeof(int));
		}
		/// <remarks>
		///   This closes and locks the current wallet.  It will
		///   disconnect all applications using the wallet.
		/// </remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     This closes and locks the current wallet.</short>
		[SmokeMethod("lockWallet()")]
		public virtual int LockWallet() {
			return (int) interceptor.Invoke("lockWallet", "lockWallet()", typeof(int));
		}
		/// <remarks>
		///   The name of the current wallet.
		/// 		 </remarks>		<short>     The name of the current wallet.</short>
		[SmokeMethod("walletName() const")]
		public virtual string WalletName() {
			return (string) interceptor.Invoke("walletName", "walletName() const", typeof(string));
		}
		/// <remarks>
		///   Determine if the current wallet is open, and is a valid
		///   wallet handle.
		/// </remarks>		<return> Returns true if the wallet handle is valid and open.
		/// 		 </return>
		/// 		<short>     Determine if the current wallet is open, and is a valid   wallet handle.</short>
		[SmokeMethod("isOpen() const")]
		public virtual bool IsOpen() {
			return (bool) interceptor.Invoke("isOpen", "isOpen() const", typeof(bool));
		}
		/// <remarks>
		///   Request to the wallet service to change the password of
		///   the current wallet.
		/// <param> name="w" The window id to associate any dialogs with.
		/// 		 </param></remarks>		<short>     Request to the wallet service to change the password of   the current wallet.</short>
		[SmokeMethod("requestChangePassword(WId)")]
		public virtual void RequestChangePassword(uint w) {
			interceptor.Invoke("requestChangePassword$", "requestChangePassword(WId)", typeof(void), typeof(uint), w);
		}
		/// <remarks>
		///   Obtain the list of all folders contained in the wallet.
		/// </remarks>		<return> Returns an empty list if the wallet is not open.
		/// 		 </return>
		/// 		<short>     Obtain the list of all folders contained in the wallet.</short>
		[SmokeMethod("folderList()")]
		public virtual List<string> FolderList() {
			return (List<string>) interceptor.Invoke("folderList", "folderList()", typeof(List<string>));
		}
		/// <remarks>
		///   Determine if the folder <code>f</code> exists in the wallet.
		/// <param> name="f" the name of the folder to check for
		/// </param></remarks>		<return> Returns true if the folder exists in the wallet.
		/// 		 </return>
		/// 		<short>     Determine if the folder <code>f</code> exists in the wallet.</short>
		[SmokeMethod("hasFolder(const QString&)")]
		public virtual bool HasFolder(string f) {
			return (bool) interceptor.Invoke("hasFolder$", "hasFolder(const QString&)", typeof(bool), typeof(string), f);
		}
		/// <remarks>
		///   Set the current working folder to <code>f.</code>  The folder must
		///   exist, or this call will fail.  Create a folder with
		///   createFolder().
		/// <param> name="f" the name of the folder to make the working folder
		/// </param></remarks>		<return> Returns true if the folder was successfully set.
		/// 		 </return>
		/// 		<short>     Set the current working folder to <code>f.</code></short>
		[SmokeMethod("setFolder(const QString&)")]
		public virtual bool SetFolder(string f) {
			return (bool) interceptor.Invoke("setFolder$", "setFolder(const QString&)", typeof(bool), typeof(string), f);
		}
		/// <remarks>
		///   Remove the folder <code>f</code> and all its entries from the wallet.
		/// <param> name="f" the name of the folder to remove
		/// </param></remarks>		<return> Returns true if the folder was successfully removed.
		/// 		 </return>
		/// 		<short>     Remove the folder <code>f</code> and all its entries from the wallet.</short>
		[SmokeMethod("removeFolder(const QString&)")]
		public virtual bool RemoveFolder(string f) {
			return (bool) interceptor.Invoke("removeFolder$", "removeFolder(const QString&)", typeof(bool), typeof(string), f);
		}
		/// <remarks>
		///   Created the folder <code>f.</code>
		/// <param> name="f" the name of the folder to create
		/// </param></remarks>		<return> Returns true if the folder was successfully created.
		/// 		 </return>
		/// 		<short>     Created the folder <code>f.</code></short>
		[SmokeMethod("createFolder(const QString&)")]
		public virtual bool CreateFolder(string f) {
			return (bool) interceptor.Invoke("createFolder$", "createFolder(const QString&)", typeof(bool), typeof(string), f);
		}
		/// <remarks>
		///   Determine the current working folder in the wallet.
		///   If the folder name is empty, it is working in the global
		///   folder, which is valid but discouraged.
		/// </remarks>		<return> Returns the current working folder.
		/// 		 </return>
		/// 		<short>     Determine the current working folder in the wallet.</short>
		[SmokeMethod("currentFolder() const")]
		public virtual string CurrentFolder() {
			return (string) interceptor.Invoke("currentFolder", "currentFolder() const", typeof(string));
		}
		/// <remarks>
		///   Return the list of keys of all entries in this folder.
		/// </remarks>		<return> Returns an empty list if the wallet is not open, or
		///           if the folder is empty.
		/// 		 </return>
		/// 		<short>     Return the list of keys of all entries in this folder.</short>
		[SmokeMethod("entryList()")]
		public virtual List<string> EntryList() {
			return (List<string>) interceptor.Invoke("entryList", "entryList()", typeof(List<string>));
		}
		/// <remarks>
		///   Rename the entry <code>oldName</code> to <code>newName.</code>
		/// <param> name="oldName" The original key of the entry.
		/// </param><param> name="newName" The new key of the entry.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Rename the entry <code>oldName</code> to <code>newName.</code></short>
		[SmokeMethod("renameEntry(const QString&, const QString&)")]
		public virtual int RenameEntry(string oldName, string newName) {
			return (int) interceptor.Invoke("renameEntry$$", "renameEntry(const QString&, const QString&)", typeof(int), typeof(string), oldName, typeof(string), newName);
		}
		/// <remarks>
		///   Read the entry <code>key</code> from the current folder.
		///   The entry format is unknown except that it is either a
		///   QByteArray or a QDataStream, which effectively means that
		///   it is anything.
		/// <param> name="key" The key of the entry to read.
		/// </param><param> name="value" A buffer to fill with the value.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Read the entry <code>key</code> from the current folder.</short>
		[SmokeMethod("readEntry(const QString&, QByteArray&)")]
		public virtual int ReadEntry(string key, QByteArray value) {
			return (int) interceptor.Invoke("readEntry$#", "readEntry(const QString&, QByteArray&)", typeof(int), typeof(string), key, typeof(QByteArray), value);
		}
		/// <remarks>
		///   Read the map entry <code>key</code> from the current folder.
		/// <param> name="key" The key of the entry to read.
		/// </param><param> name="value" A map buffer to fill with the value.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.  Will
		///           return an error if the key was not originally
		///           written as a map.
		/// 		 </return>
		/// 		<short>     Read the map entry <code>key</code> from the current folder.</short>
		[SmokeMethod("readMap(const QString&, QMap<QString, QString>&)")]
		public virtual int ReadMap(string key, Dictionary<string, string> value) {
			return (int) interceptor.Invoke("readMap$?", "readMap(const QString&, QMap<QString, QString>&)", typeof(int), typeof(string), key, typeof(Dictionary<string, string>), value);
		}
		/// <remarks>
		///   Read the password entry <code>key</code> from the current folder.
		/// <param> name="key" The key of the entry to read.
		/// </param><param> name="value" A password buffer to fill with the value.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.  Will
		///           return an error if the key was not originally
		///           written as a password.
		/// 		 </return>
		/// 		<short>     Read the password entry <code>key</code> from the current folder.</short>
		[SmokeMethod("readPassword(const QString&, QString&)")]
		public virtual int ReadPassword(string key, StringBuilder value) {
			return (int) interceptor.Invoke("readPassword$$", "readPassword(const QString&, QString&)", typeof(int), typeof(string), key, typeof(StringBuilder), value);
		}
		/// <remarks>
		///   Read the entries matching <code>key</code> from the current folder.
		///   The entry format is unknown except that it is either a
		///   QByteArray or a QDataStream, which effectively means that
		///   it is anything.
		/// <param> name="key" The key of the entry to read.  Wildcards
		///              are supported.
		/// </param><param> name="value" A buffer to fill with the value.  The key in
		///                the map is the entry key.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Read the entries matching <code>key</code> from the current folder.</short>
		public int ReadEntryList(string key, StringBuilder value) {
			return (int) interceptor.Invoke("readEntryList$?", "readEntryList(const QString&, QMap<QString, QByteArray>&)", typeof(int), typeof(string), key, typeof(StringBuilder), value);
		}
		/// <remarks>
		///   Read the map entry <code>key</code> from the current folder.
		/// <param> name="key" The key of the entry to read.  Wildcards
		///              are supported.
		/// </param><param> name="value" A buffer to fill with the value.  The key in
		///                the map is the entry key.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.  Will
		///           return an error if the key was not originally
		///           written as a map.
		/// 		 </return>
		/// 		<short>     Read the map entry <code>key</code> from the current folder.</short>
		public int ReadMapList(string key, StringBuilder value) {
			return (int) interceptor.Invoke("readMapList$?", "readMapList(const QString&, QMap<QString, QMap<QString, QString> >&)", typeof(int), typeof(string), key, typeof(StringBuilder), value);
		}
		/// <remarks>
		///   Read the password entry <code>key</code> from the current folder.
		/// <param> name="key" The key of the entry to read.  Wildcards
		///              are supported.
		/// </param><param> name="value" A buffer to fill with the value.  The key in
		///                the map is the entry key.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.  Will
		///           return an error if the key was not originally
		///           written as a password.
		/// 		 </return>
		/// 		<short>     Read the password entry <code>key</code> from the current folder.</short>
		public int ReadPasswordList(string key, Dictionary<string, string> value) {
			return (int) interceptor.Invoke("readPasswordList$?", "readPasswordList(const QString&, QMap<QString, QString>&)", typeof(int), typeof(string), key, typeof(Dictionary<string, string>), value);
		}
		/// <remarks>
		///   Write <code>key</code> = <code>value</code> as a binary entry to the current
		///   folder.  Be careful with this, it could cause inconsistency
		///   in the future since you can put an arbitrary entry type in
		///   place.
		/// <param> name="key" The key of the new entry.
		/// </param><param> name="value" The value of the entry.
		/// </param><param> name="entryType" The type of the entry.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Write <code>key</code> = <code>value</code> as a binary entry to the current   folder.</short>
		[SmokeMethod("writeEntry(const QString&, const QByteArray&, KWallet::Wallet::EntryType)")]
		public virtual int WriteEntry(string key, QByteArray value, KWallet.Wallet.EntryType entryType) {
			return (int) interceptor.Invoke("writeEntry$#$", "writeEntry(const QString&, const QByteArray&, KWallet::Wallet::EntryType)", typeof(int), typeof(string), key, typeof(QByteArray), value, typeof(KWallet.Wallet.EntryType), entryType);
		}
		/// <remarks>
		///   Write <code>key</code> = <code>value</code> as a binary entry to the current
		///   folder.
		/// <param> name="key" The key of the new entry.
		/// </param><param> name="value" The value of the entry.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Write <code>key</code> = <code>value</code> as a binary entry to the current   folder.</short>
		[SmokeMethod("writeEntry(const QString&, const QByteArray&)")]
		public virtual int WriteEntry(string key, QByteArray value) {
			return (int) interceptor.Invoke("writeEntry$#", "writeEntry(const QString&, const QByteArray&)", typeof(int), typeof(string), key, typeof(QByteArray), value);
		}
		/// <remarks>
		///   Write <code>key</code> = <code>value</code> as a map to the current folder.
		/// <param> name="key" The key of the new entry.
		/// </param><param> name="value" The value of the map.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Write <code>key</code> = <code>value</code> as a map to the current folder.</short>
		[SmokeMethod("writeMap(const QString&, const QMap<QString, QString>&)")]
		public virtual int WriteMap(string key, Dictionary<string, string> value) {
			return (int) interceptor.Invoke("writeMap$?", "writeMap(const QString&, const QMap<QString, QString>&)", typeof(int), typeof(string), key, typeof(Dictionary<string, string>), value);
		}
		/// <remarks>
		///   Write <code>key</code> = <code>value</code> as a password to the current folder.
		/// <param> name="key" The key of the new entry.
		/// </param><param> name="value" The value of the password.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Write <code>key</code> = <code>value</code> as a password to the current folder.</short>
		[SmokeMethod("writePassword(const QString&, const QString&)")]
		public virtual int WritePassword(string key, string value) {
			return (int) interceptor.Invoke("writePassword$$", "writePassword(const QString&, const QString&)", typeof(int), typeof(string), key, typeof(string), value);
		}
		/// <remarks>
		///   Determine if the current folder has they entry <code>key.</code>
		/// <param> name="key" The key to search for.
		/// </param></remarks>		<return> Returns true if the folder contains <code>key.</code>
		/// 		 </return>
		/// 		<short>     Determine if the current folder has they entry <code>key.</code></short>
		[SmokeMethod("hasEntry(const QString&)")]
		public virtual bool HasEntry(string key) {
			return (bool) interceptor.Invoke("hasEntry$", "hasEntry(const QString&)", typeof(bool), typeof(string), key);
		}
		/// <remarks>
		///   Remove the entry <code>key</code> from the current folder.
		/// <param> name="key" The key to remove.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Remove the entry <code>key</code> from the current folder.</short>
		[SmokeMethod("removeEntry(const QString&)")]
		public virtual int RemoveEntry(string key) {
			return (int) interceptor.Invoke("removeEntry$", "removeEntry(const QString&)", typeof(int), typeof(string), key);
		}
		/// <remarks>
		///   Determine the type of the entry <code>key</code> in this folder.
		/// <param> name="key" The key to look up.
		/// </param></remarks>		<return> Returns an enumerated type representing the type
		///           of the entry.
		/// 		 </return>
		/// 		<short>     Determine the type of the entry <code>key</code> in this folder.</short>
		[SmokeMethod("entryType(const QString&)")]
		public virtual KWallet.Wallet.EntryType entryType(string key) {
			return (KWallet.Wallet.EntryType) interceptor.Invoke("entryType$", "entryType(const QString&)", typeof(KWallet.Wallet.EntryType), typeof(string), key);
		}
		~Wallet() {
			interceptor.Invoke("~Wallet", "~Wallet()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~Wallet", "~Wallet()", typeof(void));
		}
		/// <remarks>
		///   List all the wallets available.
		/// </remarks>		<return> Returns a list of the names of all wallets that are
		///           open.
		/// 		 </return>
		/// 		<short>     List all the wallets available.</short>
		public static List<string> WalletList() {
			return (List<string>) staticInterceptor.Invoke("walletList", "walletList()", typeof(List<string>));
		}
		/// <remarks>
		///   Determine if the KDE wallet is enabled.  Normally you do
		///   not need to use this because openWallet() will just fail.
		/// </remarks>		<return> Returns true if the wallet enabled, else false.
		/// 		 </return>
		/// 		<short>     Determine if the KDE wallet is enabled.</short>
		public static bool IsEnabled() {
			return (bool) staticInterceptor.Invoke("isEnabled", "isEnabled()", typeof(bool));
		}
		/// <remarks>
		///   Determine if the wallet <code>name</code> is open by any application.
		/// <param> name="name" The name of the wallet to check.
		/// </param></remarks>		<return> Returns true if the wallet is open, else false.
		/// 		 </return>
		/// 		<short>     Determine if the wallet <code>name</code> is open by any application.</short>
		public static bool IsOpen(string name) {
			return (bool) staticInterceptor.Invoke("isOpen$", "isOpen(const QString&)", typeof(bool), typeof(string), name);
		}
		/// <remarks>
		///   Close the wallet <code>name.</code>  The wallet will only be closed
		///   if it is open but not in use (rare), or if it is forced
		///   closed.
		/// <param> name="name" The name of the wallet to close.
		/// </param><param> name="force" Set true to force the wallet closed even if it
		///                is in use by others.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Close the wallet <code>name.</code></short>
		public static int CloseWallet(string name, bool force) {
			return (int) staticInterceptor.Invoke("closeWallet$$", "closeWallet(const QString&, bool)", typeof(int), typeof(string), name, typeof(bool), force);
		}
		/// <remarks>
		///   Delete the wallet <code>name.</code>  The wallet will be forced closed
		///   first.
		/// <param> name="name" The name of the wallet to delete.
		/// </param></remarks>		<return> Returns 0 on success, non-zero on error.
		/// 		 </return>
		/// 		<short>     Delete the wallet <code>name.</code></short>
		public static int DeleteWallet(string name) {
			return (int) staticInterceptor.Invoke("deleteWallet$", "deleteWallet(const QString&)", typeof(int), typeof(string), name);
		}
		/// <remarks>
		///   Disconnect the application <code>app</code> from <code>wallet.</code>
		/// <param> name="wallet" The name of the wallet to disconnect.
		/// </param><param> name="app" The name of the application to disconnect.
		/// </param></remarks>		<return> Returns true on success, false on error.
		/// 		 </return>
		/// 		<short>     Disconnect the application <code>app</code> from <code>wallet.</code></short>
		public static bool DisconnectApplication(string wallet, string app) {
			return (bool) staticInterceptor.Invoke("disconnectApplication$$", "disconnectApplication(const QString&, const QString&)", typeof(bool), typeof(string), wallet, typeof(string), app);
		}
		/// <remarks>
		///   Open the wallet <code>name.</code>  The user will be prompted to
		///   allow your application to open the wallet, and may be
		///   prompted for a password.  You are responsible for deleting
		///   this object when you are done with it.
		/// <param> name="name" The name of the wallet to open.
		/// </param><param> name="ot" If Asynchronous, the call will return
		///                immediately with a non-null pointer to an
		///                invalid wallet.  You must immediately connect
		///                the walletOpened() signal to a slot so that
		///                you will know when it is opened, or when it
		///                fails.
		/// </param><param> name="w" The window id to associate any dialogs with.
		/// </param></remarks>		<return> Returns a pointer to the wallet if successful,
		///           or a null pointer on error or if rejected.
		/// 		 </return>
		/// 		<short>     Open the wallet <code>name.</code></short>
		public static KWallet.Wallet OpenWallet(string name, uint w, KWallet.Wallet.OpenType ot) {
			return (KWallet.Wallet) staticInterceptor.Invoke("openWallet$$$", "openWallet(const QString&, WId, KWallet::Wallet::OpenType)", typeof(KWallet.Wallet), typeof(string), name, typeof(uint), w, typeof(KWallet.Wallet.OpenType), ot);
		}
		public static KWallet.Wallet OpenWallet(string name, uint w) {
			return (KWallet.Wallet) staticInterceptor.Invoke("openWallet$$", "openWallet(const QString&, WId)", typeof(KWallet.Wallet), typeof(string), name, typeof(uint), w);
		}
		/// <remarks>
		///   List the applications that are using the wallet <code>wallet.</code>
		/// <param> name="wallet" The wallet to query.
		/// </param></remarks>		<return> Returns a list of all DCOP application IDs using
		///           the wallet.
		/// 		 </return>
		/// 		<short>     List the applications that are using the wallet <code>wallet.</code></short>
		public static List<string> Users(string wallet) {
			return (List<string>) staticInterceptor.Invoke("users$", "users(const QString&)", typeof(List<string>), typeof(string), wallet);
		}
		/// <remarks>
		///   The name of the wallet used to store local passwords.
		/// 		 </remarks>		<short>     The name of the wallet used to store local passwords.</short>
		public static string LocalWallet() {
			return (string) staticInterceptor.Invoke("LocalWallet", "LocalWallet()", typeof(string));
		}
		/// <remarks>
		///   The name of the wallet used to store network passwords.
		/// 		 </remarks>		<short>     The name of the wallet used to store network passwords.</short>
		public static string NetworkWallet() {
			return (string) staticInterceptor.Invoke("NetworkWallet", "NetworkWallet()", typeof(string));
		}
		/// <remarks>
		///   The standardized name of the password folder.
		///   It is automatically created when a wallet is created, but
		///   the user may still delete it so you should check for its
		///   existence and recreate it if necessary and desired.
		/// 		 </remarks>		<short>     The standardized name of the password folder.</short>
		public static string PasswordFolder() {
			return (string) staticInterceptor.Invoke("PasswordFolder", "PasswordFolder()", typeof(string));
		}
		/// <remarks>
		///   The standardized name of the form data folder.
		///   It is automatically created when a wallet is created, but
		///   the user may still delete it so you should check for its
		///   existence and recreate it if necessary and desired.
		/// 		 </remarks>		<short>     The standardized name of the form data folder.</short>
		public static string FormDataFolder() {
			return (string) staticInterceptor.Invoke("FormDataFolder", "FormDataFolder()", typeof(string));
		}
		/// <remarks>
		///   Request to the wallet service to change the password of
		///   the wallet <code>name.</code>
		/// <param> name="name" The the wallet to change the password of.
		/// </param><param> name="w" The window id to associate any dialogs with.
		/// 		 </param></remarks>		<short>     Request to the wallet service to change the password of   the wallet <code>name.</code></short>
		public static void ChangePassword(string name, uint w) {
			staticInterceptor.Invoke("changePassword$$", "changePassword(const QString&, WId)", typeof(void), typeof(string), name, typeof(uint), w);
		}
		/// <remarks>
		///   Determine if a folder does not exist in a wallet.  This
		///   does not require decryption of the wallet.
		///   This is a handy optimization to avoid prompting the user
		///   if your data is certainly not in the wallet.
		/// <param> name="wallet" The wallet to look in.
		/// </param><param> name="folder" The folder to look up.
		/// </param></remarks>		<return> Returns true if the folder does NOT exist in the
		///   wallet, or the wallet does not exist.
		/// 		 </return>
		/// 		<short>     Determine if a folder does not exist in a wallet.</short>
		public static bool FolderDoesNotExist(string wallet, string folder) {
			return (bool) staticInterceptor.Invoke("folderDoesNotExist$$", "folderDoesNotExist(const QString&, const QString&)", typeof(bool), typeof(string), wallet, typeof(string), folder);
		}
		/// <remarks>
		///   Determine if an entry in a folder does not exist in a
		///   wallet.  This does not require decryption of the wallet.
		///   This is a handy optimization to avoid prompting the user
		///   if your data is certainly not in the wallet.
		/// <param> name="wallet" The wallet to look in.
		/// </param><param> name="folder" The folder to look in.
		/// </param><param> name="key" The key to look up.
		/// </param></remarks>		<return> Returns true if the key does NOT exist in the
		///   wallet, or the folder or wallet does not exist.
		/// 		 </return>
		/// 		<short>     Determine if an entry in a folder does not exist in a   wallet.</short>
		public static bool KeyDoesNotExist(string wallet, string folder, string key) {
			return (bool) staticInterceptor.Invoke("keyDoesNotExist$$$", "keyDoesNotExist(const QString&, const QString&, const QString&)", typeof(bool), typeof(string), wallet, typeof(string), folder, typeof(string), key);
		}
		protected new IWalletSignals Emit {
			get { return (IWalletSignals) Q_EMIT; }
		}
	}

	public interface IWalletSignals : IQObjectSignals {
		/// <remarks>
		///   Emitted when this wallet is closed.
		/// 		 </remarks>		<short>     Emitted when this wallet is closed.</short>
		[Q_SIGNAL("void walletClosed()")]
		void WalletClosed();
		/// <remarks>
		///   Emitted when a folder in this wallet is updated.
		/// <param> name="folder" The folder that was updated.
		/// 		 </param></remarks>		<short>     Emitted when a folder in this wallet is updated.</short>
		[Q_SIGNAL("void folderUpdated(const QString&)")]
		void FolderUpdated(string folder);
		/// <remarks>
		///   Emitted when the folder list is changed in this wallet.
		/// 		 </remarks>		<short>     Emitted when the folder list is changed in this wallet.</short>
		[Q_SIGNAL("void folderListUpdated()")]
		void FolderListUpdated();
		/// <remarks>
		///   Emitted when a folder in this wallet is removed.
		/// <param> name="folder" The folder that was removed.
		/// 		 </param></remarks>		<short>     Emitted when a folder in this wallet is removed.</short>
		[Q_SIGNAL("void folderRemoved(const QString&)")]
		void FolderRemoved(string folder);
		/// <remarks>
		///   Emitted when a wallet is opened in asynchronous mode.
		/// <param> name="success" True if the wallet was opened successfully.
		/// 		 </param></remarks>		<short>     Emitted when a wallet is opened in asynchronous mode.</short>
		[Q_SIGNAL("void walletOpened(bool)")]
		void WalletOpened(bool success);
	}
}
