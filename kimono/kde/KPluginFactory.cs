//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  \class KPluginFactory kpluginfactory.h <KPluginFactory>
	///  If you develop a library that is to be loaded dynamically at runtime, then
	///  you should return a pointer to a KPluginFactory.
	///  For most cases it is enough to use the K_PLUGIN_FACTORY macro to create the factory.
	///  Example:
	///  <pre>
	///  #include <KPluginFactory>
	///  #include <KPluginLoader>
	///  #include <plugininterface.h>
	///  class MyPlugin;
	///  K_PLUGIN_FACTORY(MyPluginFactory,
	///                   registerPlugin<MyPlugin>();
	///                  )
	///  K_EXPORT_PLUGIN(MyPluginFactory("componentName"))
	///  class MyPlugin : public PluginInterface
	///  {
	///      ...
	///      KComponentData kcd = MyPluginFactory.ComponentData();
	///      ...
	///  }
	///  </pre>
	///  K_PLUGIN_FACTORY is a convenient macro that expands to a class derived from KPluginFactory
	///  providing two constructors and a static componentData() function. The second argument to
	///  K_PLUGIN_FACTORY is code that is called from the constructors. There you can use registerPlugin
	///  to register as many plugins for the factory as you want to.
	///  If you want to write a custom KPluginFactory not using the standard macro(s) you can reimplement
	///  the create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
	///  function.
	///  Example:
	///  <pre>
	///  class SomeScriptLanguageFactory : public KPluginFactory
	///  {
	///       public      SomeScriptLanguageFactory()
	///      {}
	///  protected:
	///      QObject create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
	///      {
	///          string identifier = QLatin1String(iface) + QLatin1Char('_') + keyword;
	///          // load scripting language module from the information in identifier
	///          // and return it:
	///          return object;
	///      }
	///  }
	///  </pre>
	///  If you want to load a library use KPluginLoader.
	///  The application that wants to instantiate plugin classes can do the following:
	///  <pre>
	///  KPluginFactory factory = KPluginLoader("libraryname").factory();
	///  if (factory) {
	///      PluginInterface p1 = factory.Create<PluginInterface>(parent);
	///      OtherInterface p2  = factory.Create<OtherInterface>(parent);
	///      NextInterface p3   = factory.Create<NextInterface>("keyword1", parent);
	///      NextInterface p3   = factory.Create<NextInterface>("keyword2", parent);
	///  }
	///  </pre>
	///  \author Matthias Kretz <kretz@kde.org>
	///  \author Bernhard Loos <nhuh.put@web.de>
	///   See <see cref="IKPluginFactorySignals"></see> for signals emitted by KPluginFactory
	/// </remarks>		<short>    \class KPluginFactory kpluginfactory.</short>

	[SmokeClass("KPluginFactory")]
	public class KPluginFactory : QObject, IDisposable {
 		protected KPluginFactory(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KPluginFactory), this);
		}
		// KPluginFactory* KPluginFactory(const char* arg1,const char* arg2,QObject* arg3); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const char* arg1,const char* arg2); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const char* arg1); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const KAboutData& arg1,QObject* arg2); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const KAboutData& arg1); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(KPluginFactoryPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(KPluginFactoryPrivate& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  This constructor creates a factory for a plugin with the given <pre>componentName</pre> and
		///  <pre>catalogName</pre>. Those values are used to initialize a KComponentData object for the plugin.
		///  You can later access it with componentData(). If <pre>componentName</pre> is 0, an invalid KComponentData
		///  object will be created.
		///  \param componentName the component name of the plugin
		///  \param catalogName the translation catalog to use
		///  \param parent a parent object
		///      </remarks>		<short>    This constructor creates a factory for a plugin with the given \p componentName and  \p catalogName.</short>
		/// <remarks>
		///  This constructor creates a factory for a plugin with the given KAboutData object. This object is
		///  used to initialize a KComponentData object for the plugin. You can later access it with
		///  componentData().
		///  KPluginFactory takes ownership of the <pre>aboutData</pre> object, so don't delete it yourself!
		///  \param aboutData the KAboutData for the plugin
		///  \param parent a parent object
		///      </remarks>		<short>    This constructor creates a factory for a plugin with the given KAboutData object.</short>
		/// <remarks>
		///  You can use this method to get the component data of the plugin. It is filled with the
		///  information given to the constructor of KPluginFactory.
		///  The K_PLUGIN_FACTORY macros provide a static version of this method, this can be used from
		///  any place within the plugin.
		///  \returns The KComponentData for the plugin
		///      </remarks>		<short>    You can use this method to get the component data of the plugin.</short>
		public KComponentData ComponentData() {
			return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
		}
		/// <remarks>
		///  Function pointer type to a function that instantiates a plugin.
		///      </remarks>		<short>    Function pointer type to a function that instantiates a plugin.</short>
		/// <remarks>
		///  \internal
		///  Converts a List<string> to a QVariantList
		///      </remarks>		<short>    \internal  Converts a List<string> to a QVariantList      </short>
		protected List<QVariant> StringListToVariantList(List<string> list) {
			return (List<QVariant>) interceptor.Invoke("stringListToVariantList?", "stringListToVariantList(const QStringList&)", typeof(List<QVariant>), typeof(List<string>), list);
		}
		/// <remarks>
		///  \internal
		///  Converts a QVariantList of strings to a List<string>
		///      </remarks>		<short>    \internal  Converts a QVariantList of strings to a List<string>      </short>
		protected List<string> VariantListToStringList(List<QVariant> list) {
			return (List<string>) interceptor.Invoke("variantListToStringList?", "variantListToStringList(const QVariantList&)", typeof(List<string>), typeof(List<QVariant>), list);
		}
		[SmokeMethod("setupTranslations()")]
		protected virtual void SetupTranslations() {
			interceptor.Invoke("setupTranslations", "setupTranslations()", typeof(void));
		}
		/// <remarks>
		///  This method sets the component data of the plugin. You can access the component data object
		///  later with componentData().
		///  Normally you don't have to call this, because the factory constructs a component data object
		///  from the information given to the constructor.
		///  The object is destroyed, when the module containing the plugin is unloaded. Normally this happens
		///  only on application shutdown.
		///  \param componentData the new KComponentData object
		///      </remarks>		<short>    This method sets the component data of the plugin.</short>
		protected void SetComponentData(KComponentData componentData) {
			interceptor.Invoke("setComponentData#", "setComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
		}
		/// <remarks>
		///  This function is called when the factory asked to create an Object.
		///  You may reimplement it to provide a very flexible factory. This is especially useful to
		///  provide generic factories for plugins implemeted using a scripting language.
		///  \param iface The staticMetaObject.ClassName() string identifying the plugin interface that
		///  was requested. E.g. for KCModule plugins this string will be "KCModule".
		///  \param parentWidget Only used if the requested plugin is a KPart.
		///  \param parent The parent object for the plugin object.
		///  \param args A plugin specific list of arbitrary arguments.
		///  \param keyword A string that uniquely identifies the plugin. If a KService is used this
		///  keyword is read from the X-KDE-PluginKeyword entry in the .desktop file.
		///      </remarks>		<short>    This function is called when the factory asked to create an Object.</short>
		[SmokeMethod("create(const char*, QWidget*, QObject*, const QVariantList&, const QString&)")]
		protected virtual QObject Create(string iface, QWidget parentWidget, QObject parent, List<QVariant> args, string keyword) {
			return (QObject) interceptor.Invoke("create$##?$", "create(const char*, QWidget*, QObject*, const QVariantList&, const QString&)", typeof(QObject), typeof(string), iface, typeof(QWidget), parentWidget, typeof(QObject), parent, typeof(List<QVariant>), args, typeof(string), keyword);
		}
		~KPluginFactory() {
			interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
		}
		protected new IKPluginFactorySignals Emit {
			get { return (IKPluginFactorySignals) Q_EMIT; }
		}
	}

	public interface IKPluginFactorySignals : IQObjectSignals {
		[Q_SIGNAL("void objectCreated(QObject*)")]
		void ObjectCreated(QObject arg1);
	}
}
