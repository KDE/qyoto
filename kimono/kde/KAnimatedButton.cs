//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	/// <remarks>
	///  This widget extends QToolButton with the ability to display animation
	///  using a sequence of individual pixmaps.  All you need to do is pass along
	///  a list of icon names and their size and everything else is taken
	///  care of.
	///  <b>Note:<> if you change the iconSize() via setIconSize(), you will need to call
	///        updateIcons() also to force reloading of the correct icon size.
	///  See <see cref="IKAnimatedButtonSignals"></see> for signals emitted by KAnimatedButton
	/// </remarks>		<author> Kurt Granroth <granroth@kde.org>
	///  </author>
	/// 		<short> An extended version of QToolButton which can display an animated icon. </short>
	[SmokeClass("KAnimatedButton")]
	public class KAnimatedButton : QToolButton, IDisposable {
 		protected KAnimatedButton(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KAnimatedButton), this);
		}
		[Q_PROPERTY("QString", "icons")]
		public string Icons {
			get { return (string) interceptor.Invoke("icons", "icons()", typeof(string)); }
			set { interceptor.Invoke("setIcons$", "setIcons(QString)", typeof(void), typeof(string), value); }
		}
		/// <remarks>
		///  Construct an animated tool button.
		/// <param> name="parent" The parent widget
		///    </param></remarks>		<short>    Construct an animated tool button.</short>
		public KAnimatedButton(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KAnimatedButton#", "KAnimatedButton(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KAnimatedButton() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KAnimatedButton", "KAnimatedButton()", typeof(void));
		}
		/// <remarks>
		///  Returns the current maximum dimension (width or length) for an icon.
		///    </remarks>		<short>    Returns the current maximum dimension (width or length) for an icon.</short>
		public int IconDimensions() {
			return (int) interceptor.Invoke("iconDimensions", "iconDimensions() const", typeof(int));
		}
		/// <remarks>
		///  Starts the animation from frame 1
		///    </remarks>		<short>    Starts the animation from frame 1    </short>
		[Q_SLOT("void start()")]
		public void Start() {
			interceptor.Invoke("start", "start()", typeof(void));
		}
		/// <remarks>
		///  Stops the animation.  This will also reset the widget to frame 1.
		///    </remarks>		<short>    Stops the animation.</short>
		[Q_SLOT("void stop()")]
		public void Stop() {
			interceptor.Invoke("stop", "stop()", typeof(void));
		}
		/// <remarks>
		///  Updates the icons by reloading them if required.
		///  You must call this after you change the icon size, in order for the correct
		///  size icon to be loaded.
		///    </remarks>		<short>    Updates the icons by reloading them if required.</short>
		[Q_SLOT("void updateIcons()")]
		public void UpdateIcons() {
			interceptor.Invoke("updateIcons", "updateIcons()", typeof(void));
		}
		[Q_SLOT("void slotTimerUpdate()")]
		protected void SlotTimerUpdate() {
			interceptor.Invoke("slotTimerUpdate", "slotTimerUpdate()", typeof(void));
		}
		~KAnimatedButton() {
			interceptor.Invoke("~KAnimatedButton", "~KAnimatedButton()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KAnimatedButton", "~KAnimatedButton()", typeof(void));
		}
		protected new IKAnimatedButtonSignals Emit {
			get { return (IKAnimatedButtonSignals) Q_EMIT; }
		}
	}

	public interface IKAnimatedButtonSignals : IQToolButtonSignals {
		[Q_SIGNAL("void clicked()")]
		void Clicked();
	}
}
