//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  A group of bookmarks
	///  </remarks>		<short>    A group of bookmarks  </short>

	[SmokeClass("KBookmarkGroup")]
	public class KBookmarkGroup : KBookmark, IDisposable {
 		protected KBookmarkGroup(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocationKDE(typeof(KBookmarkGroup), this);
		}
		/// <remarks>
		///  Create an invalid group. This is mostly for use in QValueList,
		///  and other places where we need a null group.
		///  Also used as a parent for a bookmark that doesn't have one
		///  (e.g. Netscape bookmarks)
		///      </remarks>		<short>    Create an invalid group.</short>
		public KBookmarkGroup() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KBookmarkGroup", "KBookmarkGroup()", typeof(void));
		}
		/// <remarks>
		///  Create a bookmark group as specified by the given element
		///      </remarks>		<short>    Create a bookmark group as specified by the given element      </short>
		public KBookmarkGroup(QDomElement elem) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KBookmarkGroup#", "KBookmarkGroup(const QDomElement&)", typeof(void), typeof(QDomElement), elem);
		}
		/// <remarks>
		/// </remarks>		<return> true if the bookmark folder is opened in the bookmark editor
		///      </return>
		/// 		<short>   </short>
		public bool IsOpen() {
			return (bool) interceptor.Invoke("isOpen", "isOpen() const", typeof(bool));
		}
		/// <remarks>
		///  Return the first child bookmark of this group
		///      </remarks>		<short>    Return the first child bookmark of this group      </short>
		public KBookmark First() {
			return (KBookmark) interceptor.Invoke("first", "first() const", typeof(KBookmark));
		}
		/// <remarks>
		///  Return the prevous sibling of a child bookmark of this group
		/// <param> name="current" has to be one of our child bookmarks.
		///      </param></remarks>		<short>    Return the prevous sibling of a child bookmark of this group </short>
		public KBookmark Previous(KBookmark current) {
			return (KBookmark) interceptor.Invoke("previous#", "previous(const KBookmark&) const", typeof(KBookmark), typeof(KBookmark), current);
		}
		/// <remarks>
		///  Return the next sibling of a child bookmark of this group
		/// <param> name="current" has to be one of our child bookmarks.
		///      </param></remarks>		<short>    Return the next sibling of a child bookmark of this group </short>
		public KBookmark Next(KBookmark current) {
			return (KBookmark) interceptor.Invoke("next#", "next(const KBookmark&) const", typeof(KBookmark), typeof(KBookmark), current);
		}
		/// <remarks>
		///  Return the index of a child bookmark, -1 if not found
		///      </remarks>		<short>    Return the index of a child bookmark, -1 if not found      </short>
		public int IndexOf(KBookmark child) {
			return (int) interceptor.Invoke("indexOf#", "indexOf(const KBookmark&) const", typeof(int), typeof(KBookmark), child);
		}
		/// <remarks>
		///  Create a new bookmark folder, as the last child of this group
		/// <param> name="text" for the folder.
		///  If you want an dialog use KBookmarkDialog
		///      </param></remarks>		<short>    Create a new bookmark folder, as the last child of this group </short>
		public KBookmarkGroup CreateNewFolder(string text) {
			return (KBookmarkGroup) interceptor.Invoke("createNewFolder$", "createNewFolder(const QString&)", typeof(KBookmarkGroup), typeof(string), text);
		}
		/// <remarks>
		///  Create a new bookmark separator
		///  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );
		///      </remarks>		<short>    Create a new bookmark separator  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );      </short>
		public KBookmark CreateNewSeparator() {
			return (KBookmark) interceptor.Invoke("createNewSeparator", "createNewSeparator()", typeof(KBookmark));
		}
		/// <remarks>
		///  Create a new bookmark, as the last child of this group
		///  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );
		/// <param> name="bm" the bookmark to add
		///      </param></remarks>		<short>    Create a new bookmark, as the last child of this group  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark ); </short>
		public KBookmark AddBookmark(KBookmark bm) {
			return (KBookmark) interceptor.Invoke("addBookmark#", "addBookmark(const KBookmark&)", typeof(KBookmark), typeof(KBookmark), bm);
		}
		/// <remarks>
		///  Create a new bookmark, as the last child of this group
		///  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );
		/// <param> name="text" for the bookmark
		/// </param><param> name="url" the URL that the bookmark points to
		/// </param><param> name="icon" the name of the icon to associate with the bookmark. A suitable default
		///  will be determined from the URL if not specified.
		///      </param></remarks>		<short>    Create a new bookmark, as the last child of this group  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark ); </short>
		public KBookmark AddBookmark(string text, KUrl url, string icon) {
			return (KBookmark) interceptor.Invoke("addBookmark$#$", "addBookmark(const QString&, const KUrl&, const QString&)", typeof(KBookmark), typeof(string), text, typeof(KUrl), url, typeof(string), icon);
		}
		public KBookmark AddBookmark(string text, KUrl url) {
			return (KBookmark) interceptor.Invoke("addBookmark$#", "addBookmark(const QString&, const KUrl&)", typeof(KBookmark), typeof(string), text, typeof(KUrl), url);
		}
		/// <remarks>
		///  Moves <code>bookmark</code> after <code>after</code> (which should be a child of ours).
		///  If after is null, <code>bookmark</code> is moved as the first child.
		///  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );
		///      </remarks>		<short>    Moves <code>bookmark</code> after <code>after</code> (which should be a child of ours).</short>
		public bool MoveBookmark(KBookmark bookmark, KBookmark after) {
			return (bool) interceptor.Invoke("moveBookmark##", "moveBookmark(const KBookmark&, const KBookmark&)", typeof(bool), typeof(KBookmark), bookmark, typeof(KBookmark), after);
		}
		/// <remarks>
		///  Delete a bookmark - it has to be one of our children !
		///  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );
		///      </remarks>		<short>    Delete a bookmark - it has to be one of our children !  Don't forget to use KBookmarkManager.Self().EmitChanged( parentBookmark );      </short>
		public void DeleteBookmark(KBookmark bk) {
			interceptor.Invoke("deleteBookmark#", "deleteBookmark(const KBookmark&)", typeof(void), typeof(KBookmark), bk);
		}
		/// <remarks>
		/// </remarks>		<return> true if this is the toolbar group
		///      </return>
		/// 		<short>   </short>
		public bool IsToolbarGroup() {
			return (bool) interceptor.Invoke("isToolbarGroup", "isToolbarGroup() const", typeof(bool));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public QDomElement FindToolbar() {
			return (QDomElement) interceptor.Invoke("findToolbar", "findToolbar() const", typeof(QDomElement));
		}
		/// <remarks>
		/// </remarks>		<return> the list of urls of bookmarks at top level of the group
		///      </return>
		/// 		<short>   </short>
		public List<KUrl> GroupUrlList() {
			return (List<KUrl>) interceptor.Invoke("groupUrlList", "groupUrlList() const", typeof(List<KUrl>));
		}
		protected QDomElement NextKnownTag(QDomElement start, bool goNext) {
			return (QDomElement) interceptor.Invoke("nextKnownTag#$", "nextKnownTag(const QDomElement&, bool) const", typeof(QDomElement), typeof(QDomElement), start, typeof(bool), goNext);
		}
		~KBookmarkGroup() {
			interceptor.Invoke("~KBookmarkGroup", "~KBookmarkGroup()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KBookmarkGroup", "~KBookmarkGroup()", typeof(void));
		}
	}
}
