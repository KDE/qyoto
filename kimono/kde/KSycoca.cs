//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  Read-only SYstem COnfiguration CAche
	///   See <see cref="IKSycocaSignals"></see> for signals emitted by KSycoca
	/// </remarks>		<short>   </short>

	[SmokeClass("KSycoca")]
	public class KSycoca : QObject, IDisposable {
 		protected KSycoca(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KSycoca), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KSycoca() {
			staticInterceptor = new SmokeInvocation(typeof(KSycoca), null);
		}
		// void addFactory(KSycocaFactory* arg1); >>>> NOT CONVERTED
		// KSycocaFactoryList* factories(); >>>> NOT CONVERTED
		/// <remarks>
		///  Read-only database
		///     </remarks>		<short>    Read-only database     </short>
		public KSycoca() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSycoca", "KSycoca()", typeof(void));
		}
		/// <remarks>
		///  This is how factories get a stream to an entry
		///     </remarks>		<short>   </short>
		public QDataStream FindEntry(int offset, int type) {
			return (QDataStream) interceptor.Invoke("findEntry$?", "findEntry(int, KSycocaType&)", typeof(QDataStream), typeof(int), offset, typeof(int), type);
		}
		/// <remarks>
		///     </remarks>		<short>   </short>
		public QDataStream FindFactory(int id) {
			return (QDataStream) interceptor.Invoke("findFactory?", "findFactory(KSycocaFactoryId)", typeof(QDataStream), typeof(int), id);
		}
		/// <remarks>
		///     </remarks>		<short>   </short>
		public string Kfsstnd_prefixes() {
			return (string) interceptor.Invoke("kfsstnd_prefixes", "kfsstnd_prefixes()", typeof(string));
		}
		/// <remarks>
		///     </remarks>		<short>   </short>
		public string Language() {
			return (string) interceptor.Invoke("language", "language()", typeof(string));
		}
		/// <remarks>
		///  The database contains all changes made _before_ this time and
		///  _might_ contain changes made after that.
		///     </remarks>		<short>   </short>
		public uint TimeStamp() {
			return (uint) interceptor.Invoke("timeStamp", "timeStamp()", typeof(uint));
		}
		/// <remarks>
		///  Signature that keeps track of changes to
		///  $KDEDIR/share/services/update_ksycoca
		///  Touching this file causes the database to be recreated
		///  from scratch.
		///     </remarks>		<short>   </short>
		public uint UpdateSignature() {
			return (uint) interceptor.Invoke("updateSignature", "updateSignature()", typeof(uint));
		}
		/// <remarks>
		///  stored inside sycoca.
		///     </remarks>		<short>   </short>
		public List<string> AllResourceDirs() {
			return (List<string>) interceptor.Invoke("allResourceDirs", "allResourceDirs()", typeof(List<string>));
		}
		/// <remarks>
		///     </remarks>		<short>   </short>
		/// <remarks>
		/// </remarks>		<return> true if building (i.e. if a KBuildSycoca);
		///     </return>
		/// 		<short>   </short>
		[SmokeMethod("isBuilding()")]
		public virtual bool IsBuilding() {
			return (bool) interceptor.Invoke("isBuilding", "isBuilding()", typeof(bool));
		}
		/// <remarks>
		///     </remarks>		<short>   </short>
		public void DisableAutoRebuild() {
			interceptor.Invoke("disableAutoRebuild", "disableAutoRebuild()", typeof(void));
		}
		/// <remarks>
		///  Building database
		///     </remarks>		<short>   </short>
		public KSycoca(bool arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSycoca$", "KSycoca(bool)", typeof(void), typeof(bool), arg1);
		}
		~KSycoca() {
			interceptor.Invoke("~KSycoca", "~KSycoca()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KSycoca", "~KSycoca()", typeof(void));
		}
		/// <remarks>
		///  Get or create the only instance of KSycoca (read-only)
		///     </remarks>		<short>    Get or create the only instance of KSycoca (read-only)     </short>
		public static KSycoca Self() {
			return (KSycoca) staticInterceptor.Invoke("self", "self()", typeof(KSycoca));
		}
		/// <remarks>
		/// </remarks>		<return> the compiled-in version, i.e. the one used when writing a new ksycoca
		///     </return>
		/// 		<short>   </short>
		public static int Version() {
			return (int) staticInterceptor.Invoke("version", "version()", typeof(int));
		}
		/// <remarks>
		/// </remarks>		<return> true if the ksycoca database is available
		///  This is usually the case, except if KDE isn't installed yet,
		///  or before kded is started.
		///     </return>
		/// 		<short>   </short>
		public static bool IsAvailable() {
			return (bool) staticInterceptor.Invoke("isAvailable", "isAvailable()", typeof(bool));
		}
		/// <remarks>
		///  When you receive a "databaseChanged" signal, you can query here if
		///  a change has occurred in a specific resource type.
		/// </remarks>		<short>    When you receive a "databaseChanged" signal, you can query here if  a change has occurred in a specific resource type.</short>
		/// 		<see> KStandardDirs</see>
		/// 		<see> for</see>
		/// 		<see> the</see>
		/// 		<see> various</see>
		/// 		<see> resource</see>
		/// 		<see> types.</see>
		public static bool IsChanged(string type) {
			return (bool) staticInterceptor.Invoke("isChanged$", "isChanged(const char*)", typeof(bool), typeof(string), type);
		}
		/// <remarks>
		///  A read error occurs.
		///     </remarks>		<short>    A read error occurs.</short>
		public static void FlagError() {
			staticInterceptor.Invoke("flagError", "flagError()", typeof(void));
		}
		/// <remarks>
		///  Returns read error status and clears flag.
		///     </remarks>		<short>    Returns read error status and clears flag.</short>
		public static bool ReadError() {
			return (bool) staticInterceptor.Invoke("readError", "readError()", typeof(bool));
		}
		protected new IKSycocaSignals Emit {
			get { return (IKSycocaSignals) Q_EMIT; }
		}
	}

	public interface IKSycocaSignals : IQObjectSignals {
		/// <remarks>
		///  Connect to this to get notified when the database changes
		///  (Usually apps showing icons do a 'refresh' to take into account the new mimetypes)
		///     </remarks>		<short>    Connect to this to get notified when the database changes  (Usually apps showing icons do a 'refresh' to take into account the new mimetypes)     </short>
		[Q_SIGNAL("void databaseChanged()")]
		void DatabaseChanged();
	}
}
