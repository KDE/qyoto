//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  This class helps applications implement support for KDataTool.
	///  The steps to follow are simple:
	/// 
	/// <li>
	/// query for the available tools using KDataToolInfo.Query
	/// </li>
	/// 
	/// <li>
	/// pass the result to KDataToolAction.DataToolActionList (with a slot)
	/// </li>
	/// 
	/// <li>
	/// plug the resulting actions, either using KXMLGUIClient.PlugActionList, or by hand.
	/// </li>
	///  The slot defined for step 2 is called when the action is activated, and
	///  that's where the tool should be created and run.
	///   See <see cref="IKDataToolActionSignals"></see> for signals emitted by KDataToolAction
	/// </remarks>		<short>    This class helps applications implement support for KDataTool.</short>

	[SmokeClass("KDataToolAction")]
	public class KDataToolAction : KAction, IDisposable {
 		protected KDataToolAction(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KDataToolAction), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KDataToolAction() {
			staticInterceptor = new SmokeInvocation(typeof(KDataToolAction), null);
		}
		/// <remarks>
		///  Constructs a new KDataToolAction.
		/// <param> name="text" The text that will be displayed
		/// </param><param> name="info" The corresponding KDataToolInfo
		/// </param><param> name="command" The command of the action
		/// </param><param> name="parent" This action's parent
		/// </param><param> name="name" The name of the action
		///      </param></remarks>		<short>    Constructs a new KDataToolAction.</short>
		public KDataToolAction(string text, KDataToolInfo info, string command, QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KDataToolAction$#$#", "KDataToolAction(const QString&, const KDataToolInfo&, const QString&, QObject*)", typeof(void), typeof(string), text, typeof(KDataToolInfo), info, typeof(string), command, typeof(QObject), parent);
		}
		[SmokeMethod("slotActivated()")]
		protected virtual void SlotActivated() {
			interceptor.Invoke("slotActivated", "slotActivated()", typeof(void));
		}
		~KDataToolAction() {
			interceptor.Invoke("~KDataToolAction", "~KDataToolAction()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KDataToolAction", "~KDataToolAction()", typeof(void));
		}
		/// <remarks>
		///  Creates a list of actions from a list of information about data-tools.
		///  The slot must have a signature corresponding to the toolActivated signal.
		///  Note that it's the caller's responsibility to delete the actions when they're not needed anymore.
		/// <param> name="tools" the list of data tool descriptions
		/// </param><param> name="receiver" the receiver for toolActivated() signals
		/// </param><param> name="slot" the slot that will receive the toolActivated() signals
		/// </param><param> name="parent" the parent action collection for the actions to be created
		/// </param></remarks>		<return> the KActions
		///      </return>
		/// 		<short>    Creates a list of actions from a list of information about data-tools.</short>
		public static List<QAction> DataToolActionList(List<KDataToolInfo> tools, QObject receiver, string slot, KActionCollection parent) {
			return (List<QAction>) staticInterceptor.Invoke("dataToolActionList?#$#", "dataToolActionList(const QList<KDataToolInfo>&, const QObject*, const char*, KActionCollection*)", typeof(List<QAction>), typeof(List<KDataToolInfo>), tools, typeof(QObject), receiver, typeof(string), slot, typeof(KActionCollection), parent);
		}
		protected new IKDataToolActionSignals Emit {
			get { return (IKDataToolActionSignals) Q_EMIT; }
		}
	}

	public interface IKDataToolActionSignals : IKActionSignals {
		/// <remarks>
		///  Emitted when a tool has been activated.
		/// <param> name="info" a description of the activated tools
		/// </param><param> name="command" the command for the tool
		///      </param></remarks>		<short>    Emitted when a tool has been activated.</short>
		[Q_SIGNAL("void toolActivated(const KDataToolInfo&, const QString&)")]
		void ToolActivated(KDataToolInfo info, string command);
	}
}
