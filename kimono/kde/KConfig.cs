//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Collections.Generic;
	/// <remarks>
	///  \class KConfig kconfig.h <KConfig>
	///  \brief The central class of the KDE configuration data system.
	///  Quickstart:
	///  Get the default application config object via KGlobal.Config().
	///  Load a specific configuration file:
	///  <pre>
	///  KConfig config( "/etc/kderc", KConfig.SimpleConfig );
	///  </pre>
	///  Load the configuration of a specific component (taking into account
	///  possible custom dirs in KStandardDirs):
	///  <pre>
	///  KConfig config( componentData(), "pluginrc" );
	///  </pre>
	///  In general it is recommended to use KSharedConfig instead of
	///  creating multiple instances of KConfig to avoid the overhead of
	///  separate objects or concerns about synchronizing writes to disk
	///  even if the configuration object is updated from multiple code paths.
	///  KSharedConfig provides a set of open methods as counterparts for the
	///  KConfig constructors.
	///  \sa KSharedConfig, KConfigGroup, <a href="http://techbase.kde.org/index.php?title=Development/Tutorials/KConfig">the techbase HOWTO on KConfig</a>.
	///  </remarks>		<short>    \class KConfig kconfig.</short>
	[SmokeClass("KConfig")]
	public class KConfig : KConfigBase, IDisposable {
 		protected KConfig(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KConfig), this);
		}
		public enum OpenFlag {
			IncludeGlobals = 0x01,
			CascadeConfig = 0x02,
			SimpleConfig = 0x00,
			NoCascade = IncludeGlobals,
			NoGlobals = CascadeConfig,
			FullConfig = IncludeGlobals|CascadeConfig,
		}
		// KConfig* KConfig(KConfigPrivate& arg1); >>>> NOT CONVERTED
		public KConfig(string file, uint mode, string resourceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$$", "KConfig(const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
		}
		public KConfig(string file, uint mode) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$", "KConfig(const QString&, KConfig::OpenFlags)", typeof(void), typeof(string), file, typeof(uint), mode);
		}
		public KConfig(string file) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$", "KConfig(const QString&)", typeof(void), typeof(string), file);
		}
		public KConfig() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig", "KConfig()", typeof(void));
		}
		public KConfig(KComponentData componentData, string file, uint mode, string resourceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
		}
		public KConfig(KComponentData componentData, string file, uint mode) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode);
		}
		public KConfig(KComponentData componentData, string file) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$", "KConfig(const KComponentData&, const QString&)", typeof(void), typeof(KComponentData), componentData, typeof(string), file);
		}
		public KConfig(KComponentData componentData) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#", "KConfig(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
		}
		/// <remarks>
		///  Creates a KConfig oject using the specified backend. If the backend can not
		///  be found or loaded, then the standard configuration parser is used as a fallback.
		///  @arg file the file to be parsed
		///  @arg backend the backend to load
		///  @arg resourceType where to look for the file if an absolute path is not provided
		/// </remarks>		<short>    Creates a KConfig oject using the specified backend.</short>
		public KConfig(string file, string backend, string resourceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$$", "KConfig(const QString&, const QString&, const char*)", typeof(void), typeof(string), file, typeof(string), backend, typeof(string), resourceType);
		}
		public KConfig(string file, string backend) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$", "KConfig(const QString&, const QString&)", typeof(void), typeof(string), file, typeof(string), backend);
		}
		public KComponentData ComponentData() {
			return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
		}
		/// <remarks>
		///  Returns the filename passed to the constructor.
		///      </remarks>		<short>    Returns the filename passed to the constructor.</short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		[SmokeMethod("sync()")]
		public override void Sync() {
			interceptor.Invoke("sync", "sync()", typeof(void));
		}
		[SmokeMethod("markAsClean()")]
		public override void MarkAsClean() {
			interceptor.Invoke("markAsClean", "markAsClean()", typeof(void));
		}
		[SmokeMethod("accessMode() const")]
		public override KConfigBase.AccessMode accessMode() {
			return (KConfigBase.AccessMode) interceptor.Invoke("accessMode", "accessMode() const", typeof(KConfigBase.AccessMode));
		}
		/// <remarks>
		///  Return false if the user cannot write to this KConfig instance,
		///  for instance because of permission problems.
		/// <param> name="warnUser" if true, show a message box telling the user to
		///  contact his system administrator for getting this problem fixed.
		///      </param></remarks>		<short>    Return false if the user cannot write to this KConfig instance,  for instance because of permission problems.</short>
		public bool IsConfigWritable(bool warnUser) {
			return (bool) interceptor.Invoke("isConfigWritable$", "isConfigWritable(bool)", typeof(bool), typeof(bool), warnUser);
		}
		/// <remarks>
		///  Copies all entries from this config object to a new config
		///  object that will save itself to <code>file.</code>
		///  Actual saving to <code>file</code> happens when the returned object is
		///  destructed or when sync() is called upon it.
		/// <param> name="file" the new config object will save itself to.
		/// </param><param> name="config" optional config object to reuse
		/// </param></remarks>		<return> the same as <code>config</code> if it was set, otherwise a new KConfig object.
		///  In that case, do not forget to delete it!
		///      </return>
		/// 		<short>    Copies all entries from this config object to a new config  object that will save itself to <code>file.</code></short>
		public KConfig CopyTo(string file, KConfig config) {
			return (KConfig) interceptor.Invoke("copyTo$#", "copyTo(const QString&, KConfig*) const", typeof(KConfig), typeof(string), file, typeof(KConfig), config);
		}
		public KConfig CopyTo(string file) {
			return (KConfig) interceptor.Invoke("copyTo$", "copyTo(const QString&) const", typeof(KConfig), typeof(string), file);
		}
		/// <remarks>
		///  Checks whether the config file contains the update <code>id</code>
		///  as contained in <code>updateFile.</code> If not, it runs kconf_update
		///  to update the config file.
		///  If you install config update files with critical fixes
		///  you may wish to use this method to verify that a critical
		///  update has indeed been performed to catch the case where
		///  a user restores an old config file from backup that has
		///  not been updated yet.
		/// <param> name="id" the update to check
		/// </param><param> name="updateFile" the file containing the update
		///      </param></remarks>		<short>    Checks whether the config file contains the update <code>id</code>  as contained in <code>updateFile.</code></short>
		public void CheckUpdate(string id, string updateFile) {
			interceptor.Invoke("checkUpdate$$", "checkUpdate(const QString&, const QString&)", typeof(void), typeof(string), id, typeof(string), updateFile);
		}
		/// <remarks>
		///  Clears all internal data structures and then reread
		///  configuration information from persistent storage.
		///      </remarks>		<short>    Clears all internal data structures and then reread  configuration information from persistent storage.</short>
		public void ReparseConfiguration() {
			interceptor.Invoke("reparseConfiguration", "reparseConfiguration()", typeof(void));
		}
		/// <remarks>
		///  Sets the merge stack to the list of files. The stack is last in first out with
		///  the top of the stack being the most specific config file. The files in the merge
		///  stack will be read before the file passed to the constructor and any files that
		///  cascade from that file. This means that the entries read from the files in the
		///  merge stack will be treated as defaults. This function will automatically call
		///  reparseConfiguration() for you.
		///  @note: Most specific config file is relative to this list, the overall
		///  most specific file of this KConfig object is still the file it was
		///  created with, no matter which file is passed last into this function.
		///  This means that writing always goes to the file which was used to
		///  create the KConfig object.
		/// <param> name="files" A list of extra config files.
		///      </param></remarks>		<short>    Sets the merge stack to the list of files.</short>
		public void AddConfigSources(List<string> sources) {
			interceptor.Invoke("addConfigSources?", "addConfigSources(const QStringList&)", typeof(void), typeof(List<string>), sources);
		}
		/// <remarks>
		///  Returns the current locale.
		///      </remarks>		<short>    Returns the current locale.</short>
		public string Locale() {
			return (string) interceptor.Invoke("locale", "locale() const", typeof(string));
		}
		/// <remarks>
		///  Sets the locale to <code>aLocale.</code>
		///  The global locale is used by default.
		///  @note If set to the empty string, <b></b>o locale will be matched. This effectively disables
		///  reading translated entries.
		/// </remarks>		<return> @c true if locale was changed and configuration was reparsed.
		///      </return>
		/// 		<short>    Sets the locale to <code>aLocale.</code></short>
		public bool SetLocale(string aLocale) {
			return (bool) interceptor.Invoke("setLocale$", "setLocale(const QString&)", typeof(bool), typeof(string), aLocale);
		}
		/// <remarks>
		///  When set, all readEntry calls return the system-wide (default) values instead of
		///  the user's preference.
		///  This is off by default.
		///      </remarks>		<short>    When set, all readEntry calls return the system-wide (default) values instead of  the user's preference.</short>
		public void SetReadDefaults(bool b) {
			interceptor.Invoke("setReadDefaults$", "setReadDefaults(bool)", typeof(void), typeof(bool), b);
		}
		public bool ReadDefaults() {
			return (bool) interceptor.Invoke("readDefaults", "readDefaults() const", typeof(bool));
		}
		[SmokeMethod("isImmutable() const")]
		public override bool IsImmutable() {
			return (bool) interceptor.Invoke("isImmutable", "isImmutable() const", typeof(bool));
		}
		[SmokeMethod("groupList() const")]
		public override List<string> GroupList() {
			return (List<string>) interceptor.Invoke("groupList", "groupList() const", typeof(List<string>));
		}
		/// <remarks>
		///  Returns a map (tree) of entries in a particular group.  Only the actual entry as a string
		///  is returned.
		/// <param> name="aGroup" The group to get entries from.
		/// </param></remarks>		<return> A map of entries in the group specified, indexed by key.
		///          The returned map may be empty if the group is empty, or not found.
		/// </return>
		/// 		<short>    Returns a map (tree) of entries in a particular group.</short>
		/// 		<see> QMap</see>
		public Dictionary<string, string> EntryMap(string aGroup) {
			return (Dictionary<string, string>) interceptor.Invoke("entryMap$", "entryMap(const QString&) const", typeof(Dictionary<string, string>), typeof(string), aGroup);
		}
		public Dictionary<string, string> EntryMap() {
			return (Dictionary<string, string>) interceptor.Invoke("entryMap", "entryMap() const", typeof(Dictionary<string, string>));
		}
		[SmokeMethod("hasGroupImpl(const QByteArray&) const")]
		protected override bool HasGroupImpl(QByteArray group) {
			return (bool) interceptor.Invoke("hasGroupImpl#", "hasGroupImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), group);
		}
		[SmokeMethod("groupImpl(const QByteArray&)")]
		protected override KConfigGroup GroupImpl(QByteArray b) {
			return (KConfigGroup) interceptor.Invoke("groupImpl#", "groupImpl(const QByteArray&)", typeof(KConfigGroup), typeof(QByteArray), b);
		}
		[SmokeMethod("deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)")]
		protected override void DeleteGroupImpl(QByteArray group, uint flags) {
			interceptor.Invoke("deleteGroupImpl#$", "deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)", typeof(void), typeof(QByteArray), group, typeof(uint), flags);
		}
		[SmokeMethod("deleteGroupImpl(const QByteArray&)")]
		protected virtual void DeleteGroupImpl(QByteArray group) {
			interceptor.Invoke("deleteGroupImpl#", "deleteGroupImpl(const QByteArray&)", typeof(void), typeof(QByteArray), group);
		}
		[SmokeMethod("isGroupImmutableImpl(const QByteArray&) const")]
		protected override bool IsGroupImmutableImpl(QByteArray aGroup) {
			return (bool) interceptor.Invoke("isGroupImmutableImpl#", "isGroupImmutableImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), aGroup);
		}
		~KConfig() {
			interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
		}
	}
}
