//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	/// <remarks>
	///  KFileItemDelegate is intended to be used to provide a KDE file system
	///  view, when using one of the standard item views in Qt with KDirModel.
	///  While primarily intended to be used with KDirModel, it uses
	///  Qt.DecorationRole and Qt.DisplayRole for the icons and text labels,
	///  just like QItemDelegate, and can thus be used with any standard model.
	///  When used with KDirModel however, KFileItemDelegate can change the way
	///  the display and/or decoration roles are drawn, based on properties
	///  of the file items. For example, if the file item is a symbolic link,
	///  it will use an italic font to draw the file name.
	///  KFileItemDelegate also supports showing additional information about
	///  the file items below the icon labels.
	///  Which information should be shown, if any, is controlled by the
	///  <see cref="#information"></see> property, which is a list that can be set by calling
	///  setShowInformation(), and read by calling showInformation().
	///  By default this list is empty.
	///  To use KFileItemDelegate, instantiate an object from the delegate,
	///  and call setItemDelegate() in one of the standard item views in Qt:
	///  @code
	///  QListView listview = new QListView(this);
	///  KFileItemDelegate delegate = new KFileItemDelegate(this);
	///  listview.SetItemDelegate(delegate);
	///  @endcode
	///  </remarks>		<short>    KFileItemDelegate is intended to be used to provide a KDE file system  view, when using one of the standard item views in Qt with KDirModel.</short>
	[SmokeClass("KFileItemDelegate")]
	public class KFileItemDelegate : QAbstractItemDelegate, IDisposable {
 		protected KFileItemDelegate(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KFileItemDelegate), this);
		}
		/// <remarks>
		///  This enum defines the additional information that can be displayed below item
		///  labels in icon views.
		///  The information will only be shown for indexes for which the model provides
		///  a valid value for KDirModel.FileItemRole, and only when there's sufficient vertical
		///  space to display at least one line of the information, along with the display label.
		///  For the number of items to be shown for folders, the model must provide a valid
		///  value for KDirMode.ChildCountRole, in addition to KDirModel.FileItemRole.
		///  Note that KFileItemDelegate will not call KFileItem.DetermineMimeType() if
		///  KFileItem.IsMimeTypeKnown() returns false, so if you want to display mime types
		///  you should use a KMimeTypeResolver with the model and the view, to ensure that mime
		///  types are resolved. If the mime type isn't known, "Unknown" will be displayed until
		///  the mime type has been successfully resolved.
		/// </remarks>		<short>    This enum defines the additional information that can be displayed below item  labels in icon views.</short>
		/// 		<see> setShowInformation</see>
		/// 		<see> showInformation</see>
		/// 		<see> information</see>
		public enum Information {
			NoInformation = 0,
			Size = 1,
			Permissions = 2,
			OctalPermissions = 3,
			Owner = 4,
			OwnerAndGroup = 5,
			CreationTime = 6,
			ModificationTime = 7,
			AccessTime = 8,
			MimeType = 9,
			FriendlyMimeType = 10,
		}
		[Q_PROPERTY("QColor", "shadowColor")]
		public QColor ShadowColor {
			get { return (QColor) interceptor.Invoke("shadowColor", "shadowColor()", typeof(QColor)); }
			set { interceptor.Invoke("setShadowColor#", "setShadowColor(QColor)", typeof(void), typeof(QColor), value); }
		}
		[Q_PROPERTY("QPointF", "shadowOffset")]
		public QPointF ShadowOffset {
			get { return (QPointF) interceptor.Invoke("shadowOffset", "shadowOffset()", typeof(QPointF)); }
			set { interceptor.Invoke("setShadowOffset#", "setShadowOffset(QPointF)", typeof(void), typeof(QPointF), value); }
		}
		[Q_PROPERTY("qreal", "shadowBlur")]
		public double ShadowBlur {
			get { return (double) interceptor.Invoke("shadowBlur", "shadowBlur()", typeof(double)); }
			set { interceptor.Invoke("setShadowBlur$", "setShadowBlur(qreal)", typeof(void), typeof(double), value); }
		}
		[Q_PROPERTY("QSize", "maximumSize")]
		public QSize MaximumSize {
			get { return (QSize) interceptor.Invoke("maximumSize", "maximumSize()", typeof(QSize)); }
			set { interceptor.Invoke("setMaximumSize#", "setMaximumSize(QSize)", typeof(void), typeof(QSize), value); }
		}
		// void setShowInformation(const KFileItemDelegate::InformationList& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  Constructs a new KFileItemDelegate.
		/// <param> name="parent" The parent object for the delegate.
		///          </param></remarks>		<short>    Constructs a new KFileItemDelegate.</short>
		public KFileItemDelegate(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KFileItemDelegate#", "KFileItemDelegate(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public KFileItemDelegate() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KFileItemDelegate", "KFileItemDelegate()", typeof(void));
		}
		/// <remarks>
		///  Returns the nominal size for the item referred to by <code>index</code>, given the
		///  provided options.
		///  If the model provides a valid Qt.FontRole and/or Qt.AlignmentRole for the item,
		///  those will be used instead of the ones specified in the style options.
		///  This function is reimplemented from <see cref="QAbstractItemDelegate"></see>.
		/// <param> name="option" The style options that should be used when painting the item.
		/// </param><param> name="index" The index to the item for which to return the size hint.
		///          </param></remarks>		<short>    Returns the nominal size for the item referred to by <code>index</code>, given the  provided options.</short>
		[SmokeMethod("sizeHint(const QStyleOptionViewItem&, const QModelIndex&) const")]
		public override QSize SizeHint(QStyleOptionViewItem option, QModelIndex index) {
			return (QSize) interceptor.Invoke("sizeHint##", "sizeHint(const QStyleOptionViewItem&, const QModelIndex&) const", typeof(QSize), typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Paints the item indicated by <code>index</code>, using <code>painter.</code>
		///  The item will be drawn in the rectangle specified by option.rect.
		///  The correct size for that rectangle can be obtained by calling
		///  <see cref="#sizeHint"></see>.
		///  This function will use the following data values if the model provides
		///  them for the item, in place of the values in <code>option</code>:
		/// 
		/// <li>
		/// Qt.FontRole        The font that should be used for the display role.
		/// </li>
		/// 
		/// <li>
		/// Qt.AlignmentRole   The alignment of the display role.
		/// </li>
		/// 
		/// <li>
		/// Qt.ForegroundRole  The text color for the display role.
		/// </li>
		/// 
		/// <li>
		/// Qt.BackgroundRole  The background color for the item.
		/// </li>
		///  This function is reimplemented from <see cref="QAbstractItemDelegate"></see>.
		/// <param> name="painter" The painter with which to draw the item.
		/// </param><param> name="option" The style options that should be used when painting the item.
		/// </param><param> name="index" The index to the item that should be painted.
		///          </param></remarks>		<short>    Paints the item indicated by <code>index</code>, using <code>painter.</code></short>
		[SmokeMethod("paint(QPainter*, const QStyleOptionViewItem&, const QModelIndex&) const")]
		public override void Paint(QPainter painter, QStyleOptionViewItem option, QModelIndex index) {
			interceptor.Invoke("paint###", "paint(QPainter*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(void), typeof(QPainter), painter, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("createEditor(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const")]
		public override QWidget CreateEditor(QWidget parent, QStyleOptionViewItem option, QModelIndex index) {
			return (QWidget) interceptor.Invoke("createEditor###", "createEditor(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(QWidget), typeof(QWidget), parent, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("editorEvent(QEvent*, QAbstractItemModel*, const QStyleOptionViewItem&, const QModelIndex&)")]
		public override bool EditorEvent(QEvent arg1, QAbstractItemModel model, QStyleOptionViewItem option, QModelIndex index) {
			return (bool) interceptor.Invoke("editorEvent####", "editorEvent(QEvent*, QAbstractItemModel*, const QStyleOptionViewItem&, const QModelIndex&)", typeof(bool), typeof(QEvent), arg1, typeof(QAbstractItemModel), model, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("setEditorData(QWidget*, const QModelIndex&) const")]
		public override void SetEditorData(QWidget editor, QModelIndex index) {
			interceptor.Invoke("setEditorData##", "setEditorData(QWidget*, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("setModelData(QWidget*, QAbstractItemModel*, const QModelIndex&) const")]
		public override void SetModelData(QWidget editor, QAbstractItemModel model, QModelIndex index) {
			interceptor.Invoke("setModelData###", "setModelData(QWidget*, QAbstractItemModel*, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QAbstractItemModel), model, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("updateEditorGeometry(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const")]
		public override void UpdateEditorGeometry(QWidget editor, QStyleOptionViewItem option, QModelIndex index) {
			interceptor.Invoke("updateEditorGeometry###", "updateEditorGeometry(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		/// <remarks>
		///  Sets the list of information lines that are shown below the icon label in list views.
		///  You will typically construct the list like this:
		///  @code
		///  KFileItemDelegate.InformationList list;
		///  list << KFileItemDelegate.FriendlyMimeType << KFileItemDelegate.Size;
		///  delegate.SetShowInformation(list);
		///  @endcode
		///  The information lines will be displayed in the list order.
		///  The delegate will first draw the item label, and then as many information
		///  lines as will fit in the available space.
		/// <param> name="list" A list of information items that should be shown
		///          </param></remarks>		<short>    Sets the list of information lines that are shown below the icon label in list views.</short>
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[SmokeMethod("eventFilter(QObject*, QEvent*)")]
		public override bool EventFilter(QObject arg1, QEvent arg2) {
			return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), arg1, typeof(QEvent), arg2);
		}
		/// <remarks>
		///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
		///          </remarks>		<short>    Reimplemented from @ref QAbstractItemDelegate.</short>
		[Q_SLOT("bool helpEvent(QHelpEvent*, QAbstractItemView*, const QStyleOptionViewItem&, const QModelIndex&)")]
		public new bool HelpEvent(QHelpEvent arg1, QAbstractItemView view, QStyleOptionViewItem option, QModelIndex index) {
			return (bool) interceptor.Invoke("helpEvent####", "helpEvent(QHelpEvent*, QAbstractItemView*, const QStyleOptionViewItem&, const QModelIndex&)", typeof(bool), typeof(QHelpEvent), arg1, typeof(QAbstractItemView), view, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
		}
		~KFileItemDelegate() {
			interceptor.Invoke("~KFileItemDelegate", "~KFileItemDelegate()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KFileItemDelegate", "~KFileItemDelegate()", typeof(void));
		}
		protected new IKFileItemDelegateSignals Emit {
			get { return (IKFileItemDelegateSignals) Q_EMIT; }
		}
	}

	public interface IKFileItemDelegateSignals : IQAbstractItemDelegateSignals {
	}
}
