//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;

	/// <remarks>
	///  Base class for all Sycoca entries.
	///  You can't create an instance of KSycocaEntry, but it provides
	///  the common functionality for servicetypes and services.
	/// </remarks>		<short>    Base class for all Sycoca entries.</short>
	/// 		<see> http://techbase.kde.org/Development/Architecture/KDE3/System_Configuration_Cache</see>

	[SmokeClass("KSycocaEntry")]
	public class KSycocaEntry : KShared, IDisposable {
 		protected KSycocaEntry(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KSycocaEntry), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KSycocaEntry() {
			staticInterceptor = new SmokeInvocation(typeof(KSycocaEntry), null);
		}
		// KSycocaEntry* KSycocaEntry(KSycocaEntryPrivate& arg1); >>>> NOT CONVERTED
		public KSycocaEntry() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSycocaEntry", "KSycocaEntry()", typeof(void));
		}
		/// <remarks>
		///  internal
		///     </remarks>		<short>    internal     </short>
		public bool IsType(int t) {
			return (bool) interceptor.Invoke("isType?", "isType(KSycocaType) const", typeof(bool), typeof(int), t);
		}
		/// <remarks>
		///  internal
		///     </remarks>		<short>    internal     </short>
		public int SycocaType() {
			return (int) interceptor.Invoke("sycocaType", "sycocaType() const", typeof(int));
		}
		/// <remarks>
		/// </remarks>		<return> the name of this entry
		///     </return>
		/// 		<short>   </short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> the path of this entry
		///  The path can be absolute or relative.
		///  The corresponding factory should know relative to what.
		///     </return>
		/// 		<short>   </short>
		public string EntryPath() {
			return (string) interceptor.Invoke("entryPath", "entryPath() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> true if valid
		///     </return>
		/// 		<short>   </short>
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> true if deleted
		///     </return>
		/// 		<short>   </short>
		public bool IsDeleted() {
			return (bool) interceptor.Invoke("isDeleted", "isDeleted() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the requested property. Some often used properties
		///  have convenience access functions like exec(),
		///  serviceTypes etc.
		/// <param> name="_name" the name of the property
		/// </param></remarks>		<return> the property, or invalid if not found
		///      </return>
		/// 		<short>    Returns the requested property.</short>
		public QVariant Property(string name) {
			return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), name);
		}
		/// <remarks>
		///  Returns the list of all properties that this service can have.
		///  That means, that some of these properties may be empty.
		/// </remarks>		<return> the list of supported properties
		///      </return>
		/// 		<short>    Returns the list of all properties that this service can have.</short>
		public List<string> PropertyNames() {
			return (List<string>) interceptor.Invoke("propertyNames", "propertyNames() const", typeof(List<string>));
		}
		/// <remarks>
		///  Sets whether or not this service is deleted
		///     </remarks>		<short>    Sets whether or not this service is deleted     </short>
		public void SetDeleted(bool deleted) {
			interceptor.Invoke("setDeleted$", "setDeleted(bool)", typeof(void), typeof(bool), deleted);
		}
		public bool IsSeparator() {
			return (bool) interceptor.Invoke("isSeparator", "isSeparator() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> the position of the entry in the sycoca file
		///     </return>
		/// 		<short>   </short>
		public int Offset() {
			return (int) interceptor.Invoke("offset", "offset() const", typeof(int));
		}
		/// <remarks>
		///  Save ourselves to the database. Don't forget to call the parent class
		///  first if you override this function.
		///     </remarks>		<short>   </short>
		public void Save(QDataStream s) {
			interceptor.Invoke("save#", "save(QDataStream&)", typeof(void), typeof(QDataStream), s);
		}
		~KSycocaEntry() {
			interceptor.Invoke("~KSycocaEntry", "~KSycocaEntry()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KSycocaEntry", "~KSycocaEntry()", typeof(void));
		}
		/// <remarks>
		///  Safe demarshalling functions.
		///     </remarks>		<short>    Safe demarshalling functions.</short>
		public static void Read(QDataStream s, StringBuilder str) {
			staticInterceptor.Invoke("read#$", "read(QDataStream&, QString&)", typeof(void), typeof(QDataStream), s, typeof(StringBuilder), str);
		}
		public static void Read(QDataStream s, List<string> list) {
			staticInterceptor.Invoke("read#?", "read(QDataStream&, QStringList&)", typeof(void), typeof(QDataStream), s, typeof(List<string>), list);
		}
	}
}
