//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Text;
	/// <remarks>
	///  A generic DBUS service starter, using KServiceTypeTrader.
	///  The default implementation starts new processes, but this interface can
	///  also be reimplemented by specific applications to provide dlopened in-process DBus objects.
	///  This interface is similar to the startServiceByName() function found in QDBusBusService, but
	///  with the added benefit of using KTrader (and, therefore, additional constraints and the
	///  ability to search the standard KDE dirs).
	/// </remarks>		<author> David Faure <faure@kde.org>
	///  </author>
	/// 		<short>    A generic DBUS service starter, using KServiceTypeTrader.</short>
	[SmokeClass("KDBusServiceStarter")]
	public class KDBusServiceStarter : Object {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KDBusServiceStarter(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KDBusServiceStarter), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KDBusServiceStarter() {
			staticInterceptor = new SmokeInvocation(typeof(KDBusServiceStarter), null);
		}
		/// <remarks>
		///  Check if a given DBus service is available - from the serviceType it's supposed to implement.
		///  The trader is queried to find the preferred application for this serviceType,
		///  with the constraint that its X-DBus-ServiceName property must be defined.
		///  Then the DBus server is checked. If the service is not available,
		///  this method will call startServiceFor to start it.
		/// <param> name="serviceType" the type of service we're looking for
		/// </param><param> name="constraint" see KServiceTypeTrader
		/// </param><param> name="error" On failure, <code>error</code> contains a description of the error
		///          that occurred. If the pointer is 0, the argument will be
		///          ignored
		/// </param><param> name="dbusService" On success, <code>dbusService</code> contains the DBus service name
		///          under which this service is available. If the pointer is 0 the argument
		///          will be ignored
		/// </param><param> name="flags" for future extensions (currently unused)
		/// </param></remarks>		<return> an error code indicating success (== 0) or failure (> 0).
		///      </return>
		/// 		<short>    Check if a given DBus service is available - from the serviceType it's supposed to implement.</short>
		public int FindServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService, int flags) {
			return (int) interceptor.Invoke("findServiceFor$$$$$", "findServiceFor(const QString&, const QString&, QString*, QString*, int)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService, typeof(int), flags);
		}
		public int FindServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService) {
			return (int) interceptor.Invoke("findServiceFor$$$$", "findServiceFor(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService);
		}
		public int FindServiceFor(string serviceType, string constraint, StringBuilder error) {
			return (int) interceptor.Invoke("findServiceFor$$$", "findServiceFor(const QString&, const QString&, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error);
		}
		public int FindServiceFor(string serviceType, string constraint) {
			return (int) interceptor.Invoke("findServiceFor$$", "findServiceFor(const QString&, const QString&)", typeof(int), typeof(string), serviceType, typeof(string), constraint);
		}
		public int FindServiceFor(string serviceType) {
			return (int) interceptor.Invoke("findServiceFor$", "findServiceFor(const QString&)", typeof(int), typeof(string), serviceType);
		}
		/// <remarks>
		///  Find an implementation of the given <code>serviceType</code>,
		///  and start it, to use its DBus interface.
		///  The default implementation uses KServiceTypeTrader to find the preferred Application,
		///  and then starts it using KToolInvocation.StartService...
		///  However applications (like kontact) can reimplement this method, to provide
		///  an in-process way of loading the implementation for this service type.
		/// <param> name="serviceType" the type of service we're looking for
		/// </param><param> name="constraint" see KServiceTypeTrader
		/// </param><param> name="error" On failure, <code>error</code> contains a description of the error
		///          that occurred. If the pointer is 0, the argument will be
		///          ignored
		/// </param><param> name="dbusService" On success, <code>dbusService</code> contains the DBus service name
		///          under which this service is available. If the pointer is 0 the argument
		///          will be ignored
		/// </param><param> name="flags" for future extensions (currently unused)
		/// </param></remarks>		<return> an error code indicating success (== 0) or failure (> 0).
		///      </return>
		/// 		<short>    Find an implementation of the given <code>serviceType</code>,  and start it, to use its DBus interface.</short>
		[SmokeMethod("startServiceFor(const QString&, const QString&, QString*, QString*, int)")]
		public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService, int flags) {
			return (int) interceptor.Invoke("startServiceFor$$$$$", "startServiceFor(const QString&, const QString&, QString*, QString*, int)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService, typeof(int), flags);
		}
		[SmokeMethod("startServiceFor(const QString&, const QString&, QString*, QString*)")]
		public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService) {
			return (int) interceptor.Invoke("startServiceFor$$$$", "startServiceFor(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService);
		}
		[SmokeMethod("startServiceFor(const QString&, const QString&, QString*)")]
		public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error) {
			return (int) interceptor.Invoke("startServiceFor$$$", "startServiceFor(const QString&, const QString&, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error);
		}
		[SmokeMethod("startServiceFor(const QString&, const QString&)")]
		public virtual int StartServiceFor(string serviceType, string constraint) {
			return (int) interceptor.Invoke("startServiceFor$$", "startServiceFor(const QString&, const QString&)", typeof(int), typeof(string), serviceType, typeof(string), constraint);
		}
		[SmokeMethod("startServiceFor(const QString&)")]
		public virtual int StartServiceFor(string serviceType) {
			return (int) interceptor.Invoke("startServiceFor$", "startServiceFor(const QString&)", typeof(int), typeof(string), serviceType);
		}
		public KDBusServiceStarter() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KDBusServiceStarter", "KDBusServiceStarter()", typeof(void));
		}
		public static KDBusServiceStarter Self() {
			return (KDBusServiceStarter) staticInterceptor.Invoke("self", "self()", typeof(KDBusServiceStarter));
		}
	}
}
