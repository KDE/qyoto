//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;


	[SmokeClass("KColorValueSelector")]
	public class KColorValueSelector : KSelector, IDisposable {
 		protected KColorValueSelector(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KColorValueSelector), this);
		}
		// void setChooserMode(KColorChooserMode arg1); >>>> NOT CONVERTED
		// KColorChooserMode chooserMode(); >>>> NOT CONVERTED
		/// <remarks>
		///  Constructs a widget for color selection.
		///    </remarks>		<short>    Constructs a widget for color selection.</short>
		public KColorValueSelector(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KColorValueSelector#", "KColorValueSelector(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KColorValueSelector() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KColorValueSelector", "KColorValueSelector()", typeof(void));
		}
		/// <remarks>
		///  Constructs a widget for color selection with a given orientation
		///    </remarks>		<short>    Constructs a widget for color selection with a given orientation    </short>
		public KColorValueSelector(Qt.Orientation o, QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KColorValueSelector$#", "KColorValueSelector(Qt::Orientation, QWidget*)", typeof(void), typeof(Qt.Orientation), o, typeof(QWidget), parent);
		}
		public KColorValueSelector(Qt.Orientation o) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KColorValueSelector$", "KColorValueSelector(Qt::Orientation)", typeof(void), typeof(Qt.Orientation), o);
		}
		/// <remarks>
		///  Updates the widget's contents.
		///    </remarks>		<short>    Updates the widget's contents.</short>
		public void UpdateContents() {
			interceptor.Invoke("updateContents", "updateContents()", typeof(void));
		}
		/// <remarks>
		///  Returns the current hue value.
		/// </remarks>		<return> The hue value (0-255)
		///    </return>
		/// 		<short>    Returns the current hue value.</short>
		public int Hue() {
			return (int) interceptor.Invoke("hue", "hue() const", typeof(int));
		}
		/// <remarks>
		///  Sets the hue value. Doesn't automatically update the widget;
		///  you have to call updateContents manually.
		/// <param> name="hue" Sets the hue value (0-255)
		///    </param></remarks>		<short>    Sets the hue value.</short>
		public void SetHue(int hue) {
			interceptor.Invoke("setHue$", "setHue(int)", typeof(void), typeof(int), hue);
		}
		/// <remarks>
		///  Returns the current saturation value.
		/// </remarks>		<return> The saturation value (0-255)
		///    </return>
		/// 		<short>    Returns the current saturation value.</short>
		public int Saturation() {
			return (int) interceptor.Invoke("saturation", "saturation() const", typeof(int));
		}
		/// <remarks>
		///  Sets the saturation value. Doesn't automatically update the widget;
		///  you have to call updateContents manually.
		/// <param> name="saturation" Sets the saturation value (0-255)
		///    </param></remarks>		<short>    Sets the saturation value.</short>
		public void SetSaturation(int saturation) {
			interceptor.Invoke("setSaturation$", "setSaturation(int)", typeof(void), typeof(int), saturation);
		}
		/// <remarks>
		///  Returns the current color value.
		/// </remarks>		<return> The color value (0-255)
		///    </return>
		/// 		<short>    Returns the current color value.</short>
		public int ColorValue() {
			return (int) interceptor.Invoke("colorValue", "colorValue() const", typeof(int));
		}
		/// <remarks>
		///  Sets the color value. Doesn't automatically update the widget;
		///  you have to call updateContents manually.
		/// <param> name="colorValue" Sets the color value (0-255)
		///    </param></remarks>		<short>    Sets the color value.</short>
		public void SetColorValue(int colorValue) {
			interceptor.Invoke("setColorValue$", "setColorValue(int)", typeof(void), typeof(int), colorValue);
		}
		/// <remarks>
		///  Sets the chooser mode. Doesn't automatically update the widget;
		///  you have to call updateContents manually.
		/// <param> name="chooserMode" Sets the chooser mode (one of the KColorChooserMode constants)
		///    </param></remarks>		<short>    Sets the chooser mode.</short>
		/// <remarks>
		///  Returns the current chooser mode.
		/// </remarks>		<return> The chooser mode (one of the KColorChooserMode constants)
		///    </return>
		/// 		<short>    Returns the current chooser mode.</short>
		/// <remarks>
		///  Draws the contents of the widget on a pixmap,
		///  which is used for buffering.
		///    </remarks>		<short>    Draws the contents of the widget on a pixmap,  which is used for buffering.</short>
		[SmokeMethod("drawPalette(QPixmap*)")]
		protected virtual void DrawPalette(QPixmap pixmap) {
			interceptor.Invoke("drawPalette#", "drawPalette(QPixmap*)", typeof(void), typeof(QPixmap), pixmap);
		}
		[SmokeMethod("resizeEvent(QResizeEvent*)")]
		protected override void ResizeEvent(QResizeEvent arg1) {
			interceptor.Invoke("resizeEvent#", "resizeEvent(QResizeEvent*)", typeof(void), typeof(QResizeEvent), arg1);
		}
		/// <remarks>
		///  Reimplemented from KSelector. The drawing is
		///  buffered in a pixmap here. As real drawing
		///  routine, drawPalette() is used.
		///    </remarks>		<short>    Reimplemented from KSelector.</short>
		[SmokeMethod("drawContents(QPainter*)")]
		protected override void DrawContents(QPainter painter) {
			interceptor.Invoke("drawContents#", "drawContents(QPainter*)", typeof(void), typeof(QPainter), painter);
		}
		~KColorValueSelector() {
			interceptor.Invoke("~KColorValueSelector", "~KColorValueSelector()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KColorValueSelector", "~KColorValueSelector()", typeof(void));
		}
		protected new IKColorValueSelectorSignals Emit {
			get { return (IKColorValueSelectorSignals) Q_EMIT; }
		}
	}

	public interface IKColorValueSelectorSignals : IKSelectorSignals {
	}
}
