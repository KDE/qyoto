//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	/// <remarks>
	///  A container for a "state-aware" brush.
	///  KStatefulBrush provides an easy and safe way to store a color for use in a
	///  user interface. It is "safe" both in that it will make it easy to deal with
	///  widget states in a correct manner, and that it insulates you against changes
	///  in QPalette.ColorGroup.
	///  Basically, a stateful brush is used to cache a particular "color" from the
	///  KDE system palette (usually, one which does not live in QPalette) in the way
	///  you would have used a QColor in KDE3. When you are ready to draw using the
	///  brush, you use the current state to retrieve the appropriate brush.
	///  Stateful brushes can also be used to apply state effects to arbitrary
	///  brushes, for example when working with a application specific user-defined
	///  color palette.
	///  @note As of Qt 4.3, QPalette.ColorGroup is missing a state for disabled
	///  widgets in an inactive window. Hopefully Trolltech will fix this bug, at
	///  which point KColorScheme and KStatefulBrush will be updated to recognize the
	///  new state. Using KStatefulBrush will allow your application to inherit these
	///  changes "for free", without even recompiling.
	///  </remarks>		<short>    A container for a "state-aware" brush.</short>
	[SmokeClass("KStatefulBrush")]
	public class KStatefulBrush : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KStatefulBrush(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KStatefulBrush), this);
		}
		/// <remarks>
		///  Construct a "default" stateful brush. For such an instance, all
		///  overloads of KStatefulBrush.Brush will return a default brush (i.e.
		///  <tt>QBrush()</tt>).
		///      </remarks>		<short>    Construct a "default" stateful brush.</short>
		public KStatefulBrush() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush", "KStatefulBrush()", typeof(void));
		}
		/// <remarks>
		///  Construct a stateful brush from given color set and foreground role,
		///  using the colors from the given KConfig (if null, the system colors are
		///  used).
		///      </remarks>		<short>    Construct a stateful brush from given color set and foreground role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.ForegroundRole arg2, KSharedConfig arg3) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$#", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::ForegroundRole, KSharedConfigPtr)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.ForegroundRole), arg2, typeof(KSharedConfig), arg3);
		}
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.ForegroundRole arg2) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::ForegroundRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.ForegroundRole), arg2);
		}
		/// <remarks>
		///  Construct a stateful brush from given color set and background role,
		///  using the colors from the given KConfig (if null, the system colors are
		///  used).
		///      </remarks>		<short>    Construct a stateful brush from given color set and background role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.BackgroundRole arg2, KSharedConfig arg3) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$#", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::BackgroundRole, KSharedConfigPtr)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.BackgroundRole), arg2, typeof(KSharedConfig), arg3);
		}
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.BackgroundRole arg2) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::BackgroundRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.BackgroundRole), arg2);
		}
		/// <remarks>
		///  Construct a stateful brush from given color set and decoration role,
		///  using the colors from the given KConfig (if null, the system colors are
		///  used).
		///      </remarks>		<short>    Construct a stateful brush from given color set and decoration role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.DecorationRole arg2, KSharedConfig arg3) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$#", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::DecorationRole, KSharedConfigPtr)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.DecorationRole), arg2, typeof(KSharedConfig), arg3);
		}
		public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.DecorationRole arg2) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::DecorationRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.DecorationRole), arg2);
		}
		/// <remarks>
		///  Construct a stateful background brush from a specified QBrush (or
		///  QColor, via QBrush's implicit constructor). The various states are
		///  determined from the base QBrush (which fills in the Active state)
		///  according to the same rules used to build stateful color schemes from
		///  the system color scheme. The state effects from the given KConfig are
		///  used (if null, the system state effects are used).
		///      </remarks>		<short>    Construct a stateful background brush from a specified QBrush (or  QColor, via QBrush's implicit constructor).</short>
		public KStatefulBrush(QBrush arg1, KSharedConfig arg2) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush##", "KStatefulBrush(const QBrush&, KSharedConfigPtr)", typeof(void), typeof(QBrush), arg1, typeof(KSharedConfig), arg2);
		}
		public KStatefulBrush(QBrush arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush#", "KStatefulBrush(const QBrush&)", typeof(void), typeof(QBrush), arg1);
		}
		/// <remarks>
		///  Construct a stateful foreground/decoration brush from a specified
		///  QBrush (or QColor, via QBrush's implicit constructor). The various
		///  states are determined from the base QBrush (which fills in the Active
		///  state) according to the same rules used to build stateful color schemes
		///  from the system color scheme. The state effects from the given KConfig
		///  are used (if null, the system state effects are used).
		/// <param> name="background" The background brush (or color) corresponding to the
		///  KColorScheme.NormalBackground role and QPalette.Active state for this
		///  foreground/decoration color.
		///      </param></remarks>		<short>    Construct a stateful foreground/decoration brush from a specified  QBrush (or QColor, via QBrush's implicit constructor).</short>
		public KStatefulBrush(QBrush arg1, QBrush background, KSharedConfig arg3) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush###", "KStatefulBrush(const QBrush&, const QBrush&, KSharedConfigPtr)", typeof(void), typeof(QBrush), arg1, typeof(QBrush), background, typeof(KSharedConfig), arg3);
		}
		public KStatefulBrush(QBrush arg1, QBrush background) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush##", "KStatefulBrush(const QBrush&, const QBrush&)", typeof(void), typeof(QBrush), arg1, typeof(QBrush), background);
		}
		/// <remarks> Construct a copy of another KStatefulBrush. </remarks>		<short>   Construct a copy of another KStatefulBrush.</short>
		public KStatefulBrush(KStatefulBrush arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KStatefulBrush#", "KStatefulBrush(const KStatefulBrush&)", typeof(void), typeof(KStatefulBrush), arg1);
		}
		/// <remarks>
		///  Retrieve the brush for the specified widget state. This is used when you
		///  know explicitly what state is wanted. Otherwise one of overloads is
		///  often more convenient.
		///      </remarks>		<short>    Retrieve the brush for the specified widget state.</short>
		public QBrush Brush(QPalette.ColorGroup arg1) {
			return (QBrush) interceptor.Invoke("brush$", "brush(QPalette::ColorGroup) const", typeof(QBrush), typeof(QPalette.ColorGroup), arg1);
		}
		/// <remarks>
		///  Retrieve the brush, using a QPalette reference to determine the correct
		///  state. Use when your painting code has easy access to the QPalette that
		///  it is supposed to be using. The state used in this instance is the
		///  currentColorGroup of the palette.
		///      </remarks>		<short>    Retrieve the brush, using a QPalette reference to determine the correct  state.</short>
		public QBrush Brush(QPalette arg1) {
			return (QBrush) interceptor.Invoke("brush#", "brush(const QPalette&) const", typeof(QBrush), typeof(QPalette), arg1);
		}
		/// <remarks>
		///  Retrieve the brush, using a QWidget pointer to determine the correct
		///  state. Use when you have a pointer to the widget that you are painting.
		///  The state used is the current state of the widget.
		///  @note If you pass an invalid widget, you will get a default brush (i.e.
		///  <tt>QBrush()</tt>).
		///      </remarks>		<short>    Retrieve the brush, using a QWidget pointer to determine the correct  state.</short>
		public QBrush Brush(QWidget arg1) {
			return (QBrush) interceptor.Invoke("brush#", "brush(const QWidget*) const", typeof(QBrush), typeof(QWidget), arg1);
		}
		~KStatefulBrush() {
			interceptor.Invoke("~KStatefulBrush", "~KStatefulBrush()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KStatefulBrush", "~KStatefulBrush()", typeof(void));
		}
	}
}
