//Auto-generated by kalyptus. DO NOT EDIT.
namespace KIO {

	using Kimono;
	using System;
	using Qyoto;

	/// <remarks>
	///  The FileCopyJob copies data from one place to another.
	///  See <see cref="IFileCopyJobSignals"></see> for signals emitted by FileCopyJob
	/// </remarks>		<short>    The FileCopyJob copies data from one place to another.</short>
	/// 		<see> file_copy</see>
	/// 		<see> file_move</see>

	[SmokeClass("KIO::FileCopyJob")]
	public class FileCopyJob : KIO.Job {
 		protected FileCopyJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(FileCopyJob), this);
		}
		// void setSourceSize(KIO::filesize_t arg1); >>>> NOT CONVERTED
		// KIO::FileCopyJob* FileCopyJob(KIO::FileCopyJobPrivate& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  If you know the size of the source file, call this method
		///  to inform this job. It will be displayed in the "resume" dialog.
		/// <param> name="size" the size of the source file
		///          </param></remarks>		<short>    If you know the size of the source file, call this method  to inform this job.</short>
		/// <remarks>
		///  Sets the modification time of the file
		///  Note that this is ignored if a direct copy (SlaveBase.Copy) can be done,
		///  in which case the mtime of the source is applied to the destination (if the protocol
		///  supports the concept).
		///          </remarks>		<short>    Sets the modification time of the file </short>
		public void SetModificationTime(QDateTime mtime) {
			interceptor.Invoke("setModificationTime#", "setModificationTime(const QDateTime&)", typeof(void), typeof(QDateTime), mtime);
		}
		/// <remarks>
		///  Returns the source URL.
		/// </remarks>		<return> the source URL
		/// 	 </return>
		/// 		<short>    Returns the source URL.</short>
		public KUrl SrcUrl() {
			return (KUrl) interceptor.Invoke("srcUrl", "srcUrl() const", typeof(KUrl));
		}
		/// <remarks>
		///  Returns the destination URL.
		/// </remarks>		<return> the destination URL
		/// 	 </return>
		/// 		<short>    Returns the destination URL.</short>
		public KUrl DestUrl() {
			return (KUrl) interceptor.Invoke("destUrl", "destUrl() const", typeof(KUrl));
		}
		[SmokeMethod("doSuspend()")]
		public new virtual bool DoSuspend() {
			return (bool) interceptor.Invoke("doSuspend", "doSuspend()", typeof(bool));
		}
		[SmokeMethod("doResume()")]
		public new virtual bool DoResume() {
			return (bool) interceptor.Invoke("doResume", "doResume()", typeof(bool));
		}
		/// <remarks>
		///  Called whenever a subjob finishes.
		/// <param> name="job" the job that emitted this signal
		///          </param></remarks>		<short>    Called whenever a subjob finishes.</short>
		[Q_SLOT("void slotResult(KJob*)")]
		[SmokeMethod("slotResult(KJob*)")]
		protected override void SlotResult(KJob job) {
			interceptor.Invoke("slotResult#", "slotResult(KJob*)", typeof(void), typeof(KJob), job);
		}
		protected new IFileCopyJobSignals Emit {
			get { return (IFileCopyJobSignals) Q_EMIT; }
		}
	}

	public interface IFileCopyJobSignals : KIO.IJobSignals {
		/// <remarks>
		///  Mimetype determined during a file copy.
		///  This is never emitted during a move, and might not be emitted during
		///  a file copy, depending on the slave. But when a get and a put are
		///  being used (which is the common case), this signal forwards the
		///  mimetype information from the get job.
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="type" the mime type
		///          </param></remarks>		<short>    Mimetype determined during a file copy.</short>
		[Q_SIGNAL("void mimetype(KIO::Job*, const QString&)")]
		void Mimetype(KIO.Job job, string type);
	}
}
