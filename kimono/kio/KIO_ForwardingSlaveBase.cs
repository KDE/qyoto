//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;

	/// <remarks>
	///  This class should be used as a base for ioslaves acting as a
	///  forwarder to other ioslaves. It has been designed to support only
	///  local filesystem like ioslaves.
	///  If the resulting ioslave should be a simple proxy, you only need
	///  to implement the ForwardingSlaveBase.RewriteUrl() method.
	///  For more advanced behavior, the classic ioslave methods should
	///  be reimplemented, because their default behavior in this class
	///  is to forward using the ForwardingSlaveBase.RewriteUrl() method.
	///  A possible code snippet for an advanced stat() behavior would look
	///  like this in the child class:
	///  <pre>
	///      void ChildProtocol.Stat(KUrlurl)
	///      {
	///          bool is_special = false;
	///          // Process the URL to see if it should have
	///          // a special treatment
	///          if ( is_special )
	///          {
	///              // Handle the URL ourselves
	///              KIO.UDSEntry entry;
	///              // Fill entry with UDSAtom instances
	///              statEntry(entry);
	///              finished();
	///          }
	///          else
	///          {
	///              // Setup the ioslave internal state if
	///              // required by ChildProtocol.RewriteUrl()
	///              ForwardingSlaveBase.Stat(url);
	///          }
	///      }
	///  </pre>
	///  Of course in this case, you surely need to reimplement listDir()
	///  and get() accordingly.
	///  If you want view on directories to be correctly refreshed when
	///  something changes on a forwarded URL, you'll need a companion kded
	///  module to emit the KDirNotify Files() D-Bus signals.
	///  This class was initially used for media:/ ioslave. This ioslave code
	///  and the MediaDirNotify class of its companion kded module can be a
	///  good source of inspiration.
	/// </remarks>		<author> Kevin Ottens <ervin@ipsquad.net>
	///  </author>
	/// 		<short>    This class should be used as a base for ioslaves acting as a  forwarder to other ioslaves.</short>
	/// 		<see> ForwardingSlaveBase.RewriteUrl</see>

	[SmokeClass("KIO::ForwardingSlaveBase")]
	public abstract class ForwardingSlaveBase : QObject, KIO.ISlaveBase {
 		protected ForwardingSlaveBase(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(ForwardingSlaveBase), this);
		}
		// void listEntries(const KIO::UDSEntryList& arg1); >>>> NOT CONVERTED
		// int messageBox(KIO::SlaveBase::MessageBoxType arg1,const QString& arg2,const QString& arg3,const QString& arg4,const QString& arg5); >>>> NOT CONVERTED
		// int messageBox(KIO::SlaveBase::MessageBoxType arg1,const QString& arg2,const QString& arg3,const QString& arg4); >>>> NOT CONVERTED
		// int messageBox(KIO::SlaveBase::MessageBoxType arg1,const QString& arg2,const QString& arg3); >>>> NOT CONVERTED
		// int messageBox(KIO::SlaveBase::MessageBoxType arg1,const QString& arg2); >>>> NOT CONVERTED
		// int messageBox(const QString& arg1,KIO::SlaveBase::MessageBoxType arg2,const QString& arg3,const QString& arg4,const QString& arg5,const QString& arg6); >>>> NOT CONVERTED
		// int messageBox(const QString& arg1,KIO::SlaveBase::MessageBoxType arg2,const QString& arg3,const QString& arg4,const QString& arg5); >>>> NOT CONVERTED
		// int messageBox(const QString& arg1,KIO::SlaveBase::MessageBoxType arg2,const QString& arg3,const QString& arg4); >>>> NOT CONVERTED
		// int messageBox(const QString& arg1,KIO::SlaveBase::MessageBoxType arg2,const QString& arg3); >>>> NOT CONVERTED
		// int messageBox(const QString& arg1,KIO::SlaveBase::MessageBoxType arg2); >>>> NOT CONVERTED
		public ForwardingSlaveBase(QByteArray protocol, QByteArray poolSocket, QByteArray appSocket) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("ForwardingSlaveBase###", "ForwardingSlaveBase(const QByteArray&, const QByteArray&, const QByteArray&)", typeof(void), typeof(QByteArray), protocol, typeof(QByteArray), poolSocket, typeof(QByteArray), appSocket);
		}
		[SmokeMethod("get(const KUrl&)")]
		public virtual void Get(KUrl url) {
			interceptor.Invoke("get#", "get(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		[SmokeMethod("put(const KUrl&, int, bool, bool)")]
		public virtual void Put(KUrl url, int permissions, bool overwrite, bool resume) {
			interceptor.Invoke("put#$$$", "put(const KUrl&, int, bool, bool)", typeof(void), typeof(KUrl), url, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume);
		}
		[SmokeMethod("stat(const KUrl&)")]
		public virtual void Stat(KUrl url) {
			interceptor.Invoke("stat#", "stat(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		[SmokeMethod("mimetype(const KUrl&)")]
		public virtual void Mimetype(KUrl url) {
			interceptor.Invoke("mimetype#", "mimetype(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		[SmokeMethod("listDir(const KUrl&)")]
		public virtual void ListDir(KUrl url) {
			interceptor.Invoke("listDir#", "listDir(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		[SmokeMethod("mkdir(const KUrl&, int)")]
		public virtual void Mkdir(KUrl url, int permissions) {
			interceptor.Invoke("mkdir#$", "mkdir(const KUrl&, int)", typeof(void), typeof(KUrl), url, typeof(int), permissions);
		}
		[SmokeMethod("rename(const KUrl&, const KUrl&, bool)")]
		public virtual void Rename(KUrl src, KUrl dest, bool overwrite) {
			interceptor.Invoke("rename##$", "rename(const KUrl&, const KUrl&, bool)", typeof(void), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), overwrite);
		}
		[SmokeMethod("symlink(const QString&, const KUrl&, bool)")]
		public virtual void Symlink(string target, KUrl dest, bool overwrite) {
			interceptor.Invoke("symlink$#$", "symlink(const QString&, const KUrl&, bool)", typeof(void), typeof(string), target, typeof(KUrl), dest, typeof(bool), overwrite);
		}
		[SmokeMethod("chmod(const KUrl&, int)")]
		public virtual void Chmod(KUrl url, int permissions) {
			interceptor.Invoke("chmod#$", "chmod(const KUrl&, int)", typeof(void), typeof(KUrl), url, typeof(int), permissions);
		}
		[SmokeMethod("setModificationTime(const KUrl&, const QDateTime&)")]
		public virtual void SetModificationTime(KUrl url, QDateTime mtime) {
			interceptor.Invoke("setModificationTime##", "setModificationTime(const KUrl&, const QDateTime&)", typeof(void), typeof(KUrl), url, typeof(QDateTime), mtime);
		}
		[SmokeMethod("copy(const KUrl&, const KUrl&, int, bool)")]
		public virtual void Copy(KUrl src, KUrl dest, int permissions, bool overwrite) {
			interceptor.Invoke("copy##$$", "copy(const KUrl&, const KUrl&, int, bool)", typeof(void), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite);
		}
		[SmokeMethod("del(const KUrl&, bool)")]
		public virtual void Del(KUrl url, bool isfile) {
			interceptor.Invoke("del#$", "del(const KUrl&, bool)", typeof(void), typeof(KUrl), url, typeof(bool), isfile);
		}
		/// <remarks>
		///  Rewrite an url to it's forwarded counterpart. It should return
		///  true if everything was ok, and false otherwise.
		///  If a problem is detected it's up to this method to trigger error()
		///  before returning. Returning false silently cancel the current
		///  slave operation.
		/// <param> name="url" The URL as given during the slave call
		/// </param><param> name="newURL" The new URL to forward the slave call to
		/// </param></remarks>		<return> true if the given url could be correctly rewritten
		///      </return>
		/// 		<short>    Rewrite an url to it's forwarded counterpart.</short>
		[SmokeMethod("rewriteUrl(const KUrl&, KUrl&)")]
		protected abstract bool RewriteUrl(KUrl url, KUrl newURL);
		/// <remarks>
		///  Allow to modify a UDSEntry before it's sent to the ioslave enpoint.
		///  This is the default implementation working in most case, but sometimes
		///  you could make use of more forwarding black magic (for example
		///  dynamically transform any desktop file into a fake directory...)
		/// <param> name="entry" the UDSEntry to post-process
		/// </param><param> name="listing" indicate if this entry it created during a listDir
		///                 operation
		///      </param></remarks>		<short>    Allow to modify a UDSEntry before it's sent to the ioslave enpoint.</short>
		[SmokeMethod("prepareUDSEntry(KIO::UDSEntry&, bool) const")]
		protected virtual void PrepareUDSEntry(KIO.UDSEntry entry, bool listing) {
			interceptor.Invoke("prepareUDSEntry#$", "prepareUDSEntry(KIO::UDSEntry&, bool) const", typeof(void), typeof(KIO.UDSEntry), entry, typeof(bool), listing);
		}
		[SmokeMethod("prepareUDSEntry(KIO::UDSEntry&) const")]
		protected virtual void PrepareUDSEntry(KIO.UDSEntry entry) {
			interceptor.Invoke("prepareUDSEntry#", "prepareUDSEntry(KIO::UDSEntry&) const", typeof(void), typeof(KIO.UDSEntry), entry);
		}
		/// <remarks>
		///  Return the URL being processed by the ioslave
		///  Only access it inside prepareUDSEntry()
		///      </remarks>		<short>    Return the URL being processed by the ioslave  Only access it inside prepareUDSEntry()      </short>
		protected KUrl ProcessedUrl() {
			return (KUrl) interceptor.Invoke("processedUrl", "processedUrl() const", typeof(KUrl));
		}
		/// <remarks>
		///  Return the URL asked to the ioslave
		///  Only access it inside prepareUDSEntry()
		///      </remarks>		<short>    Return the URL asked to the ioslave  Only access it inside prepareUDSEntry()      </short>
		protected KUrl RequestedUrl() {
			return (KUrl) interceptor.Invoke("requestedUrl", "requestedUrl() const", typeof(KUrl));
		}
		/// <remarks>
		///  Terminate the slave by calling the destructor and then .Exit()
		///      </remarks>		<short>   </short>
		public void Exit() {
			interceptor.Invoke("exit", "exit()", typeof(void));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public void DispatchLoop() {
			interceptor.Invoke("dispatchLoop", "dispatchLoop()", typeof(void));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public void SetConnection(KIO.Connection connection) {
			interceptor.Invoke("setConnection#", "setConnection(KIO::Connection*)", typeof(void), typeof(KIO.Connection), connection);
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public KIO.Connection Connection() {
			return (KIO.Connection) interceptor.Invoke("connection", "connection() const", typeof(KIO.Connection));
		}
		/// <remarks>
		///  Sends data in the slave to the job (i.e. in get).
		///  To signal end of data, simply send an empty
		///  QByteArray().
		/// <param> name="data" the data read by the slave
		///      </param></remarks>		<short>    Sends data in the slave to the job (i.</short>
		public void Data(QByteArray data) {
			interceptor.Invoke("data#", "data(const QByteArray&)", typeof(void), typeof(QByteArray), data);
		}
		/// <remarks>
		///  Asks for data from the job.
		/// </remarks>		<short>    Asks for data from the job.</short>
		/// 		<see> readData</see>
		public void DataReq() {
			interceptor.Invoke("dataReq", "dataReq()", typeof(void));
		}
		/// <remarks>
		///  open succedes
		/// </remarks>		<short>    open succedes </short>
		/// 		<see> open</see>
		public void Opened() {
			interceptor.Invoke("opened", "opened()", typeof(void));
		}
		/// <remarks>
		///  Call to signal an error.
		///  This also finishes the job, no need to call finished.
		///  If the Error code is KIO.ERR_SLAVE_DEFINED then the
		///  _text should contain the complete translated text of
		///  of the error message.  This message will be displayed
		///  in an KTextBrowser which allows rich text complete
		///  with hyper links.  Email links will call the default
		///  mailer, "exec:/command arg1 arg2" will be forked and
		///  all other links will call the default browser.
		/// <param> name="_errid" the error code from KIO.Error
		/// </param><param> name="_text" the rich text error message
		///      </param></remarks>		<short>    Call to signal an error.</short>
		/// 		<see> Error</see>
		/// 		<see> KTextBrowser</see>
		public void error(int _errid, string _text) {
			interceptor.Invoke("error$$", "error(int, const QString&)", typeof(void), typeof(int), _errid, typeof(string), _text);
		}
		/// <remarks>
		///  Call in openConnection, if you reimplement it, when you're done.
		///      </remarks>		<short>    Call in openConnection, if you reimplement it, when you're done.</short>
		public void Connected() {
			interceptor.Invoke("connected", "connected()", typeof(void));
		}
		/// <remarks>
		///  Call to signal successful completion of any command
		///  (besides openConnection and closeConnection)
		///      </remarks>		<short>    Call to signal successful completion of any command  (besides openConnection and closeConnection)      </short>
		public void Finished() {
			interceptor.Invoke("finished", "finished()", typeof(void));
		}
		/// <remarks>
		///  Call to signal that data from the sub-URL is needed
		///      </remarks>		<short>    Call to signal that data from the sub-URL is needed      </short>
		public void NeedSubUrlData() {
			interceptor.Invoke("needSubUrlData", "needSubUrlData()", typeof(void));
		}
		/// <remarks>
		///  Used to report the status of the slave.
		/// <param> name="host" the slave is currently connected to. (Should be
		///         empty if not connected)
		/// </param><param> name="connected" Whether an actual network connection exists.
		/// </param></remarks>		<short>    Used to report the status of the slave.</short>
		public void SlaveStatus(string host, bool connected) {
			interceptor.Invoke("slaveStatus$$", "slaveStatus(const QString&, bool)", typeof(void), typeof(string), host, typeof(bool), connected);
		}
		/// <remarks>
		///  Call this from stat() to express details about an object, the
		///  UDSEntry customarily contains the atoms describing file name, size,
		///  mimetype, etc.
		/// <param> name="_entry" The UDSEntry containing all of the object attributes.
		///      </param></remarks>		<short>    Call this from stat() to express details about an object, the  UDSEntry customarily contains the atoms describing file name, size,  mimetype, etc.</short>
		public void StatEntry(KIO.UDSEntry _entry) {
			interceptor.Invoke("statEntry#", "statEntry(const KIO::UDSEntry&)", typeof(void), typeof(KIO.UDSEntry), _entry);
		}
		/// <remarks>
		///  Call this in listDir, each time you have a bunch of entries
		///  to report.
		/// <param> name="_entry" The UDSEntry containing all of the object attributes.
		///      </param></remarks>		<short>    Call this in listDir, each time you have a bunch of entries  to report.</short>
		/// <remarks>
		///  Call this at the beginning of put(), to give the size of the existing
		///  partial file, if there is one. The <code>offset</code> argument notifies the
		///  other job (the one that gets the data) about the offset to use.
		///  In this case, the boolean returns whether we can indeed resume or not
		///  (we can't if the protocol doing the get() doesn't support setting an offset)
		///      </remarks>		<short>    Call this at the beginning of put(), to give the size of the existing  partial file, if there is one.</short>
		public bool CanResume(long offset) {
			return (bool) interceptor.Invoke("canResume$", "canResume(KIO::filesize_t)", typeof(bool), typeof(long), offset);
		}
		public void CanResume() {
			interceptor.Invoke("canResume", "canResume()", typeof(void));
		}
		/// <remarks>
		///  Call this in get and copy, to give the total size
		///  of the file
		///  Call in listDir too, when you know the total number of items.
		///      </remarks>		<short>    Call this in get and copy, to give the total size  of the file  Call in listDir too, when you know the total number of items.</short>
		public void TotalSize(long _bytes) {
			interceptor.Invoke("totalSize$", "totalSize(KIO::filesize_t)", typeof(void), typeof(long), _bytes);
		}
		/// <remarks>
		///  Call this during get and copy, once in a while,
		///  to give some info about the current state.
		///  Don't emit it in listDir, listEntries speaks for itself.
		///      </remarks>		<short>    Call this during get and copy, once in a while,  to give some info about the current state.</short>
		public void ProcessedSize(long _bytes) {
			interceptor.Invoke("processedSize$", "processedSize(KIO::filesize_t)", typeof(void), typeof(long), _bytes);
		}
		public void Position(long _pos) {
			interceptor.Invoke("position$", "position(KIO::filesize_t)", typeof(void), typeof(long), _pos);
		}
		public void Written(long _bytes) {
			interceptor.Invoke("written$", "written(KIO::filesize_t)", typeof(void), typeof(long), _bytes);
		}
		/// <remarks>
		///  Only use this if you can't know in advance the size of the
		///  copied data. For example, if you're doing variable bitrate
		///  compression of the source.
		///  STUB ! Currently unimplemented. Here now for binary compatibility.
		///  Call this during get and copy, once in a while,
		///  to give some info about the current state.
		///  Don't emit it in listDir, listEntries speaks for itself.
		///      </remarks>		<short>    Only use this if you can't know in advance the size of the  copied data.</short>
		public void ProcessedPercent(float percent) {
			interceptor.Invoke("processedPercent$", "processedPercent(float)", typeof(void), typeof(float), percent);
		}
		/// <remarks>
		///  Call this in get and copy, to give the current transfer
		///  speed, but only if it can't be calculated out of the size you
		///  passed to processedSize (in most cases you don't want to call it)
		///      </remarks>		<short>    Call this in get and copy, to give the current transfer  speed, but only if it can't be calculated out of the size you  passed to processedSize (in most cases you don't want to call it)      </short>
		public void Speed(ulong _bytes_per_second) {
			interceptor.Invoke("speed$", "speed(unsigned long)", typeof(void), typeof(ulong), _bytes_per_second);
		}
		/// <remarks>
		///  Call this to signal a redirection
		///  The job will take care of going to that url.
		///      </remarks>		<short>    Call this to signal a redirection  The job will take care of going to that url.</short>
		public void Redirection(KUrl _url) {
			interceptor.Invoke("redirection#", "redirection(const KUrl&)", typeof(void), typeof(KUrl), _url);
		}
		/// <remarks>
		///  Tell that we will only get an error page here.
		///  This means: the data you'll get isn't the data you requested,
		///  but an error page (usually HTML) that describes an error.
		///      </remarks>		<short>    Tell that we will only get an error page here.</short>
		public void ErrorPage() {
			interceptor.Invoke("errorPage", "errorPage()", typeof(void));
		}
		/// <remarks>
		///  Call this in mimetype() and in get(), when you know the mimetype.
		///  See mimetype about other ways to implement it.
		///      </remarks>		<short>    Call this in mimetype() and in get(), when you know the mimetype.</short>
		public void MimeType(string _type) {
			interceptor.Invoke("mimeType$", "mimeType(const QString&)", typeof(void), typeof(string), _type);
		}
		/// <remarks>
		///  Call to signal a warning, to be displayed in a dialog box.
		///      </remarks>		<short>    Call to signal a warning, to be displayed in a dialog box.</short>
		public void Warning(string msg) {
			interceptor.Invoke("warning$", "warning(const QString&)", typeof(void), typeof(string), msg);
		}
		/// <remarks>
		///  Call to signal a message, to be displayed if the application wants to,
		///  for instance in a status bar. Usual examples are "connecting to host xyz", etc.
		///      </remarks>		<short>    Call to signal a message, to be displayed if the application wants to,  for instance in a status bar.</short>
		public void InfoMessage(string msg) {
			interceptor.Invoke("infoMessage$", "infoMessage(const QString&)", typeof(void), typeof(string), msg);
		}
		/// <remarks>
		///  Call this to show a message box from the slave
		/// <param> name="type" type of message box: QuestionYesNo, WarningYesNo, WarningContinueCancel...
		/// </param><param> name="text" Message string. May contain newlines.
		/// </param><param> name="caption" Message box title.
		/// </param><param> name="buttonYes" The text for the first button.
		///                   The default is i18n("&Yes").
		/// </param><param> name="buttonNo" The text for the second button.
		///                   The default is i18n("&No").
		///  Note: for ContinueCancel, buttonYes is the continue button and buttonNo is unused.
		///        and for Information, none is used.
		/// </param></remarks>		<return> a button code, as defined in KMessageBox, or 0 on communication error.
		///      </return>
		/// 		<short>    Call this to show a message box from the slave </short>
		/// <remarks>
		///  Call this to show a message box from the slave
		/// <param> name="text" Message string. May contain newlines.
		/// </param><param> name="type" type of message box: QuestionYesNo, WarningYesNo, WarningContinueCancel...
		/// </param><param> name="caption" Message box title.
		/// </param><param> name="buttonYes" The text for the first button.
		///                   The default is i18n("&Yes").
		/// </param><param> name="buttonNo" The text for the second button.
		///                   The default is i18n("&No").
		///  Note: for ContinueCancel, buttonYes is the continue button and buttonNo is unused.
		///        and for Information, none is used.
		/// </param><param> name="dontAskAgainName" A checkbox is added with which further confirmation can be turned off.
		///         The string is used to lookup and store the setting in kioslaverc.
		/// </param></remarks>		<return> a button code, as defined in KMessageBox, or 0 on communication error.
		///      </return>
		/// 		<short>    Call this to show a message box from the slave </short>
		/// <remarks>
		///  Sets meta-data to be send to the application before the first
		///  data() or finished() signal.
		///      </remarks>		<short>    Sets meta-data to be send to the application before the first  data() or finished() signal.</short>
		public void SetMetaData(string key, string value) {
			interceptor.Invoke("setMetaData$$", "setMetaData(const QString&, const QString&)", typeof(void), typeof(string), key, typeof(string), value);
		}
		/// <remarks>
		///  Queries for the existence of a certain config/meta-data entry
		///  send by the application to the slave.
		///      </remarks>		<short>    Queries for the existence of a certain config/meta-data entry  send by the application to the slave.</short>
		public bool HasMetaData(string key) {
			return (bool) interceptor.Invoke("hasMetaData$", "hasMetaData(const QString&) const", typeof(bool), typeof(string), key);
		}
		/// <remarks>
		///  Queries for config/meta-data send by the application to the slave.
		///      </remarks>		<short>    Queries for config/meta-data send by the application to the slave.</short>
		public string MetaData(string key) {
			return (string) interceptor.Invoke("metaData$", "metaData(const QString&) const", typeof(string), typeof(string), key);
		}
		/// <remarks>
		///  Contains all metadata (but no config) sent by the application to the slave.
		///      </remarks>		<short>   </short>
		public KIO.MetaData AllMetaData() {
			return (KIO.MetaData) interceptor.Invoke("allMetaData", "allMetaData() const", typeof(KIO.MetaData));
		}
		/// <remarks>
		///  Returns a configuration object to query config/meta-data information
		///  from.
		///  The application provides the slave with all configuration information
		///  relevant for the current protocol and host.
		///      </remarks>		<short>    Returns a configuration object to query config/meta-data information  from.</short>
		public KConfigGroup Config() {
			return (KConfigGroup) interceptor.Invoke("config", "config()", typeof(KConfigGroup));
		}
		/// <remarks>
		///  Returns an object that can translate remote filenames into proper
		///  Unicode forms. This encoding can be set by the user.
		///      </remarks>		<short>    Returns an object that can translate remote filenames into proper  Unicode forms.</short>
		public KRemoteEncoding RemoteEncoding() {
			return (KRemoteEncoding) interceptor.Invoke("remoteEncoding", "remoteEncoding()", typeof(KRemoteEncoding));
		}
		/// <remarks>
		///  Set the host
		/// <param> name="pass"  Called directly by createSlave, this is why there is no equivalent in
		///  SlaveInterface, unlike the other methods.
		/// </param> This method is called whenever a change in host, port or user occurs.
		///      </remarks>		<short>    Set the host </short>
		[SmokeMethod("setHost(const QString&, quint16, const QString&, const QString&)")]
		public virtual void SetHost(string host, ushort port, string user, string pass) {
			interceptor.Invoke("setHost$$$$", "setHost(const QString&, quint16, const QString&, const QString&)", typeof(void), typeof(string), host, typeof(ushort), port, typeof(string), user, typeof(string), pass);
		}
		/// <remarks>
		///  Prepare slave for streaming operation
		///      </remarks>		<short>    Prepare slave for streaming operation      </short>
		[SmokeMethod("setSubUrl(const KUrl&)")]
		public virtual void SetSubUrl(KUrl url) {
			interceptor.Invoke("setSubUrl#", "setSubUrl(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		/// <remarks>
		///  Opens the connection (forced)
		///  When this function gets called the slave is operating in
		///  connection-oriented mode.
		///  When a connection gets lost while the slave operates in
		///  connection oriented mode, the slave should report
		///  ERR_CONNECTION_BROKEN instead of reconnecting. The user is
		///  expected to disconnect the slave in the error handler.
		///      </remarks>		<short>    Opens the connection (forced)  When this function gets called the slave is operating in  connection-oriented mode.</short>
		[SmokeMethod("openConnection()")]
		public virtual void OpenConnection() {
			interceptor.Invoke("openConnection", "openConnection()", typeof(void));
		}
		/// <remarks>
		///  Closes the connection (forced)
		///  Called when the application disconnects the slave to close
		///  any open network connections.
		///  When the slave was operating in connection-oriented mode,
		///  it should reset itself to connectionless (default) mode.
		///      </remarks>		<short>    Closes the connection (forced)  Called when the application disconnects the slave to close  any open network connections.</short>
		[SmokeMethod("closeConnection()")]
		public virtual void CloseConnection() {
			interceptor.Invoke("closeConnection", "closeConnection()", typeof(void));
		}
		/// <remarks>
		///  open.
		/// <param> name="url" the full url for this request. Host, port and user of the URL
		///         can be assumed to be the same as in the last setHost() call.
		/// </param><param> name="mode" see \ref QIODevice.OpenMode
		///      </param></remarks>		<short>    open.</short>
		[SmokeMethod("open(const KUrl&, QIODevice::OpenMode)")]
		public virtual void Open(KUrl url, int mode) {
			interceptor.Invoke("open#$", "open(const KUrl&, QIODevice::OpenMode)", typeof(void), typeof(KUrl), url, typeof(int), mode);
		}
		/// <remarks>
		///  Change the destination of a symlink
		/// <param> name="url" the url of the symlink to modify
		/// </param><param> name="target" the new destination (target) of the symlink
		///      </param></remarks>		<short>    Change the destination of a symlink </short>
		[SmokeMethod("setLinkDest(const KUrl&, const QString&)")]
		public virtual void SetLinkDest(KUrl url, string target) {
			interceptor.Invoke("setLinkDest#$", "setLinkDest(const KUrl&, const QString&)", typeof(void), typeof(KUrl), url, typeof(string), target);
		}
		/// <remarks>
		///  Used for any command that is specific to this slave (protocol)
		///  Examples are : HTTP POST, mount and unmount (kio_file)
		/// <param> name="data" packed data; the meaning is completely dependent on the
		///         slave, but usually starts with an int for the command number.
		///  Document your slave's commands, at least in its header file.
		///      </param></remarks>		<short>    Used for any command that is specific to this slave (protocol)  Examples are : HTTP POST, mount and unmount (kio_file) </short>
		[SmokeMethod("special(const QByteArray&)")]
		public virtual void Special(QByteArray data) {
			interceptor.Invoke("special#", "special(const QByteArray&)", typeof(void), typeof(QByteArray), data);
		}
		/// <remarks>
		///  Used for multiple get. Currently only used foir HTTP pielining
		///  support.
		/// <param> name="data" packed data; Contains number of URLs to fetch, and for
		///  each URL the URL itself and its associated MetaData.
		///      </param></remarks>		<short>    Used for multiple get.</short>
		[SmokeMethod("multiGet(const QByteArray&)")]
		public virtual void MultiGet(QByteArray data) {
			interceptor.Invoke("multiGet#", "multiGet(const QByteArray&)", typeof(void), typeof(QByteArray), data);
		}
		/// <remarks>
		///  Called to get the status of the slave. Slave should respond
		///  by calling slaveStatus(...)
		///      </remarks>		<short>    Called to get the status of the slave.</short>
		[SmokeMethod("slave_status()")]
		public virtual void Slave_status() {
			interceptor.Invoke("slave_status", "slave_status()", typeof(void));
		}
		/// <remarks>
		///  Called by the scheduler to tell the slave that the configuration
		///  changed (i.e. proxy settings) .
		///      </remarks>		<short>    Called by the scheduler to tell the slave that the configuration  changed (i.</short>
		[SmokeMethod("reparseConfiguration()")]
		public virtual void ReparseConfiguration() {
			interceptor.Invoke("reparseConfiguration", "reparseConfiguration()", typeof(void));
		}
		/// <remarks>
		/// </remarks>		<return> timeout value for connecting to remote host.
		///      </return>
		/// 		<short>   </short>
		public int ConnectTimeout() {
			return (int) interceptor.Invoke("connectTimeout", "connectTimeout()", typeof(int));
		}
		/// <remarks>
		/// </remarks>		<return> timeout value for connecting to proxy in secs.
		///      </return>
		/// 		<short>   </short>
		public int ProxyConnectTimeout() {
			return (int) interceptor.Invoke("proxyConnectTimeout", "proxyConnectTimeout()", typeof(int));
		}
		/// <remarks>
		/// </remarks>		<return> timeout value for read from first data from
		///  remote host in seconds.
		///      </return>
		/// 		<short>   </short>
		public int ResponseTimeout() {
			return (int) interceptor.Invoke("responseTimeout", "responseTimeout()", typeof(int));
		}
		/// <remarks>
		/// </remarks>		<return> timeout value for read from subsequent data from
		///  remote host in secs.
		///      </return>
		/// 		<short>   </short>
		public int ReadTimeout() {
			return (int) interceptor.Invoke("readTimeout", "readTimeout()", typeof(int));
		}
		/// <remarks>
		///  This function sets a timeout of <code>timeout</code> seconds and calls
		///  special(data) when the timeout occurs as if it was called by the
		///  application.
		///  A timeout can only occur when the slave is waiting for a command
		///  from the application.
		///  Specifying a negative timeout cancels a pending timeout.
		///  Only one timeout at a time is supported, setting a timeout
		///  cancels any pending timeout.
		///      </remarks>		<short>    This function sets a timeout of <code>timeout</code> seconds and calls  special(data) when the timeout occurs as if it was called by the  application.</short>
		public void SetTimeoutSpecialCommand(int timeout, QByteArray data) {
			interceptor.Invoke("setTimeoutSpecialCommand$#", "setTimeoutSpecialCommand(int, const QByteArray&)", typeof(void), typeof(int), timeout, typeof(QByteArray), data);
		}
		public void SetTimeoutSpecialCommand(int timeout) {
			interceptor.Invoke("setTimeoutSpecialCommand$", "setTimeoutSpecialCommand(int)", typeof(void), typeof(int), timeout);
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		[SmokeMethod("dispatch()")]
		public virtual bool Dispatch() {
			return (bool) interceptor.Invoke("dispatch", "dispatch()", typeof(bool));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		[SmokeMethod("dispatch(int, const QByteArray&)")]
		public virtual void Dispatch(int command, QByteArray data) {
			interceptor.Invoke("dispatch$#", "dispatch(int, const QByteArray&)", typeof(void), typeof(int), command, typeof(QByteArray), data);
		}
		/// <remarks>
		///  Read data send by the job, after a dataReq
		/// <param> name="buffer" buffer where data is stored
		/// </param></remarks>		<return> 0 on end of data,
		///          > 0 bytes read
		///          < 0 error
		/// </return>
		/// 		<short>    Read data send by the job, after a dataReq </short>
		public int ReadData(QByteArray buffer) {
			return (int) interceptor.Invoke("readData#", "readData(QByteArray&)", typeof(int), typeof(QByteArray), buffer);
		}
		/// <remarks>
		///  internal function to be called by the slave.
		///  It collects entries and emits them via listEntries
		///  when enough of them are there or a certain time
		///  frame exceeded (to make sure the app gets some
		///  items in time but not too many items one by one
		///  as this will cause a drastic performance penalty)
		/// <param> name="_entry" The UDSEntry containing all of the object attributes.
		/// </param><param> name="ready" set to true after emitting all items. <code>_entry</code> is not
		///         used in this case
		///      </param></remarks>		<short>    internal function to be called by the slave.</short>
		public void ListEntry(KIO.UDSEntry _entry, bool ready) {
			interceptor.Invoke("listEntry#$", "listEntry(const KIO::UDSEntry&, bool)", typeof(void), typeof(KIO.UDSEntry), _entry, typeof(bool), ready);
		}
		/// <remarks>
		///  internal function to connect a slave to/ disconnect from
		///  either the slave pool or the application
		///      </remarks>		<short>    internal function to connect a slave to/ disconnect from  either the slave pool or the application      </short>
		public void ConnectSlave(string path) {
			interceptor.Invoke("connectSlave$", "connectSlave(const QString&)", typeof(void), typeof(string), path);
		}
		public void DisconnectSlave() {
			interceptor.Invoke("disconnectSlave", "disconnectSlave()", typeof(void));
		}
		/// <remarks>
		///  Prompt the user for Authorization info (login & password).
		///  Use this function to request authorization information from
		///  the end user. You can also pass an error message which explains
		///  why a previous authorization attempt failed. Here is a very
		///  simple example:
		///  <pre>
		///  KIO.AuthInfo authInfo;
		///  if ( openPasswordDialog( authInfo ) )
		///  {
		///     kDebug() << QLatin1String("User: ")
		///               << authInfo.username << endl;
		///     kDebug() << QLatin1String("Password: ")
		///               << QLatin1String("Not displayed here!") << endl;
		///  }
		///  </pre>
		///  You can also preset some values like the username, caption or
		///  comment as follows:
		///  <pre>
		///  KIO.AuthInfo authInfo;
		///  authInfo.caption= "Acme Password Dialog";
		///  authInfo.username= "Wile E. Coyote";
		///  string errorMsg = "You entered an incorrect password.";
		///  if ( openPasswordDialog( authInfo, errorMsg ) )
		///  {
		///     kDebug() << QLatin1String("User: ")
		///               << authInfo.username << endl;
		///     kDebug() << QLatin1String("Password: ")
		///               << QLatin1String("Not displayed here!") << endl;
		///  }
		///  </pre>
		///  <b>Note:<> You should consider using checkCachedAuthentication() to
		///  see if the password is available in kpasswdserver before calling
		///  this function.
		///  <b>Note:<> A call to this function can fail and return <code>false</code>,
		///  if the UIServer could not be started for whatever reason.
		/// <param> name="info" See AuthInfo.
		/// </param><param> name="errorMsg" Error message to show
		/// </param></remarks>		<return> <code>true</code> if user clicks on "OK", <code>false</code> otherwsie.
		///      </return>
		/// 		<short>    Prompt the user for Authorization info (login & password).</short>
		/// 		<see> checkCachedAuthentication</see>
		public bool OpenPasswordDialog(KIO.AuthInfo info, string errorMsg) {
			return (bool) interceptor.Invoke("openPasswordDialog#$", "openPasswordDialog(KIO::AuthInfo&, const QString&)", typeof(bool), typeof(KIO.AuthInfo), info, typeof(string), errorMsg);
		}
		public bool OpenPasswordDialog(KIO.AuthInfo info) {
			return (bool) interceptor.Invoke("openPasswordDialog#", "openPasswordDialog(KIO::AuthInfo&)", typeof(bool), typeof(KIO.AuthInfo), info);
		}
		/// <remarks>
		///  Used by the slave to check if it can connect
		///  to a given host. This should be called where the slave is ready
		///  to do a .Connect() on a socket. For each call to
		///  requestNetwork must exist a matching call to
		///  dropNetwork, or the system will stay online until
		///  KNetMgr gets closed (or the SlaveBase gets destructed)!
		///  If KNetMgr is not running, then this is a no-op and returns true
		/// <param> name="host" tells the netmgr the host the slave wants to connect
		///              to. As this could also be a proxy, we can't just take
		///              the host currenctly connected to (but that's the default
		///              value)
		/// </param></remarks>		<return> true in theorie, the host is reachable
		///          false the system is offline and the host is in a remote network.
		///      </return>
		/// 		<short>    Used by the slave to check if it can connect  to a given host.</short>
		public bool RequestNetwork(string host) {
			return (bool) interceptor.Invoke("requestNetwork$", "requestNetwork(const QString&)", typeof(bool), typeof(string), host);
		}
		public bool RequestNetwork() {
			return (bool) interceptor.Invoke("requestNetwork", "requestNetwork()", typeof(bool));
		}
		/// <remarks>
		///  Used by the slave to withdraw a connection requested by
		///  requestNetwork. This function cancels the last call to
		///  requestNetwork. If a client uses more than one internet
		///  connection, it must use dropNetwork(host) to
		///  stop each request.
		///  If KNetMgr is not running, then this is a no-op.
		/// <param> name="host" the host passed to requestNetwork
		/// </param> A slave should call this function every time it disconnect from a host.
		///  </remarks>		<short>    Used by the slave to withdraw a connection requested by  requestNetwork.</short>
		public void DropNetwork(string host) {
			interceptor.Invoke("dropNetwork$", "dropNetwork(const QString&)", typeof(void), typeof(string), host);
		}
		public void DropNetwork() {
			interceptor.Invoke("dropNetwork", "dropNetwork()", typeof(void));
		}
		/// <remarks>
		///  Wait for an answer to our request, until we get <code>expected1</code> or <code>expected2</code>
		/// </remarks>		<return> the result from readData, as well as the cmd in *pCmd if set, and the data in <code>data</code>
		///      </return>
		/// 		<short>    Wait for an answer to our request, until we get <code>expected1</code> or <code>expected2</code> </short>
		public int WaitForAnswer(int expected1, int expected2, QByteArray data, ref int pCmd) {
			StackItem[] stack = new StackItem[5];
			stack[1].s_int = expected1;
			stack[2].s_int = expected2;
#if DEBUG
			stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(data);
#else
			stack[3].s_class = (IntPtr) GCHandle.Alloc(data);
#endif
			stack[4].s_int = pCmd;
			interceptor.Invoke("waitForAnswer$$#$", "waitForAnswer(int, int, QByteArray&, int*)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
			((GCHandle) stack[3].s_class).Free();
#endif
			pCmd = stack[4].s_int;
			return stack[0].s_int;
		}
		public int WaitForAnswer(int expected1, int expected2, QByteArray data) {
			return (int) interceptor.Invoke("waitForAnswer$$#", "waitForAnswer(int, int, QByteArray&)", typeof(int), typeof(int), expected1, typeof(int), expected2, typeof(QByteArray), data);
		}
		/// <remarks>
		///  Internal function to transmit meta data to the application.
		///      </remarks>		<short>    Internal function to transmit meta data to the application.</short>
		public void SendMetaData() {
			interceptor.Invoke("sendMetaData", "sendMetaData()", typeof(void));
		}
		/// <remarks> If your ioslave was killed by a signal, wasKilled() returns true.
		///      Check it regularly in lengthy functions (e.g. in get();) and return
		///      as fast as possible from this function if wasKilled() returns true.
		///      This will ensure that your slave destructor will be called correctly.
		///      </remarks>		<short>   If your ioslave was killed by a signal, wasKilled() returns true.</short>
		public bool WasKilled() {
			return (bool) interceptor.Invoke("wasKilled", "wasKilled() const", typeof(bool));
		}
		/// <remarks> Internally used.
		///      </remarks>		<short>   Internally used.</short>
		public void SetKillFlag() {
			interceptor.Invoke("setKillFlag", "setKillFlag()", typeof(void));
		}
		protected new IForwardingSlaveBaseSignals Emit {
			get { return (IForwardingSlaveBaseSignals) Q_EMIT; }
		}
	}

	public interface IForwardingSlaveBaseSignals : IQObjectSignals {
	}
	}
}
