//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KParts {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  A generic factory object to create a Part.
	///  Factory is an abstract class. Reimplement the
	///  createPartObject() method to give it functionality.
	/// </remarks>		<short>    A generic factory object to create a Part.</short>
	/// 		<see> KLibFactory.</see>

	[SmokeClass("KParts::Factory")]
	public abstract class Factory : KLibFactory {
 		protected Factory(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Factory), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static Factory() {
			staticInterceptor = new SmokeInvocation(typeof(Factory), null);
		}
		public Factory(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Factory#", "Factory(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public Factory() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Factory", "Factory()", typeof(void));
		}
		/// <remarks>
		///  Creates a part.
		///  The List<string> can be used to pass additional arguments to the part.
		///  If the part needs additional arguments, it should take them as
		///  name="value" pairs. This is the way additional arguments will get passed
		///  to the part from eg. khtml. You can for example emebed the part into HTML
		///  by using the following code:
		///  <pre>
		///     <object type="my_mimetype" data="url_to_my_data">
		///         <param name="name1" value="value1">
		///         <param name="name2" value="value2">
		///     </object>
		///  </pre>
		///  This could result in a call to
		///  <pre>
		///      createPart( parentWidget, parentObject, "KParts.Part",
		///                  List<string>("name1="value1"", "name2="value2") );
		///  </pre>
		///  createPart() automatically emits a signal KLibFactory.ObjectCreated to tell
		///  the library about its newly created object.  This is very
		///  important for reference counting, and allows unloading the
		///  library automatically once all its objects have been destroyed.
		///      </remarks>		<return> the newly created part.
		/// </return>
		/// 		<short>    Creates a part.</short>
		public KParts.Part CreatePart(QWidget parentWidget, QObject parent, string classname, List<string> args) {
			return (KParts.Part) interceptor.Invoke("createPart##$?", "createPart(QWidget*, QObject*, const char*, const QStringList&)", typeof(KParts.Part), typeof(QWidget), parentWidget, typeof(QObject), parent, typeof(string), classname, typeof(List<string>), args);
		}
		public KParts.Part CreatePart(QWidget parentWidget, QObject parent, string classname) {
			return (KParts.Part) interceptor.Invoke("createPart##$", "createPart(QWidget*, QObject*, const char*)", typeof(KParts.Part), typeof(QWidget), parentWidget, typeof(QObject), parent, typeof(string), classname);
		}
		public KParts.Part CreatePart(QWidget parentWidget, QObject parent) {
			return (KParts.Part) interceptor.Invoke("createPart##", "createPart(QWidget*, QObject*)", typeof(KParts.Part), typeof(QWidget), parentWidget, typeof(QObject), parent);
		}
		public KParts.Part CreatePart(QWidget parentWidget) {
			return (KParts.Part) interceptor.Invoke("createPart#", "createPart(QWidget*)", typeof(KParts.Part), typeof(QWidget), parentWidget);
		}
		public KParts.Part CreatePart() {
			return (KParts.Part) interceptor.Invoke("createPart", "createPart()", typeof(KParts.Part));
		}
		/// <remarks>
		///  If you have a part contained in a shared library you might want to query
		///  for meta-information like the about-data, or the KComponentData in general.
		///  If the part is exported using KParts.GenericFactory then this method will
		///  return the instance that belongs to the part without the need to instantiate
		///  the part component.
		///       </remarks>		<short>    If you have a part contained in a shared library you might want to query  for meta-information like the about-data, or the KComponentData in general.</short>
		[SmokeMethod("partComponentData()")]
		public virtual KComponentData PartComponentData() {
			return (KComponentData) interceptor.Invoke("partComponentData", "partComponentData()", typeof(KComponentData));
		}
		/// <remarks>
		///  Reimplement this method in your implementation to create the Part.
		///  The List<string> can be used to pass additional arguments to the part.
		///  If the part needs additional arguments, it should take them as
		///  name="value" pairs. This is the way additional arguments will get passed
		///  to the part from eg. khtml. You can for example emebed the part into HTML
		///  by using the following code:
		///  <pre>
		///     <object type="my_mimetype" data="url_to_my_data">
		///         <param name="name1" value="value1">
		///         <param name="name2" value="value2">
		///     </object>
		///  </pre>
		///  This could result in a call to
		///  <pre>
		///      createPart( parentWidget, parentObject, "KParts.Part",
		///                  List<string>("name1="value1"", "name2="value2") );
		///  </pre>
		/// </remarks>		<return> the newly created part.
		///      </return>
		/// 		<short>    Reimplement this method in your implementation to create the Part.</short>
		[SmokeMethod("createPartObject(QWidget*, QObject*, const char*, const QStringList&)")]
		protected abstract KParts.Part CreatePartObject(QWidget parentWidget, QObject parent, string classname, List<string> args);
		/// <remarks>
		///  Reimplemented from KLibFactory. Calls createPart()
		///      </remarks>		<short>    Reimplemented from KLibFactory.</short>
		[SmokeMethod("createObject(QObject*, const char*, const QStringList&)")]
		protected override QObject CreateObject(QObject parent, string classname, List<string> args) {
			return (QObject) interceptor.Invoke("createObject#$?", "createObject(QObject*, const char*, const QStringList&)", typeof(QObject), typeof(QObject), parent, typeof(string), classname, typeof(List<string>), args);
		}
		[SmokeMethod("createObject(QObject*, const char*)")]
		protected virtual QObject CreateObject(QObject parent, string classname) {
			return (QObject) interceptor.Invoke("createObject#$", "createObject(QObject*, const char*)", typeof(QObject), typeof(QObject), parent, typeof(string), classname);
		}
		[SmokeMethod("createObject(QObject*)")]
		protected virtual QObject CreateObject(QObject parent) {
			return (QObject) interceptor.Invoke("createObject#", "createObject(QObject*)", typeof(QObject), typeof(QObject), parent);
		}
		[SmokeMethod("createObject()")]
		protected virtual QObject CreateObject() {
			return (QObject) interceptor.Invoke("createObject", "createObject()", typeof(QObject));
		}
		/// <remarks>
		///  A convenience method for partComponentData that takes care of retrieving
		///  the factory for a given library name and calling partComponentData on it.
		/// <param> name="libraryName" name of the library to query the instance from
		///       </param></remarks>		<short>    A convenience method for partComponentData that takes care of retrieving  the factory for a given library name and calling partComponentData on it.</short>
		public static KComponentData PartComponentDataFromLibrary(string libraryName) {
			return (KComponentData) staticInterceptor.Invoke("partComponentDataFromLibrary$", "partComponentDataFromLibrary(const QString&)", typeof(KComponentData), typeof(string), libraryName);
		}
		protected new IFactorySignals Emit {
			get { return (IFactorySignals) Q_EMIT; }
		}
	}

	public interface IFactorySignals : IKLibFactorySignals {
	}
	}
}
