//Auto-generated by kalyptus. DO NOT EDIT.
namespace KParts {

	using Kimono;
	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;

	/// <remarks>
	///  A plugin is the way to add actions to an existing KParts application,
	///  or to a Part.
	///  The XML of those plugins looks exactly like of the shell or parts,
	///  with one small difference: The document tag should have an additional
	///  attribute, named "library", and contain the name of the library implementing
	///  the plugin.
	///  If you want this plugin to be used by a part, you need to
	///  install the rc file under the directory
	///  "data" (KDEDIR/share/apps usually)+"/instancename/kpartplugins/"
	///  where instancename is the name of the part's instance.
	///  You should also install a "plugin info" .desktop file with the same name.
	///  \see KPluginInfo
	///  For a tutorial on how to write plugins, see http://developer.kde.org/documentation/tutorials/developing-a-plugin-structure/index.html#developing_plugins
	///  </remarks>		<short>    A plugin is the way to add actions to an existing KParts application,  or to a Part.</short>

	[SmokeClass("KParts::Plugin")]
	public class Plugin : QObject, IKXMLGUIClient, IDisposable {
 		protected Plugin(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Plugin), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static Plugin() {
			staticInterceptor = new SmokeInvocation(typeof(Plugin), null);
		}
		// void loadPlugins(QObject* arg1,const QList<KParts::Plugin::PluginInfo>& arg2); >>>> NOT CONVERTED
		// void loadPlugins(QObject* arg1,const QList<KParts::Plugin::PluginInfo>& arg2,const KComponentData& arg3); >>>> NOT CONVERTED
		// QList<KParts::Plugin::PluginInfo> pluginInfos(const KComponentData& arg1); >>>> NOT CONVERTED
		// KXMLGUIClient::StateChange getActionsToChangeForState(const QString& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  Construct a new KParts plugin.
		///      </remarks>		<short>    Construct a new KParts plugin.</short>
		public Plugin(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Plugin#", "Plugin(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public Plugin() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Plugin", "Plugin()", typeof(void));
		}
		/// <remarks>
		///  Reimplemented for internal reasons
		///      </remarks>		<short>    Reimplemented for internal reasons      </short>
		[SmokeMethod("xmlFile() const")]
		public virtual string XmlFile() {
			return (string) interceptor.Invoke("xmlFile", "xmlFile() const", typeof(string));
		}
		/// <remarks>
		///  Reimplemented for internal reasons
		///      </remarks>		<short>    Reimplemented for internal reasons      </short>
		[SmokeMethod("localXMLFile() const")]
		public virtual string LocalXMLFile() {
			return (string) interceptor.Invoke("localXMLFile", "localXMLFile() const", typeof(string));
		}
		[SmokeMethod("setComponentData(const KComponentData&)")]
		protected virtual void SetComponentData(KComponentData instance) {
			interceptor.Invoke("setComponentData#", "setComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), instance);
		}
		~Plugin() {
			interceptor.Invoke("~Plugin", "~Plugin()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~Plugin", "~Plugin()", typeof(void));
		}
		/// <remarks>
		///  Retrieves an action of the client by name.  If not found, it looks in its child clients.
		///  This method is provided for convenience, as it uses actionCollection()
		///  to get the action object.
		///    </remarks>		<short>    Retrieves an action of the client by name.</short>
		public QAction Action(string name) {
			return (QAction) interceptor.Invoke("action$", "action(const char*) const", typeof(QAction), typeof(string), name);
		}
		/// <remarks>
		///  Retrieves an action for a given QDomElement. The default
		///  implementation uses the "name" attribute to query the action
		///  object via the other action() method.
		///    </remarks>		<short>    Retrieves an action for a given QDomElement.</short>
		[SmokeMethod("action(const QDomElement&) const")]
		public virtual QAction Action(QDomElement element) {
			return (QAction) interceptor.Invoke("action#", "action(const QDomElement&) const", typeof(QAction), typeof(QDomElement), element);
		}
		/// <remarks>
		///  Retrieves the entire action collection for the GUI client.
		///    </remarks>		<short>    Retrieves the entire action collection for the GUI client.</short>
		[SmokeMethod("actionCollection() const")]
		public virtual KActionCollection ActionCollection() {
			return (KActionCollection) interceptor.Invoke("actionCollection", "actionCollection() const", typeof(KActionCollection));
		}
		/// <remarks>
		/// </remarks>		<return> The componentData ( KComponentData ) for this GUI client.
		///    </return>
		/// 		<short>   </short>
		[SmokeMethod("componentData() const")]
		public virtual KComponentData ComponentData() {
			return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
		}
		/// <remarks>
		/// </remarks>		<return> The parsed XML in a QDomDocument, set by
		///  setXMLFile() or setXML().
		///  This document describes the layout of the GUI.
		///    </return>
		/// 		<short>   </short>
		[SmokeMethod("domDocument() const")]
		public virtual QDomDocument DomDocument() {
			return (QDomDocument) interceptor.Invoke("domDocument", "domDocument() const", typeof(QDomDocument));
		}
		/// <remarks>
		///    </remarks>		<short>   </short>
		public void SetXMLGUIBuildDocument(QDomDocument doc) {
			interceptor.Invoke("setXMLGUIBuildDocument#", "setXMLGUIBuildDocument(const QDomDocument&)", typeof(void), typeof(QDomDocument), doc);
		}
		/// <remarks>
		///    </remarks>		<short>   </short>
		public QDomDocument XmlguiBuildDocument() {
			return (QDomDocument) interceptor.Invoke("xmlguiBuildDocument", "xmlguiBuildDocument() const", typeof(QDomDocument));
		}
		/// <remarks>
		///  This method is called by the KXMLGUIFactory as soon as the client
		///  is added to the KXMLGUIFactory's GUI.
		///    </remarks>		<short>    This method is called by the KXMLGUIFactory as soon as the client  is added to the KXMLGUIFactory's GUI.</short>
		public void SetFactory(KXMLGUIFactory factory) {
			interceptor.Invoke("setFactory#", "setFactory(KXMLGUIFactory*)", typeof(void), typeof(KXMLGUIFactory), factory);
		}
		/// <remarks>
		///  Retrieves a pointer to the KXMLGUIFactory this client is
		///  associated with (will return 0 if the client's GUI has not been built
		///  by a KXMLGUIFactory.
		///    </remarks>		<short>    Retrieves a pointer to the KXMLGUIFactory this client is  associated with (will return 0 if the client's GUI has not been built  by a KXMLGUIFactory.</short>
		public KXMLGUIFactory Factory() {
			return (KXMLGUIFactory) interceptor.Invoke("factory", "factory() const", typeof(KXMLGUIFactory));
		}
		/// <remarks>
		///  KXMLGUIClients can form a simple child/parent object tree. This
		///  method returns a pointer to the parent client or 0 if it has no
		///  parent client assigned.
		///    </remarks>		<short>    KXMLGUIClients can form a simple child/parent object tree.</short>
		public KXMLGUIClient ParentClient() {
			return (KXMLGUIClient) interceptor.Invoke("parentClient", "parentClient() const", typeof(KXMLGUIClient));
		}
		/// <remarks>
		///  Use this method to make a client a child client of another client.
		///  Usually you don't need to call this method, as it is called
		///  automatically when using the second constructor, which takes a
		///  parent argument.
		///    </remarks>		<short>    Use this method to make a client a child client of another client.</short>
		public void InsertChildClient(KXMLGUIClient child) {
			interceptor.Invoke("insertChildClient#", "insertChildClient(KXMLGUIClient*)", typeof(void), typeof(KXMLGUIClient), child);
		}
		/// <remarks>
		///  Removes the given <code>child</code> from the client's children list.
		///    </remarks>		<short>    Removes the given <code>child</code> from the client's children list.</short>
		public void RemoveChildClient(KXMLGUIClient child) {
			interceptor.Invoke("removeChildClient#", "removeChildClient(KXMLGUIClient*)", typeof(void), typeof(KXMLGUIClient), child);
		}
		/// <remarks>
		///  Retrieves a list of all child clients.
		///    </remarks>		<short>    Retrieves a list of all child clients.</short>
		public List<KXMLGUIClient> ChildClients() {
			return (List<KXMLGUIClient>) interceptor.Invoke("childClients", "childClients()", typeof(List<KXMLGUIClient>));
		}
		/// <remarks>
		///  A client can have an own KXMLGUIBuilder.
		///  Use this method to assign your builder instance to the client (so that the
		///  KXMLGUIFactory can use it when building the client's GUI)
		///  Client specific guibuilders are useful if you want to create
		///  custom container widgets for your GUI.
		///    </remarks>		<short>    A client can have an own KXMLGUIBuilder.</short>
		public void SetClientBuilder(KXMLGUIBuilder builder) {
			interceptor.Invoke("setClientBuilder#", "setClientBuilder(KXMLGUIBuilder*)", typeof(void), typeof(KXMLGUIBuilder), builder);
		}
		/// <remarks>
		///  Retrieves the client's GUI builder or 0 if no client specific
		///  builder has been assigned via setClientBuilder()
		///    </remarks>		<short>    Retrieves the client's GUI builder or 0 if no client specific  builder has been assigned via setClientBuilder()    </short>
		public KXMLGUIBuilder ClientBuilder() {
			return (KXMLGUIBuilder) interceptor.Invoke("clientBuilder", "clientBuilder() const", typeof(KXMLGUIBuilder));
		}
		/// <remarks>
		///  Forces this client to re-read its XML resource file.  This is
		///  intended to be used when you know that the resource file has
		///  changed and you will soon be rebuilding the GUI.  It has no
		///  useful effect with non-KParts GUIs, so don't bother using it
		///  unless your app is component based.
		///    </remarks>		<short>    Forces this client to re-read its XML resource file.</short>
		public void ReloadXML() {
			interceptor.Invoke("reloadXML", "reloadXML()", typeof(void));
		}
		/// <remarks>
		///  ActionLists are a way for XMLGUI to support dynamic lists of
		///  actions.  E.g. if you are writing a file manager, and there is a
		///  menu file whose contents depend on the mimetype of the file that
		///  is selected, then you can achieve this using ActionLists. It
		///  works as follows:
		///  In your xxxui.rc file ( the one that you set in setXMLFile() / pass to setupGUI()
		///  ), you put a tag <tt>\<ActionList name="xxx"\></tt>.
		///  Example:
		///  <pre>
		///  <kpartgui name="xxx_part" version="1">
		///  <MenuBar>
		///    <Menu name="file">
		///      ...  <!-- some useful actions-->
		///      <ActionList name="xxx_file_actionlist" />
		///      ...  <!-- even more useful actions-->
		///    </Menu>
		///    ...
		///  </MenuBar>
		///  </kpartgui>
		///  </pre>
		///  This tag will get expanded to a list of actions.  In the example
		///  above ( a file manager with a dynamic file menu ), you would call
		///  <pre>
		///  QList<QAction> file_actions;
		///  for( ... )
		///    if( ... )
		///      file_actions.append( cool_action );
		///  unplugActionList( "xxx_file_actionlist" );
		///  plugActionList( "xxx_file_actionlist", file_actions );
		///  </pre>
		///  every time a file is selected, unselected or ...
		///  <b>Note:<> You should not call createGUI() after calling this
		///        function.  In fact, that would remove the newly added
		///        actionlists again...
		///  <b>Note:<> Forgetting to call unplugActionList() before
		///        plugActionList() would leave the previous actions in the
		///        menu too..
		///  \see unplugActionList()
		///    </remarks>		<short>    ActionLists are a way for XMLGUI to support dynamic lists of  actions.</short>
		public void PlugActionList(string name, List<QAction> actionList) {
			interceptor.Invoke("plugActionList$?", "plugActionList(const QString&, const QList<QAction*>&)", typeof(void), typeof(string), name, typeof(List<QAction>), actionList);
		}
		/// <remarks>
		///  Unplugs the action list <pre>name</pre> from the XMLGUI.
		///  Calling this removes the specified action list, i.e. this is the
		///  complement to plugActionList(). See plugActionList() for a more
		///  detailed example.
		///  \see plugActionList()
		///    </remarks>		<short>    Unplugs the action list \p name from the XMLGUI.</short>
		public void UnplugActionList(string name) {
			interceptor.Invoke("unplugActionList$", "unplugActionList(const QString&)", typeof(void), typeof(string), name);
		}
		public void AddStateActionEnabled(string state, string action) {
			interceptor.Invoke("addStateActionEnabled$$", "addStateActionEnabled(const QString&, const QString&)", typeof(void), typeof(string), state, typeof(string), action);
		}
		public void AddStateActionDisabled(string state, string action) {
			interceptor.Invoke("addStateActionDisabled$$", "addStateActionDisabled(const QString&, const QString&)", typeof(void), typeof(string), state, typeof(string), action);
		}
		public void BeginXMLPlug(QWidget arg1) {
			interceptor.Invoke("beginXMLPlug#", "beginXMLPlug(QWidget*)", typeof(void), typeof(QWidget), arg1);
		}
		public void EndXMLPlug() {
			interceptor.Invoke("endXMLPlug", "endXMLPlug()", typeof(void));
		}
		public void PrepareXMLUnplug(QWidget arg1) {
			interceptor.Invoke("prepareXMLUnplug#", "prepareXMLUnplug(QWidget*)", typeof(void), typeof(QWidget), arg1);
		}
		/// <remarks>
		///  Sets the name of the rc file containing the XML for the part.
		///  Call this in the Part-inherited class constructor.
		///  If you're writing usual application, use KXmlGuiWindow.SetupGUI() with non-default arguments
		/// <param> name="file" Either an absolute path for the file, or simply the
		///              filename, which will then be assumed to be installed
		///              in the "data" resource, under a directory named like
		///              the componentData.
		/// </param><param> name="merge" Whether to merge with the global document.
		/// </param><param> name="setXMLDoc" Specify whether to call setXML. Default is true.
		///                and the DOM document at once.
		/// </param></remarks>		<short>    Sets the name of the rc file containing the XML for the part.</short>
		[SmokeMethod("setXMLFile(const QString&, bool, bool)")]
		protected virtual void SetXMLFile(string file, bool merge, bool setXMLDoc) {
			interceptor.Invoke("setXMLFile$$$", "setXMLFile(const QString&, bool, bool)", typeof(void), typeof(string), file, typeof(bool), merge, typeof(bool), setXMLDoc);
		}
		[SmokeMethod("setXMLFile(const QString&, bool)")]
		protected virtual void SetXMLFile(string file, bool merge) {
			interceptor.Invoke("setXMLFile$$", "setXMLFile(const QString&, bool)", typeof(void), typeof(string), file, typeof(bool), merge);
		}
		[SmokeMethod("setXMLFile(const QString&)")]
		protected virtual void SetXMLFile(string file) {
			interceptor.Invoke("setXMLFile$", "setXMLFile(const QString&)", typeof(void), typeof(string), file);
		}
		[SmokeMethod("setLocalXMLFile(const QString&)")]
		protected virtual void SetLocalXMLFile(string file) {
			interceptor.Invoke("setLocalXMLFile$", "setLocalXMLFile(const QString&)", typeof(void), typeof(string), file);
		}
		/// <remarks>
		///  Sets the XML for the part.
		///  Call this in the Part-inherited class constructor if you
		///   don't call setXMLFile().
		/// </remarks>		<short>    Sets the XML for the part.</short>
		[SmokeMethod("setXML(const QString&, bool)")]
		protected virtual void SetXML(string document, bool merge) {
			interceptor.Invoke("setXML$$", "setXML(const QString&, bool)", typeof(void), typeof(string), document, typeof(bool), merge);
		}
		[SmokeMethod("setXML(const QString&)")]
		protected virtual void SetXML(string document) {
			interceptor.Invoke("setXML$", "setXML(const QString&)", typeof(void), typeof(string), document);
		}
		/// <remarks>
		///  Sets the Document for the part, describing the layout of the GUI.
		///  Call this in the Part-inherited class constructor if you don't call
		///  setXMLFile or setXML .
		///    </remarks>		<short>    Sets the Document for the part, describing the layout of the GUI.</short>
		[SmokeMethod("setDOMDocument(const QDomDocument&, bool)")]
		protected virtual void SetDOMDocument(QDomDocument document, bool merge) {
			interceptor.Invoke("setDOMDocument#$", "setDOMDocument(const QDomDocument&, bool)", typeof(void), typeof(QDomDocument), document, typeof(bool), merge);
		}
		[SmokeMethod("setDOMDocument(const QDomDocument&)")]
		protected virtual void SetDOMDocument(QDomDocument document) {
			interceptor.Invoke("setDOMDocument#", "setDOMDocument(const QDomDocument&)", typeof(void), typeof(QDomDocument), document);
		}
		/// <remarks>
		///  Actions can collectively be assigned a "State". To accomplish this
		///  the respective actions are tagged as \<enable\> or \<disable\> in
		///  a \<State\> \</State\> group of the XMLfile. During program execution the
		///  programmer can call stateChanged() to set actions to a defined state.
		/// <param> name="newstate" Name of a State in the XMLfile.
		/// </param><param> name="reverse" If the flag reverse is set to StateReverse, the State is reversed.
		///  (actions to be enabled will be disabled and action to be disabled will be enabled)
		///  Default is reverse=false.
		///    </param></remarks>		<short>    Actions can collectively be assigned a "State".</short>
		[SmokeMethod("stateChanged(const QString&, KXMLGUIClient::ReverseStateChange)")]
		protected virtual void StateChanged(string newstate, KXMLGUIClient.ReverseStateChange reverse) {
			interceptor.Invoke("stateChanged$$", "stateChanged(const QString&, KXMLGUIClient::ReverseStateChange)", typeof(void), typeof(string), newstate, typeof(KXMLGUIClient.ReverseStateChange), reverse);
		}
		[SmokeMethod("stateChanged(const QString&)")]
		protected virtual void StateChanged(string newstate) {
			interceptor.Invoke("stateChanged$", "stateChanged(const QString&)", typeof(void), typeof(string), newstate);
		}
		/// <remarks>
		///  Load the plugin libraries from the directories appropriate
		///  to <code>instance</code> and make the Plugin objects children of <code>parent.</code>
		///  It is recommended to use the last loadPlugins method instead,
		///  to support enabling and disabling of plugins.
		///      </remarks>		<short>    Load the plugin libraries from the directories appropriate  to <code>instance</code> and make the Plugin objects children of <code>parent.</code></short>
		public static void LoadPlugins(QObject parent, KComponentData instance) {
			staticInterceptor.Invoke("loadPlugins##", "loadPlugins(QObject*, const KComponentData&)", typeof(void), typeof(QObject), parent, typeof(KComponentData), instance);
		}
		/// <remarks>
		///  Load the plugin libraries specified by the list <code>docs</code> and make the
		///  Plugin objects children of <code>parent</code> .
		///  It is recommended to use the last loadPlugins method instead,
		///  to support enabling and disabling of plugins.
		///      </remarks>		<short>    Load the plugin libraries specified by the list <code>docs</code> and make the  Plugin objects children of <code>parent</code> .</short>
		/// <remarks>
		///  Load the plugin libraries specified by the list <code>pluginInfos</code>, make the
		///  Plugin objects children of <code>parent</code>, and use the given <code>instance.</code>
		///  It is recommended to use the last loadPlugins method instead,
		///  to support enabling and disabling of plugins.
		///      </remarks>		<short>    Load the plugin libraries specified by the list <code>pluginInfos</code>, make the  Plugin objects children of <code>parent</code>, and use the given <code>instance.</code></short>
		/// <remarks>
		///  Load the plugin libraries for the given <code>instance</code>, make the
		///  Plugin objects children of <code>parent</code>, and insert the plugin as a child GUI client
		///  of <code>parentGUIClient.</code>
		///  This method uses the KConfig object of the given instance, to find out which
		///  plugins are enabled and which are disabled. What happens by default (i.e.
		///  for new plugins that are not in that config file) is controlled by
		///  <code>enableNewPluginsByDefault.</code> It can be overridden by the plugin if it
		///  sets the X-KDE-PluginInfo-EnabledByDefault key in the .desktop file
		///  (with the same name as the .rc file)
		///  If a disabled plugin is already loaded it will be removed from the GUI
		///  factory and deleted.
		///  If you change the binary interface offered by your part, you can avoid crashes
		///  from old plugins lying around by setting X-KDE-InterfaceVersion=2 in the
		///  .desktop files of the plugins, and passing 2 to <code>interfaceVersionRequired</code>, so that
		///  the old plugins are not loaded. Increase both numbers every time a
		///  binary incompatible change in the application's plugin interface is made.
		///  This method is automatically called by KParts.Part and by KParts.MainWindow.
		///  If you call this method in an already constructed GUI (like when the user
		///  has changed which plugins are enabled) you need to add the new plugins to
		///  the KXMLGUIFactory:
		///  <pre>
		///  if( factory() )
		///  {
		///    const QList<KParts.Plugin > plugins = KParts.Plugin.PluginObjects( this );
		///    foreach ( KParts.Plugin  plugin, plugins )
		///      factory().AddClient( plugin );
		///  }
		///  </pre>
		///      </remarks>		<short>    Load the plugin libraries for the given <code>instance</code>, make the  Plugin objects children of <code>parent</code>, and insert the plugin as a child GUI client  of <code>parentGUIClient.</code></short>
		/// 		<see> PartBase.SetPluginLoadingMode</see>
		/// 		<see> PartBase.SetPluginInterfaceVersion</see>
		public static void LoadPlugins(QObject parent, KXMLGUIClient parentGUIClient, KComponentData instance, bool enableNewPluginsByDefault, int interfaceVersionRequired) {
			staticInterceptor.Invoke("loadPlugins###$$", "loadPlugins(QObject*, KXMLGUIClient*, const KComponentData&, bool, int)", typeof(void), typeof(QObject), parent, typeof(KXMLGUIClient), parentGUIClient, typeof(KComponentData), instance, typeof(bool), enableNewPluginsByDefault, typeof(int), interfaceVersionRequired);
		}
		public static void LoadPlugins(QObject parent, KXMLGUIClient parentGUIClient, KComponentData instance, bool enableNewPluginsByDefault) {
			staticInterceptor.Invoke("loadPlugins###$", "loadPlugins(QObject*, KXMLGUIClient*, const KComponentData&, bool)", typeof(void), typeof(QObject), parent, typeof(KXMLGUIClient), parentGUIClient, typeof(KComponentData), instance, typeof(bool), enableNewPluginsByDefault);
		}
		public static void LoadPlugins(QObject parent, KXMLGUIClient parentGUIClient, KComponentData instance) {
			staticInterceptor.Invoke("loadPlugins###", "loadPlugins(QObject*, KXMLGUIClient*, const KComponentData&)", typeof(void), typeof(QObject), parent, typeof(KXMLGUIClient), parentGUIClient, typeof(KComponentData), instance);
		}
		/// <remarks>
		///  Returns a list of plugin objects loaded for <code>parent.</code> This
		///  functions basically calls the queryList method of
		///  QObject to retrieve the list of child objects inheriting
		///  KParts.Plugin .
		/// </remarks>		<short>    Returns a list of plugin objects loaded for <code>parent.</code></short>
		public static List<KParts.Plugin> PluginObjects(QObject parent) {
			return (List<KParts.Plugin>) staticInterceptor.Invoke("pluginObjects#", "pluginObjects(QObject*)", typeof(List<KParts.Plugin>), typeof(QObject), parent);
		}
		/// <remarks>
		///  Look for plugins in the <code>instance</code>'s "data" directory (+"/kpartplugins")
		/// </remarks>		<return> A list of QDomDocument s, containing the parsed xml documents returned by plugins.
		///      </return>
		/// 		<short>    Look for plugins in the <code>instance</code>'s "data" directory (+"/kpartplugins") </short>
		/// <remarks>
		/// </remarks>		<return> The plugin created from the library <code>libname</code>
		///      </return>
		/// 		<short>   </short>
		protected static KParts.Plugin LoadPlugin(QObject parent, string libname) {
			return (KParts.Plugin) staticInterceptor.Invoke("loadPlugin#$", "loadPlugin(QObject*, const char*)", typeof(KParts.Plugin), typeof(QObject), parent, typeof(string), libname);
		}
		public static string FindMostRecentXMLFile(List<string> files, StringBuilder doc) {
			return (string) staticInterceptor.Invoke("findMostRecentXMLFile?$", "findMostRecentXMLFile(const QStringList&, QString&)", typeof(string), typeof(List<string>), files, typeof(StringBuilder), doc);
		}
		protected new IPluginSignals Emit {
			get { return (IPluginSignals) Q_EMIT; }
		}
	}

	public interface IPluginSignals : IQObjectSignals {
	}
}
