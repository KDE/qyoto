//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
	using System;
	using System.Collections.Generic;
	[SmokeClass("QPolygonF")]
	public partial class QPolygonF : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected QPolygonF(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QPolygonF), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QPolygonF() {
			staticInterceptor = new SmokeInvocation(typeof(QPolygonF), null);
		}
		public QPolygonF() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF", "QPolygonF()", typeof(void));
		}
		public QPolygonF(int size) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF$", "QPolygonF(int)", typeof(void), typeof(int), size);
		}
		public QPolygonF(QPolygonF a) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF#", "QPolygonF(const QPolygonF&)", typeof(void), typeof(QPolygonF), a);
		}
		public QPolygonF(List<QPointF> v) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF?", "QPolygonF(const QVector<QPointF>&)", typeof(void), typeof(List<QPointF>), v);
		}
		public QPolygonF(QRectF r) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF#", "QPolygonF(const QRectF&)", typeof(void), typeof(QRectF), r);
		}
		public QPolygonF(QPolygon a) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QPolygonF#", "QPolygonF(const QPolygon&)", typeof(void), typeof(QPolygon), a);
		}
		public void Translate(double dx, double dy) {
			interceptor.Invoke("translate$$", "translate(qreal, qreal)", typeof(void), typeof(double), dx, typeof(double), dy);
		}
		public void Translate(QPointF offset) {
			interceptor.Invoke("translate#", "translate(const QPointF&)", typeof(void), typeof(QPointF), offset);
		}
		public QPolygon ToPolygon() {
			return (QPolygon) interceptor.Invoke("toPolygon", "toPolygon() const", typeof(QPolygon));
		}
		public bool IsClosed() {
			return (bool) interceptor.Invoke("isClosed", "isClosed() const", typeof(bool));
		}
		public QRectF BoundingRect() {
			return (QRectF) interceptor.Invoke("boundingRect", "boundingRect() const", typeof(QRectF));
		}
		public bool ContainsPoint(QPointF pt, Qt.FillRule fillRule) {
			return (bool) interceptor.Invoke("containsPoint#$", "containsPoint(const QPointF&, Qt::FillRule) const", typeof(bool), typeof(QPointF), pt, typeof(Qt.FillRule), fillRule);
		}
		public QPolygonF United(QPolygonF r) {
			return (QPolygonF) interceptor.Invoke("united#", "united(const QPolygonF&) const", typeof(QPolygonF), typeof(QPolygonF), r);
		}
		public QPolygonF Intersected(QPolygonF r) {
			return (QPolygonF) interceptor.Invoke("intersected#", "intersected(const QPolygonF&) const", typeof(QPolygonF), typeof(QPolygonF), r);
		}
		public QPolygonF Subtracted(QPolygonF r) {
			return (QPolygonF) interceptor.Invoke("subtracted#", "subtracted(const QPolygonF&) const", typeof(QPolygonF), typeof(QPolygonF), r);
		}
		~QPolygonF() {
			interceptor.Invoke("~QPolygonF", "~QPolygonF()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~QPolygonF", "~QPolygonF()", typeof(void));
		}
		public static QPolygonF operator*(QPolygonF a, QMatrix m) {
			return (QPolygonF) staticInterceptor.Invoke("operator*##", "operator*(const QPolygonF&, const QMatrix&)", typeof(QPolygonF), typeof(QPolygonF), a, typeof(QMatrix), m);
		}
		public static QPolygonF operator*(QPolygonF a, QTransform m) {
			return (QPolygonF) staticInterceptor.Invoke("operator*##", "operator*(const QPolygonF&, const QTransform&)", typeof(QPolygonF), typeof(QPolygonF), a, typeof(QTransform), m);
		}
	}
}
