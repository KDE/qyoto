//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {

	using System;

	[SmokeClass("QSslKey")]
	public class QSslKey : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected QSslKey(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QSslKey), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QSslKey() {
			staticInterceptor = new SmokeInvocation(typeof(QSslKey), null);
		}
		public QSslKey() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey", "QSslKey()", typeof(void));
		}
		public QSslKey(QByteArray encoded, QSsl.Algorithm algorithm, QSsl.EncodingFormat format, QSsl.KeyType type, QByteArray passPhrase) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$$#", "QSslKey(const QByteArray&, QSsl::Algorithm, QSsl::EncodingFormat, QSsl::KeyType, const QByteArray&)", typeof(void), typeof(QByteArray), encoded, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format, typeof(QSsl.KeyType), type, typeof(QByteArray), passPhrase);
		}
		public QSslKey(QByteArray encoded, QSsl.Algorithm algorithm, QSsl.EncodingFormat format, QSsl.KeyType type) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$$", "QSslKey(const QByteArray&, QSsl::Algorithm, QSsl::EncodingFormat, QSsl::KeyType)", typeof(void), typeof(QByteArray), encoded, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format, typeof(QSsl.KeyType), type);
		}
		public QSslKey(QByteArray encoded, QSsl.Algorithm algorithm, QSsl.EncodingFormat format) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$", "QSslKey(const QByteArray&, QSsl::Algorithm, QSsl::EncodingFormat)", typeof(void), typeof(QByteArray), encoded, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format);
		}
		public QSslKey(QByteArray encoded, QSsl.Algorithm algorithm) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$", "QSslKey(const QByteArray&, QSsl::Algorithm)", typeof(void), typeof(QByteArray), encoded, typeof(QSsl.Algorithm), algorithm);
		}
		public QSslKey(QIODevice device, QSsl.Algorithm algorithm, QSsl.EncodingFormat format, QSsl.KeyType type, QByteArray passPhrase) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$$#", "QSslKey(QIODevice*, QSsl::Algorithm, QSsl::EncodingFormat, QSsl::KeyType, const QByteArray&)", typeof(void), typeof(QIODevice), device, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format, typeof(QSsl.KeyType), type, typeof(QByteArray), passPhrase);
		}
		public QSslKey(QIODevice device, QSsl.Algorithm algorithm, QSsl.EncodingFormat format, QSsl.KeyType type) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$$", "QSslKey(QIODevice*, QSsl::Algorithm, QSsl::EncodingFormat, QSsl::KeyType)", typeof(void), typeof(QIODevice), device, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format, typeof(QSsl.KeyType), type);
		}
		public QSslKey(QIODevice device, QSsl.Algorithm algorithm, QSsl.EncodingFormat format) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$$", "QSslKey(QIODevice*, QSsl::Algorithm, QSsl::EncodingFormat)", typeof(void), typeof(QIODevice), device, typeof(QSsl.Algorithm), algorithm, typeof(QSsl.EncodingFormat), format);
		}
		public QSslKey(QIODevice device, QSsl.Algorithm algorithm) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#$", "QSslKey(QIODevice*, QSsl::Algorithm)", typeof(void), typeof(QIODevice), device, typeof(QSsl.Algorithm), algorithm);
		}
		public QSslKey(QSslKey other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QSslKey#", "QSslKey(const QSslKey&)", typeof(void), typeof(QSslKey), other);
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public void Clear() {
			interceptor.Invoke("clear", "clear()", typeof(void));
		}
		public int Length() {
			return (int) interceptor.Invoke("length", "length() const", typeof(int));
		}
		public QSsl.KeyType type() {
			return (QSsl.KeyType) interceptor.Invoke("type", "type() const", typeof(QSsl.KeyType));
		}
		public QSsl.Algorithm Algorithm() {
			return (QSsl.Algorithm) interceptor.Invoke("algorithm", "algorithm() const", typeof(QSsl.Algorithm));
		}
		public QByteArray ToPem(QByteArray passPhrase) {
			return (QByteArray) interceptor.Invoke("toPem#", "toPem(const QByteArray&) const", typeof(QByteArray), typeof(QByteArray), passPhrase);
		}
		public QByteArray ToPem() {
			return (QByteArray) interceptor.Invoke("toPem", "toPem() const", typeof(QByteArray));
		}
		public QByteArray ToDer(QByteArray passPhrase) {
			return (QByteArray) interceptor.Invoke("toDer#", "toDer(const QByteArray&) const", typeof(QByteArray), typeof(QByteArray), passPhrase);
		}
		public QByteArray ToDer() {
			return (QByteArray) interceptor.Invoke("toDer", "toDer() const", typeof(QByteArray));
		}
		public override bool Equals(object o) {
			if (!(o is QSslKey)) { return false; }
			return this == (QSslKey) o;
		}
		public override int GetHashCode() {
			return interceptor.GetHashCode();
		}
		~QSslKey() {
			interceptor.Invoke("~QSslKey", "~QSslKey()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~QSslKey", "~QSslKey()", typeof(void));
		}
		public static bool operator==(QSslKey lhs, QSslKey key) {
			return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QSslKey&) const", typeof(bool), typeof(QSslKey), lhs, typeof(QSslKey), key);
		}
		public static bool operator!=(QSslKey lhs, QSslKey key) {
			return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QSslKey&) const", typeof(bool), typeof(QSslKey), lhs, typeof(QSslKey), key);
		}
	}
}
