//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    using System.Collections.Generic;
    /// <remarks> See <see cref="IQSslSocketSignals"></see> for signals emitted by QSslSocket
    /// </remarks>
    [SmokeClass("QSslSocket")]
    public class QSslSocket : QTcpSocket, IDisposable {
        protected QSslSocket(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QSslSocket), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QSslSocket() {
            staticInterceptor = new SmokeInvocation(typeof(QSslSocket), null);
        }
        public enum SslMode {
            UnencryptedMode = 0,
            SslClientMode = 1,
            SslServerMode = 2,
        }
        public enum PeerVerifyMode {
            VerifyNone = 0,
            QueryPeer = 1,
            VerifyPeer = 2,
            AutoVerifyPeer = 3,
        }
        public QSslSocket(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslSocket#", "QSslSocket(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public QSslSocket() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslSocket", "QSslSocket()", typeof(void));
        }
        public void ConnectToHostEncrypted(string hostName, ushort port, uint mode) {
            interceptor.Invoke("connectToHostEncrypted$$$", "connectToHostEncrypted(const QString&, unsigned short, QIODevice::OpenMode)", typeof(void), typeof(string), hostName, typeof(ushort), port, typeof(uint), mode);
        }
        public void ConnectToHostEncrypted(string hostName, ushort port) {
            interceptor.Invoke("connectToHostEncrypted$$", "connectToHostEncrypted(const QString&, unsigned short)", typeof(void), typeof(string), hostName, typeof(ushort), port);
        }
        public new bool SetSocketDescriptor(int socketDescriptor, QAbstractSocket.SocketState state, uint openMode) {
            return (bool) interceptor.Invoke("setSocketDescriptor$$$", "setSocketDescriptor(int, QAbstractSocket::SocketState, QIODevice::OpenMode)", typeof(bool), typeof(int), socketDescriptor, typeof(QAbstractSocket.SocketState), state, typeof(uint), openMode);
        }
        public new bool SetSocketDescriptor(int socketDescriptor, QAbstractSocket.SocketState state) {
            return (bool) interceptor.Invoke("setSocketDescriptor$$", "setSocketDescriptor(int, QAbstractSocket::SocketState)", typeof(bool), typeof(int), socketDescriptor, typeof(QAbstractSocket.SocketState), state);
        }
        public new bool SetSocketDescriptor(int socketDescriptor) {
            return (bool) interceptor.Invoke("setSocketDescriptor$", "setSocketDescriptor(int)", typeof(bool), typeof(int), socketDescriptor);
        }
        public QSslSocket.SslMode Mode() {
            return (QSslSocket.SslMode) interceptor.Invoke("mode", "mode() const", typeof(QSslSocket.SslMode));
        }
        public bool IsEncrypted() {
            return (bool) interceptor.Invoke("isEncrypted", "isEncrypted() const", typeof(bool));
        }
        public QSsl.SslProtocol Protocol() {
            return (QSsl.SslProtocol) interceptor.Invoke("protocol", "protocol() const", typeof(QSsl.SslProtocol));
        }
        public void SetProtocol(QSsl.SslProtocol protocol) {
            interceptor.Invoke("setProtocol$", "setProtocol(QSsl::SslProtocol)", typeof(void), typeof(QSsl.SslProtocol), protocol);
        }
        public QSslSocket.PeerVerifyMode peerVerifyMode() {
            return (QSslSocket.PeerVerifyMode) interceptor.Invoke("peerVerifyMode", "peerVerifyMode() const", typeof(QSslSocket.PeerVerifyMode));
        }
        public void SetPeerVerifyMode(QSslSocket.PeerVerifyMode mode) {
            interceptor.Invoke("setPeerVerifyMode$", "setPeerVerifyMode(QSslSocket::PeerVerifyMode)", typeof(void), typeof(QSslSocket.PeerVerifyMode), mode);
        }
        public int PeerVerifyDepth() {
            return (int) interceptor.Invoke("peerVerifyDepth", "peerVerifyDepth() const", typeof(int));
        }
        public void SetPeerVerifyDepth(int depth) {
            interceptor.Invoke("setPeerVerifyDepth$", "setPeerVerifyDepth(int)", typeof(void), typeof(int), depth);
        }
        [SmokeMethod("bytesAvailable() const")]
        public override long BytesAvailable() {
            return (long) interceptor.Invoke("bytesAvailable", "bytesAvailable() const", typeof(long));
        }
        [SmokeMethod("bytesToWrite() const")]
        public override long BytesToWrite() {
            return (long) interceptor.Invoke("bytesToWrite", "bytesToWrite() const", typeof(long));
        }
        [SmokeMethod("canReadLine() const")]
        public override bool CanReadLine() {
            return (bool) interceptor.Invoke("canReadLine", "canReadLine() const", typeof(bool));
        }
        [SmokeMethod("close()")]
        public override void Close() {
            interceptor.Invoke("close", "close()", typeof(void));
        }
        [SmokeMethod("atEnd() const")]
        public override bool AtEnd() {
            return (bool) interceptor.Invoke("atEnd", "atEnd() const", typeof(bool));
        }
        public new bool Flush() {
            return (bool) interceptor.Invoke("flush", "flush()", typeof(bool));
        }
        public new void Abort() {
            interceptor.Invoke("abort", "abort()", typeof(void));
        }
        public new void SetReadBufferSize(long size) {
            interceptor.Invoke("setReadBufferSize$", "setReadBufferSize(qint64)", typeof(void), typeof(long), size);
        }
        public long EncryptedBytesAvailable() {
            return (long) interceptor.Invoke("encryptedBytesAvailable", "encryptedBytesAvailable() const", typeof(long));
        }
        public long EncryptedBytesToWrite() {
            return (long) interceptor.Invoke("encryptedBytesToWrite", "encryptedBytesToWrite() const", typeof(long));
        }
        public QSslConfiguration SslConfiguration() {
            return (QSslConfiguration) interceptor.Invoke("sslConfiguration", "sslConfiguration() const", typeof(QSslConfiguration));
        }
        public void SetSslConfiguration(QSslConfiguration config) {
            interceptor.Invoke("setSslConfiguration#", "setSslConfiguration(const QSslConfiguration&)", typeof(void), typeof(QSslConfiguration), config);
        }
        public void SetLocalCertificate(QSslCertificate certificate) {
            interceptor.Invoke("setLocalCertificate#", "setLocalCertificate(const QSslCertificate&)", typeof(void), typeof(QSslCertificate), certificate);
        }
        public void SetLocalCertificate(string fileName, QSsl.EncodingFormat format) {
            interceptor.Invoke("setLocalCertificate$$", "setLocalCertificate(const QString&, QSsl::EncodingFormat)", typeof(void), typeof(string), fileName, typeof(QSsl.EncodingFormat), format);
        }
        public void SetLocalCertificate(string fileName) {
            interceptor.Invoke("setLocalCertificate$", "setLocalCertificate(const QString&)", typeof(void), typeof(string), fileName);
        }
        public QSslCertificate LocalCertificate() {
            return (QSslCertificate) interceptor.Invoke("localCertificate", "localCertificate() const", typeof(QSslCertificate));
        }
        public QSslCertificate PeerCertificate() {
            return (QSslCertificate) interceptor.Invoke("peerCertificate", "peerCertificate() const", typeof(QSslCertificate));
        }
        public List<QSslCertificate> PeerCertificateChain() {
            return (List<QSslCertificate>) interceptor.Invoke("peerCertificateChain", "peerCertificateChain() const", typeof(List<QSslCertificate>));
        }
        public QSslCipher SessionCipher() {
            return (QSslCipher) interceptor.Invoke("sessionCipher", "sessionCipher() const", typeof(QSslCipher));
        }
        public void SetPrivateKey(QSslKey key) {
            interceptor.Invoke("setPrivateKey#", "setPrivateKey(const QSslKey&)", typeof(void), typeof(QSslKey), key);
        }
        public void SetPrivateKey(string fileName, QSsl.KeyAlgorithm algorithm, QSsl.EncodingFormat format, QByteArray passPhrase) {
            interceptor.Invoke("setPrivateKey$$$#", "setPrivateKey(const QString&, QSsl::KeyAlgorithm, QSsl::EncodingFormat, const QByteArray&)", typeof(void), typeof(string), fileName, typeof(QSsl.KeyAlgorithm), algorithm, typeof(QSsl.EncodingFormat), format, typeof(QByteArray), passPhrase);
        }
        public void SetPrivateKey(string fileName, QSsl.KeyAlgorithm algorithm, QSsl.EncodingFormat format) {
            interceptor.Invoke("setPrivateKey$$$", "setPrivateKey(const QString&, QSsl::KeyAlgorithm, QSsl::EncodingFormat)", typeof(void), typeof(string), fileName, typeof(QSsl.KeyAlgorithm), algorithm, typeof(QSsl.EncodingFormat), format);
        }
        public void SetPrivateKey(string fileName, QSsl.KeyAlgorithm algorithm) {
            interceptor.Invoke("setPrivateKey$$", "setPrivateKey(const QString&, QSsl::KeyAlgorithm)", typeof(void), typeof(string), fileName, typeof(QSsl.KeyAlgorithm), algorithm);
        }
        public void SetPrivateKey(string fileName) {
            interceptor.Invoke("setPrivateKey$", "setPrivateKey(const QString&)", typeof(void), typeof(string), fileName);
        }
        public QSslKey PrivateKey() {
            return (QSslKey) interceptor.Invoke("privateKey", "privateKey() const", typeof(QSslKey));
        }
        public List<QSslCipher> Ciphers() {
            return (List<QSslCipher>) interceptor.Invoke("ciphers", "ciphers() const", typeof(List<QSslCipher>));
        }
        public void SetCiphers(List<QSslCipher> ciphers) {
            interceptor.Invoke("setCiphers?", "setCiphers(const QList<QSslCipher>&)", typeof(void), typeof(List<QSslCipher>), ciphers);
        }
        public void SetCiphers(string ciphers) {
            interceptor.Invoke("setCiphers$", "setCiphers(const QString&)", typeof(void), typeof(string), ciphers);
        }
        public bool AddCaCertificates(string path, QSsl.EncodingFormat format, QRegExp.PatternSyntax syntax) {
            return (bool) interceptor.Invoke("addCaCertificates$$$", "addCaCertificates(const QString&, QSsl::EncodingFormat, QRegExp::PatternSyntax)", typeof(bool), typeof(string), path, typeof(QSsl.EncodingFormat), format, typeof(QRegExp.PatternSyntax), syntax);
        }
        public bool AddCaCertificates(string path, QSsl.EncodingFormat format) {
            return (bool) interceptor.Invoke("addCaCertificates$$", "addCaCertificates(const QString&, QSsl::EncodingFormat)", typeof(bool), typeof(string), path, typeof(QSsl.EncodingFormat), format);
        }
        public bool AddCaCertificates(string path) {
            return (bool) interceptor.Invoke("addCaCertificates$", "addCaCertificates(const QString&)", typeof(bool), typeof(string), path);
        }
        public void AddCaCertificate(QSslCertificate certificate) {
            interceptor.Invoke("addCaCertificate#", "addCaCertificate(const QSslCertificate&)", typeof(void), typeof(QSslCertificate), certificate);
        }
        public void AddCaCertificates(List<QSslCertificate> certificates) {
            interceptor.Invoke("addCaCertificates?", "addCaCertificates(const QList<QSslCertificate>&)", typeof(void), typeof(List<QSslCertificate>), certificates);
        }
        public void SetCaCertificates(List<QSslCertificate> certificates) {
            interceptor.Invoke("setCaCertificates?", "setCaCertificates(const QList<QSslCertificate>&)", typeof(void), typeof(List<QSslCertificate>), certificates);
        }
        public List<QSslCertificate> CaCertificates() {
            return (List<QSslCertificate>) interceptor.Invoke("caCertificates", "caCertificates() const", typeof(List<QSslCertificate>));
        }
        public new bool WaitForConnected(int msecs) {
            return (bool) interceptor.Invoke("waitForConnected$", "waitForConnected(int)", typeof(bool), typeof(int), msecs);
        }
        public new bool WaitForConnected() {
            return (bool) interceptor.Invoke("waitForConnected", "waitForConnected()", typeof(bool));
        }
        public bool WaitForEncrypted(int msecs) {
            return (bool) interceptor.Invoke("waitForEncrypted$", "waitForEncrypted(int)", typeof(bool), typeof(int), msecs);
        }
        public bool WaitForEncrypted() {
            return (bool) interceptor.Invoke("waitForEncrypted", "waitForEncrypted()", typeof(bool));
        }
        [SmokeMethod("waitForReadyRead(int)")]
        public override bool WaitForReadyRead(int msecs) {
            return (bool) interceptor.Invoke("waitForReadyRead$", "waitForReadyRead(int)", typeof(bool), typeof(int), msecs);
        }
        public new bool WaitForReadyRead() {
            return (bool) interceptor.Invoke("waitForReadyRead", "waitForReadyRead()", typeof(bool));
        }
        [SmokeMethod("waitForBytesWritten(int)")]
        public override bool WaitForBytesWritten(int msecs) {
            return (bool) interceptor.Invoke("waitForBytesWritten$", "waitForBytesWritten(int)", typeof(bool), typeof(int), msecs);
        }
        public new bool WaitForBytesWritten() {
            return (bool) interceptor.Invoke("waitForBytesWritten", "waitForBytesWritten()", typeof(bool));
        }
        public new bool WaitForDisconnected(int msecs) {
            return (bool) interceptor.Invoke("waitForDisconnected$", "waitForDisconnected(int)", typeof(bool), typeof(int), msecs);
        }
        public new bool WaitForDisconnected() {
            return (bool) interceptor.Invoke("waitForDisconnected", "waitForDisconnected()", typeof(bool));
        }
        public List<QSslError> SslErrors() {
            return (List<QSslError>) interceptor.Invoke("sslErrors", "sslErrors() const", typeof(List<QSslError>));
        }
        [Q_SLOT("void startClientEncryption()")]
        public void StartClientEncryption() {
            interceptor.Invoke("startClientEncryption", "startClientEncryption()", typeof(void));
        }
        [Q_SLOT("void startServerEncryption()")]
        public void StartServerEncryption() {
            interceptor.Invoke("startServerEncryption", "startServerEncryption()", typeof(void));
        }
        [Q_SLOT("void ignoreSslErrors()")]
        public void IgnoreSslErrors() {
            interceptor.Invoke("ignoreSslErrors", "ignoreSslErrors()", typeof(void));
        }
        [SmokeMethod("readData(char*, qint64)")]
        protected override long ReadData(Pointer<sbyte> data, long maxlen) {
            return (long) interceptor.Invoke("readData$$", "readData(char*, qint64)", typeof(long), typeof(Pointer<sbyte>), data, typeof(long), maxlen);
        }
        [SmokeMethod("writeData(const char*, qint64)")]
        protected override long WriteData(string data, long len) {
            return (long) interceptor.Invoke("writeData$$", "writeData(const char*, qint64)", typeof(long), typeof(string), data, typeof(long), len);
        }
        [Q_SLOT("void connectToHostImplementation(QString, quint16, OpenMode)")]
        protected new void ConnectToHostImplementation(string hostName, ushort port, uint openMode) {
            interceptor.Invoke("connectToHostImplementation$$$", "connectToHostImplementation(const QString&, unsigned short, QIODevice::OpenMode)", typeof(void), typeof(string), hostName, typeof(ushort), port, typeof(uint), openMode);
        }
        [Q_SLOT("void disconnectFromHostImplementation()")]
        protected new void DisconnectFromHostImplementation() {
            interceptor.Invoke("disconnectFromHostImplementation", "disconnectFromHostImplementation()", typeof(void));
        }
        ~QSslSocket() {
            interceptor.Invoke("~QSslSocket", "~QSslSocket()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~QSslSocket", "~QSslSocket()", typeof(void));
        }
        public event SlotFunc SignalEncrypted {
            add { QObject.Connect(this, SIGNAL("encrypted()"), value); }
            remove { QObject.Disconnect(this, SIGNAL("encrypted()"), value); }
        }
        public event SlotFunc<QSslError> SignalPeerVerifyError {
            add { QObject.Connect(this, SIGNAL("peerVerifyError(QSslError)"), value); }
            remove { QObject.Disconnect(this, SIGNAL("peerVerifyError(QSslError)"), value); }
        }
        public event SlotFunc<List<QSslError>> SignalSslErrors {
            add { QObject.Connect(this, SIGNAL("sslErrors(QList<QSslError>)"), value); }
            remove { QObject.Disconnect(this, SIGNAL("sslErrors(QList<QSslError>)"), value); }
        }
        public event SlotFunc<QSslSocket.SslMode> SignalModeChanged {
            add { QObject.Connect(this, SIGNAL("modeChanged(QSslSocket::SslMode)"), value); }
            remove { QObject.Disconnect(this, SIGNAL("modeChanged(QSslSocket::SslMode)"), value); }
        }
        public event SlotFunc<long> SignalEncryptedBytesWritten {
            add { QObject.Connect(this, SIGNAL("encryptedBytesWritten(qint64)"), value); }
            remove { QObject.Disconnect(this, SIGNAL("encryptedBytesWritten(qint64)"), value); }
        }
        public static new string Tr(string s, string c) {
            return (string) staticInterceptor.Invoke("tr$$", "tr(const char*, const char*)", typeof(string), typeof(string), s, typeof(string), c);
        }
        public static new string Tr(string s) {
            return (string) staticInterceptor.Invoke("tr$", "tr(const char*)", typeof(string), typeof(string), s);
        }
        public static void SetDefaultCiphers(List<QSslCipher> ciphers) {
            staticInterceptor.Invoke("setDefaultCiphers?", "setDefaultCiphers(const QList<QSslCipher>&)", typeof(void), typeof(List<QSslCipher>), ciphers);
        }
        public static List<QSslCipher> DefaultCiphers() {
            return (List<QSslCipher>) staticInterceptor.Invoke("defaultCiphers", "defaultCiphers()", typeof(List<QSslCipher>));
        }
        public static List<QSslCipher> SupportedCiphers() {
            return (List<QSslCipher>) staticInterceptor.Invoke("supportedCiphers", "supportedCiphers()", typeof(List<QSslCipher>));
        }
        public static bool AddDefaultCaCertificates(string path, QSsl.EncodingFormat format, QRegExp.PatternSyntax syntax) {
            return (bool) staticInterceptor.Invoke("addDefaultCaCertificates$$$", "addDefaultCaCertificates(const QString&, QSsl::EncodingFormat, QRegExp::PatternSyntax)", typeof(bool), typeof(string), path, typeof(QSsl.EncodingFormat), format, typeof(QRegExp.PatternSyntax), syntax);
        }
        public static bool AddDefaultCaCertificates(string path, QSsl.EncodingFormat format) {
            return (bool) staticInterceptor.Invoke("addDefaultCaCertificates$$", "addDefaultCaCertificates(const QString&, QSsl::EncodingFormat)", typeof(bool), typeof(string), path, typeof(QSsl.EncodingFormat), format);
        }
        public static bool AddDefaultCaCertificates(string path) {
            return (bool) staticInterceptor.Invoke("addDefaultCaCertificates$", "addDefaultCaCertificates(const QString&)", typeof(bool), typeof(string), path);
        }
        public static void AddDefaultCaCertificate(QSslCertificate certificate) {
            staticInterceptor.Invoke("addDefaultCaCertificate#", "addDefaultCaCertificate(const QSslCertificate&)", typeof(void), typeof(QSslCertificate), certificate);
        }
        public static void AddDefaultCaCertificates(List<QSslCertificate> certificates) {
            staticInterceptor.Invoke("addDefaultCaCertificates?", "addDefaultCaCertificates(const QList<QSslCertificate>&)", typeof(void), typeof(List<QSslCertificate>), certificates);
        }
        public static void SetDefaultCaCertificates(List<QSslCertificate> certificates) {
            staticInterceptor.Invoke("setDefaultCaCertificates?", "setDefaultCaCertificates(const QList<QSslCertificate>&)", typeof(void), typeof(List<QSslCertificate>), certificates);
        }
        public static List<QSslCertificate> DefaultCaCertificates() {
            return (List<QSslCertificate>) staticInterceptor.Invoke("defaultCaCertificates", "defaultCaCertificates()", typeof(List<QSslCertificate>));
        }
        public static List<QSslCertificate> SystemCaCertificates() {
            return (List<QSslCertificate>) staticInterceptor.Invoke("systemCaCertificates", "systemCaCertificates()", typeof(List<QSslCertificate>));
        }
        public static bool SupportsSsl() {
            return (bool) staticInterceptor.Invoke("supportsSsl", "supportsSsl()", typeof(bool));
        }
        protected new IQSslSocketSignals Emit {
            get { return (IQSslSocketSignals) Q_EMIT; }
        }
    }

    public interface IQSslSocketSignals : IQTcpSocketSignals {
        [Q_SIGNAL("void encrypted()")]
        void Encrypted();
        [Q_SIGNAL("void peerVerifyError(QSslError)")]
        void PeerVerifyError(QSslError error);
        [Q_SIGNAL("void sslErrors(QList<QSslError>)")]
        void SslErrors(List<QSslError> errors);
        [Q_SIGNAL("void modeChanged(QSslSocket::SslMode)")]
        void ModeChanged(QSslSocket.SslMode newMode);
        [Q_SIGNAL("void encryptedBytesWritten(qint64)")]
        void EncryptedBytesWritten(long totalBytes);
    }
}
