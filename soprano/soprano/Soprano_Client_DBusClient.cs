//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Client {
	using Soprano;
	using System;
	using Qyoto;
	using System.Collections.Generic;
	/// <remarks>
	///  \class DBusClient dbusclient.h Soprano/Client/DBusClient
	///  \brief Core class to handle a connection to a Soprano server through the
	///  DBus interface.
	///  DBusClient creates a connection to a running Soprano Server via its DBus
	///  interface. All DBus communication is handled internally.
	///  See DBusModel for details about thread-safety.
	///  \author Sebastian Trueg <trueg@kde.org>
	///  \sa \ref soprano_server_dbus
	///          </remarks>		<short>    \class DBusClient dbusclient.</short>
	[SmokeClass("Soprano::Client::DBusClient")]
	public class DBusClient : QObject, Soprano.Error.IErrorCache, IDisposable {
 		protected DBusClient(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(DBusClient), this);
		}
		// Soprano::Client::DBusModel* createModel(const QString& arg1,const Soprano::BackendSettings& arg2); >>>> NOT CONVERTED
		// Soprano::Error lastError(); >>>> NOT CONVERTED
		// void setError(const Soprano::Error& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  Create a new DBus client.
		///  \param service The DBus service name. If empty the client will use the
		///  default Soprano service name.
		///  \param parent The parent object.
		///              </remarks>		<short>    Create a new DBus client.</short>
		public DBusClient(string service, QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DBusClient$#", "DBusClient(const QString&, QObject*)", typeof(void), typeof(string), service, typeof(QObject), parent);
		}
		public DBusClient(string service) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DBusClient$", "DBusClient(const QString&)", typeof(void), typeof(string), service);
		}
		public DBusClient() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DBusClient", "DBusClient()", typeof(void));
		}
		/// <remarks>
		///  Check if the service is valid and available.
		///  \return <pre>true</pre> if the Soprano server service could be found and used.
		///  Otherwise returns <pre>false</pre>.
		///              </remarks>		<short>    Check if the service is valid and available.</short>
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Retrive a list of all models that are available.
		///  \return A list of model names to be used with createModel()
		///              </remarks>		<short>    Retrive a list of all models that are available.</short>
		public List<string> AllModels() {
			return (List<string>) interceptor.Invoke("allModels", "allModels() const", typeof(List<string>));
		}
		/// <remarks>
		///  Creates a new Model instance that wraps a dbus server model.
		///  \param name The name of the model to access.
		///  \param settings Settings for future extension. Not used yet.
		///  \return A new Model instance wrapping the requested server
		///  model or 0 on error (check lastError() for details.)
		///              </remarks>		<short>    Creates a new Model instance that wraps a dbus server model.</short>
		public Soprano.Client.DBusModel CreateModel(string name) {
			return (Soprano.Client.DBusModel) interceptor.Invoke("createModel$", "createModel(const QString&)", typeof(Soprano.Client.DBusModel), typeof(string), name);
		}
		/// <remarks>
		///  Deletes a model including all its data.
		///  \param name The name of the model to remove.
		///  \warning Calling this method will remove all data physically. It can not
		///  be reverted. Use with care.
		///              </remarks>		<short>    Deletes a model including all its data.</short>
		public void RemoveModel(string name) {
			interceptor.Invoke("removeModel$", "removeModel(const QString&)", typeof(void), typeof(string), name);
		}
		~DBusClient() {
			interceptor.Invoke("~DBusClient", "~DBusClient()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~DBusClient", "~DBusClient()", typeof(void));
		}
		/// <remarks>
		///  Get the last error that occured in the current thread.
		///              </remarks>		<short>    Get the last error that occured in the current thread.</short>
		/// <remarks>
		///  Reset the error for the current thread to no error.
		///              </remarks>		<short>    Reset the error for the current thread to no error.</short>
		protected void ClearError() {
			interceptor.Invoke("clearError", "clearError() const", typeof(void));
		}
		/// <remarks>
		///  Set the last occured error. This method is const to allow setting
		///  of errors in all types of methods. The last error is as such a 
		///  mutable property.
		///              </remarks>		<short>    Set the last occured error.</short>
		/// <remarks>
		///  Convenience method to set simple string error messages with a default
		///  error code ErrorUnknown.
		///              </remarks>		<short>    Convenience method to set simple string error messages with a default  error code ErrorUnknown.</short>
		protected void SetError(string errorMessage, int code) {
			interceptor.Invoke("setError$$", "setError(const QString&, int) const", typeof(void), typeof(string), errorMessage, typeof(int), code);
		}
		protected void SetError(string errorMessage) {
			interceptor.Invoke("setError$", "setError(const QString&) const", typeof(void), typeof(string), errorMessage);
		}
		protected new IDBusClientSignals Emit {
			get { return (IDBusClientSignals) Q_EMIT; }
		}
	}

	public interface IDBusClientSignals : IQObjectSignals {
	}
}
