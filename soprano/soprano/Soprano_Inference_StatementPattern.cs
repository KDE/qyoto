//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Inference {
	using Soprano;
	using System;
	using Qyoto;
	/// <remarks>
	///  \class StatementPattern statementpattern.h Soprano/Inference/StatementPattern
	///  \brief Building block of an inference Rule.
	///  A StatementPattern consists of three NodePattern that can either
	///  be variables or already bound ndoes.
	///  StatementPattern is used to define preconditions and effects in Rule.
	///  \author Sebastian Trueg <trueg@kde.org>
	///          </remarks>		<short>    \class StatementPattern statementpattern.</short>
	[SmokeClass("Soprano::Inference::StatementPattern")]
	public class StatementPattern : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected StatementPattern(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(StatementPattern), this);
		}
		public StatementPattern() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("StatementPattern", "StatementPattern()", typeof(void));
		}
		public StatementPattern(Soprano.Inference.NodePattern arg1, Soprano.Inference.NodePattern arg2, Soprano.Inference.NodePattern arg3) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("StatementPattern###", "StatementPattern(const Soprano::Inference::NodePattern&, const Soprano::Inference::NodePattern&, const Soprano::Inference::NodePattern&)", typeof(void), typeof(Soprano.Inference.NodePattern), arg1, typeof(Soprano.Inference.NodePattern), arg2, typeof(Soprano.Inference.NodePattern), arg3);
		}
		public StatementPattern(Soprano.Inference.StatementPattern arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("StatementPattern#", "StatementPattern(const Soprano::Inference::StatementPattern&)", typeof(void), typeof(Soprano.Inference.StatementPattern), arg1);
		}
		public Soprano.Inference.NodePattern SubjectPattern() {
			return (Soprano.Inference.NodePattern) interceptor.Invoke("subjectPattern", "subjectPattern() const", typeof(Soprano.Inference.NodePattern));
		}
		public Soprano.Inference.NodePattern PredicatePattern() {
			return (Soprano.Inference.NodePattern) interceptor.Invoke("predicatePattern", "predicatePattern() const", typeof(Soprano.Inference.NodePattern));
		}
		public Soprano.Inference.NodePattern ObjectPattern() {
			return (Soprano.Inference.NodePattern) interceptor.Invoke("objectPattern", "objectPattern() const", typeof(Soprano.Inference.NodePattern));
		}
		public bool Match(Soprano.Statement arg1) {
			return (bool) interceptor.Invoke("match#", "match(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), arg1);
		}
		public string CreateSparqlGraphPattern(Soprano.BindingSet bindings) {
			return (string) interceptor.Invoke("createSparqlGraphPattern#", "createSparqlGraphPattern(const Soprano::BindingSet&) const", typeof(string), typeof(Soprano.BindingSet), bindings);
		}
		~StatementPattern() {
			interceptor.Invoke("~StatementPattern", "~StatementPattern()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~StatementPattern", "~StatementPattern()", typeof(void));
		}
	}
}
