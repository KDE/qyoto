//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class RunnerManager plasma/runnermanager.h <Plasma/RunnerManager>
    ///  See <see cref="IRunnerManagerSignals"></see> for signals emitted by RunnerManager
    /// </remarks>        <short> The RunnerManager class decides what installed runners are runnable,         and their ratings. It is the main proxy to the runners.  </short>
    [SmokeClass("Plasma::RunnerManager")]
    public class RunnerManager : QObject, IDisposable {
        protected RunnerManager(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(RunnerManager), this);
        }
        public RunnerManager(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RunnerManager#", "RunnerManager(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public RunnerManager() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RunnerManager", "RunnerManager()", typeof(void));
        }
        public RunnerManager(KConfigGroup config, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RunnerManager##", "RunnerManager(KConfigGroup&, QObject*)", typeof(void), typeof(KConfigGroup), config, typeof(QObject), parent);
        }
        public RunnerManager(KConfigGroup config) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RunnerManager#", "RunnerManager(KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  Finds and returns a loaded runner or NULL
        ///  @arg name the name of the runner
        /// </remarks>        <return> Pointer to the runner
        ///          </return>
        ///         <short>    Finds and returns a loaded runner or NULL  @arg name the name of the runner </short>
        public Plasma.AbstractRunner Runner(string name) {
            return (Plasma.AbstractRunner) interceptor.Invoke("runner$", "runner(const QString&) const", typeof(Plasma.AbstractRunner), typeof(string), name);
        }
        /// <remarks>
        ///  Retrieves the current context
        /// </remarks>        <return> pointer to the current context
        ///          </return>
        ///         <short>    Retrieves the current context </short>
        public Plasma.RunnerContext SearchContext() {
            return (Plasma.RunnerContext) interceptor.Invoke("searchContext", "searchContext() const", typeof(Plasma.RunnerContext));
        }
        /// <remarks>
        ///  Retrieves all available matches found so far for the previously launched query 
        /// </remarks>        <return> List of matches
        ///          </return>
        ///         <short>    Retrieves all available matches found so far for the previously launched query  </short>
        public List<Plasma.QueryMatch> Matches() {
            return (List<Plasma.QueryMatch>) interceptor.Invoke("matches", "matches() const", typeof(List<Plasma.QueryMatch>));
        }
        /// <remarks>
        ///  Runs a given match
        ///  @arg match the match to be executed
        ///          </remarks>        <short>    Runs a given match  @arg match the match to be executed          </short>
        public void Run(Plasma.QueryMatch match) {
            interceptor.Invoke("run#", "run(const Plasma::QueryMatch&)", typeof(void), typeof(Plasma.QueryMatch), match);
        }
        /// <remarks>
        ///  Runs a given match
        ///  @arg id the id of the match to run
        ///          </remarks>        <short>    Runs a given match  @arg id the id of the match to run          </short>
        public void Run(string id) {
            interceptor.Invoke("run$", "run(const QString&)", typeof(void), typeof(string), id);
        }
        /// <remarks>
        /// </remarks>        <return> the current query term
        ///          </return>
        ///         <short>   </short>
        public string Query() {
            return (string) interceptor.Invoke("query", "query() const", typeof(string));
        }
        /// <remarks>
        ///  Causes a reload of the current configuration
        ///          </remarks>        <short>    Causes a reload of the current configuration          </short>
        public void ReloadConfiguration() {
            interceptor.Invoke("reloadConfiguration", "reloadConfiguration()", typeof(void));
        }
        /// <remarks>
        ///  Launch a query, this will create threads and return inmediately.
        ///  When the information will be available can be known using the
        ///  matchesChanged signal.
        ///  @arg term the term we want to find matches for
        ///  @arg runner optional, if only one specific runner is to be used
        ///          </remarks>        <short>    Launch a query, this will create threads and return inmediately.</short>
        [Q_SLOT("void launchQuery(QString, QString)")]
        public void LaunchQuery(string term, string runnerName) {
            interceptor.Invoke("launchQuery$$", "launchQuery(const QString&, const QString&)", typeof(void), typeof(string), term, typeof(string), runnerName);
        }
        /// <remarks>
        ///  Convenience version of above
        ///          </remarks>        <short>    Convenience version of above          </short>
        [Q_SLOT("void launchQuery(QString)")]
        public void LaunchQuery(string term) {
            interceptor.Invoke("launchQuery$", "launchQuery(const QString&)", typeof(void), typeof(string), term);
        }
        /// <remarks>
        ///  Execute a query, this method will only return when the query is executed
        ///  This means that the method may be dangerous as it wait a variable amount
        ///  of time for the runner to finish.
        ///  The runner parameter is mandatory, to avoid launching unwanted runners.
        ///  @arg term the term we want to find matches for
        ///  @arg runner the runner we will use, it is mandatory
        /// </remarks>        <return> 0 if nothing was launched, 1 if launched.
        ///          </return>
        ///         <short>    Execute a query, this method will only return when the query is executed  This means that the method may be dangerous as it wait a variable amount  of time for the runner to finish.</short>
        [Q_SLOT("bool execQuery(QString, QString)")]
        public bool ExecQuery(string term, string runnerName) {
            return (bool) interceptor.Invoke("execQuery$$", "execQuery(const QString&, const QString&)", typeof(bool), typeof(string), term, typeof(string), runnerName);
        }
        /// <remarks>
        ///  Convenience version of above
        ///          </remarks>        <short>    Convenience version of above          </short>
        [Q_SLOT("bool execQuery(QString)")]
        public bool ExecQuery(string term) {
            return (bool) interceptor.Invoke("execQuery$", "execQuery(const QString&)", typeof(bool), typeof(string), term);
        }
        /// <remarks>
        ///  Reset the current data and stops the query
        ///          </remarks>        <short>    Reset the current data and stops the query          </short>
        [Q_SLOT("void reset()")]
        public void Reset() {
            interceptor.Invoke("reset", "reset()", typeof(void));
        }
        ~RunnerManager() {
            interceptor.Invoke("~RunnerManager", "~RunnerManager()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~RunnerManager", "~RunnerManager()", typeof(void));
        }
        protected new IRunnerManagerSignals Emit {
            get { return (IRunnerManagerSignals) Q_EMIT; }
        }
    }

    public interface IRunnerManagerSignals : IQObjectSignals {
        /// <remarks>
        ///  Emitted each time a new match is added to the list
        ///          </remarks>        <short>    Emitted each time a new match is added to the list          </short>
        [Q_SIGNAL("void matchesChanged(QList<Plasma::QueryMatch>)")]
        void MatchesChanged(List<Plasma.QueryMatch> matches);
    }
}
