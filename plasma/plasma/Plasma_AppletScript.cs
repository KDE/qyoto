//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class AppletScript plasma/scripting/appletscript.h <Plasma/Scripting/AppletScript>
    /// </remarks>        <short> Provides a restricted interface for scripted applets.  </short>
    [SmokeClass("Plasma::AppletScript")]
    public class AppletScript : Plasma.ScriptEngine, IDisposable {
        protected AppletScript(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(AppletScript), this);
        }
        /// <remarks>
        ///  Default constructor for an AppletScript.
        ///  Subclasses should not attempt to access the Plasma.Applet
        ///  associated with this AppletScript in the constructor. All
        ///  such set up that requires the Applet itself should be done
        ///  in the init() method.
        ///      </remarks>        <short>    Default constructor for an AppletScript.</short>
        public AppletScript(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AppletScript#", "AppletScript(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public AppletScript() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AppletScript", "AppletScript()", typeof(void));
        }
        /// <remarks>
        ///  Sets the applet associated with this AppletScript
        ///      </remarks>        <short>    Sets the applet associated with this AppletScript      </short>
        public void SetApplet(Plasma.Applet applet) {
            interceptor.Invoke("setApplet#", "setApplet(Plasma::Applet*)", typeof(void), typeof(Plasma.Applet), applet);
        }
        /// <remarks>
        ///  Returns the Plasma.Applet associated with this script component
        ///      </remarks>        <short>    Returns the Plasma.Applet associated with this script component      </short>
        public Plasma.Applet Applet() {
            return (Plasma.Applet) interceptor.Invoke("applet", "applet() const", typeof(Plasma.Applet));
        }
        /// <remarks>
        ///  Called when the script should paint the applet
        /// <param> name="painter" the QPainter to use
        /// </param><param> name="option" the style option containing such flags as selection, level of detail, etc
        /// </param><param> name="contentsRect" the rect to paint within; automatically adjusted for
        ///                      the background, if any
        ///      </param></remarks>        <short>    Called when the script should paint the applet </short>
        [SmokeMethod("paintInterface(QPainter*, const QStyleOptionGraphicsItem*, const QRect&)")]
        public virtual void PaintInterface(QPainter painter, QStyleOptionGraphicsItem option, QRect contentsRect) {
            interceptor.Invoke("paintInterface###", "paintInterface(QPainter*, const QStyleOptionGraphicsItem*, const QRect&)", typeof(void), typeof(QPainter), painter, typeof(QStyleOptionGraphicsItem), option, typeof(QRect), contentsRect);
        }
        /// <remarks>
        ///  Returns the area within which contents can be painted.
        /// </remarks>        <short>    Returns the area within which contents can be painted.</short>
        public QSizeF Size() {
            return (QSizeF) interceptor.Invoke("size", "size() const", typeof(QSizeF));
        }
        /// <remarks>
        ///  Called when any of the geometry constraints have been updated.
        ///  This is always called prior to painting and should be used as an
        ///  opportunity to layout the widget, calculate sizings, etc.
        ///  Do not call update() from this method; an update() will be triggered
        ///  at the appropriate time for the applet.
        /// <param> name="constraints" the type of constraints that were updated
        ///      </param></remarks>        <short>    Called when any of the geometry constraints have been updated.</short>
        [SmokeMethod("constraintsEvent(Plasma::Constraints)")]
        public virtual void ConstraintsEvent(uint constraints) {
            interceptor.Invoke("constraintsEvent$", "constraintsEvent(Plasma::Constraints)", typeof(void), typeof(uint), constraints);
        }
        /// <remarks>
        ///  Returns a list of context-related QAction instances.
        /// </remarks>        <return> A list of actions. The default implementation returns an
        ///          empty list.
        ///      </return>
        ///         <short>    Returns a list of context-related QAction instances.</short>
        [SmokeMethod("contextualActions()")]
        public virtual List<QAction> ContextualActions() {
            return (List<QAction>) interceptor.Invoke("contextualActions", "contextualActions()", typeof(List<QAction>));
        }
        /// <remarks>
        ///  Returns the shape of the widget, defaults to the bounding rect
        ///      </remarks>        <short>    Returns the shape of the widget, defaults to the bounding rect      </short>
        [SmokeMethod("shape() const")]
        public virtual QPainterPath Shape() {
            return (QPainterPath) interceptor.Invoke("shape", "shape() const", typeof(QPainterPath));
        }
        /// <remarks>
        ///  Sets whether or not this script has a configuration interface or not
        ///  @arg hasInterface true if the applet is user configurable
        ///      </remarks>        <short>    Sets whether or not this script has a configuration interface or not </short>
        public void SetHasConfigurationInterface(bool hasInterface) {
            interceptor.Invoke("setHasConfigurationInterface$", "setHasConfigurationInterface(bool)", typeof(void), typeof(bool), hasInterface);
        }
        /// <remarks>
        /// </remarks>        <short>   </short>
        ///         <see> Applet</see>
        public void SetConfigurationRequired(bool req, string reason) {
            interceptor.Invoke("setConfigurationRequired$$", "setConfigurationRequired(bool, const QString&)", typeof(void), typeof(bool), req, typeof(string), reason);
        }
        public void SetConfigurationRequired(bool req) {
            interceptor.Invoke("setConfigurationRequired$", "setConfigurationRequired(bool)", typeof(void), typeof(bool), req);
        }
        /// <remarks>
        /// </remarks>        <short>   </short>
        ///         <see> Applet</see>
        public void SetFailedToLaunch(bool failed, string reason) {
            interceptor.Invoke("setFailedToLaunch$$", "setFailedToLaunch(bool, const QString&)", typeof(void), typeof(bool), failed, typeof(string), reason);
        }
        public void SetFailedToLaunch(bool failed) {
            interceptor.Invoke("setFailedToLaunch$", "setFailedToLaunch(bool)", typeof(void), typeof(bool), failed);
        }
        /// <remarks>
        /// </remarks>        <short>   </short>
        ///         <see> Applet</see>
        public void ConfigNeedsSaving() {
            interceptor.Invoke("configNeedsSaving", "configNeedsSaving() const", typeof(void));
        }
        /// <remarks>
        ///  Show a configuration dialog.
        ///      </remarks>        <short>    Show a configuration dialog.</short>
        [Q_SLOT("void showConfigurationInterface()")]
        [SmokeMethod("showConfigurationInterface()")]
        public virtual void ShowConfigurationInterface() {
            interceptor.Invoke("showConfigurationInterface", "showConfigurationInterface()", typeof(void));
        }
        /// <remarks>
        ///  Configure was changed.
        ///      </remarks>        <short>    Configure was changed.</short>
        [Q_SLOT("void configChanged()")]
        [SmokeMethod("configChanged()")]
        public virtual void ConfigChanged() {
            interceptor.Invoke("configChanged", "configChanged()", typeof(void));
        }
        /// <remarks>
        ///  @arg engine name of the engine
        /// </remarks>        <return> a data engine associated with this plasmoid
        ///      </return>
        ///         <short>    @arg engine name of the engine </short>
        protected Plasma.DataEngine DataEngine(string engine) {
            return (Plasma.DataEngine) interceptor.Invoke("dataEngine$", "dataEngine(const QString&) const", typeof(Plasma.DataEngine), typeof(string), engine);
        }
        /// <remarks>
        /// </remarks>        <return> absolute path to the main script file for this plasmoid
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("mainScript() const")]
        protected override string MainScript() {
            return (string) interceptor.Invoke("mainScript", "mainScript() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the Package associated with this plasmoid which can
        ///          be used to request resources, such as images and
        ///          interface files.
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("package() const")]
        protected override Plasma.Package Package() {
            return (Plasma.Package) interceptor.Invoke("package", "package() const", typeof(Plasma.Package));
        }
        /// <remarks>
        ///  Note that the dialog returned is set to delete on close.
        ///      </remarks>        <return> a standard Plasma applet configuration dialog, ready
        ///  to have pages added to it.
        /// </return>
        ///         <short>   </short>
        protected KConfigDialog StandardConfigurationDialog() {
            return (KConfigDialog) interceptor.Invoke("standardConfigurationDialog", "standardConfigurationDialog()", typeof(KConfigDialog));
        }
        ~AppletScript() {
            interceptor.Invoke("~AppletScript", "~AppletScript()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~AppletScript", "~AppletScript()", typeof(void));
        }
        protected new IAppletScriptSignals Emit {
            get { return (IAppletScriptSignals) Q_EMIT; }
        }
    }

    public interface IAppletScriptSignals : Plasma.IScriptEngineSignals {
    }
}
