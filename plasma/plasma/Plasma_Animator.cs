//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
	using Plasma;
	using System;
	using Kimono;
	using Qyoto;
	/// <remarks>
	/// </remarks>		<short> A system for applying effects to Plasma elements.</short>
	[SmokeClass("Plasma::Animator")]
	public class Animator : QObject {
 		protected Animator(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Animator), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static Animator() {
			staticInterceptor = new SmokeInvocation(typeof(Animator), null);
		}
		public enum Animation {
			AppearAnimation = 0,
			DisappearAnimation = 1,
			ActivateAnimation = 2,
		}
		public enum CurveShape {
			EaseInCurve = 0,
			EaseOutCurve = 1,
			EaseInOutCurve = 2,
			LinearCurve = 3,
		}
		public enum Movement {
			SlideInMovement = 0,
			SlideOutMovement = 1,
			FastSlideInMovement = 2,
			FastSlideOutMovement = 3,
		}
		/// <remarks>
		///  Starts a standard animation on a QGraphicsItem.
		///  @arg item the item to animate in some fashion
		///  @arg anim the the type of animation to perform
		/// </remarks>		<return> the id of the animation
		/// </return>
		/// 		<short>    Starts a standard animation on a QGraphicsItem.</short>
		public int AnimateItem(QGraphicsItem item, Plasma.Animator.Animation anim) {
			return (int) interceptor.Invoke("animateItem#$", "animateItem(QGraphicsItem*, Plasma::Animator::Animation)", typeof(int), typeof(QGraphicsItem), item, typeof(Plasma.Animator.Animation), anim);
		}
		/// <remarks>
		///  Stops an item animation before the animation is complete.
		///  Note that it is not necessary to call
		///  this on normal completion of the animation.
		///  @arg id the id of the animation as returned by animateItem
		///      </remarks>		<short>    Stops an item animation before the animation is complete.</short>
		public void StopItemAnimation(int id) {
			interceptor.Invoke("stopItemAnimation$", "stopItemAnimation(int)", typeof(void), typeof(int), id);
		}
		/// <remarks>
		///  Starts a standard animation on a QGraphicsItem.
		///  @arg item the item to animate in some fashion
		///  @arg anim the the type of animation to perform
		/// </remarks>		<return> the id of the animation
		/// </return>
		/// 		<short>    Starts a standard animation on a QGraphicsItem.</short>
		public int MoveItem(QGraphicsItem item, Plasma.Animator.Movement movement, QPoint destination) {
			return (int) interceptor.Invoke("moveItem#$#", "moveItem(QGraphicsItem*, Plasma::Animator::Movement, const QPoint&)", typeof(int), typeof(QGraphicsItem), item, typeof(Plasma.Animator.Movement), movement, typeof(QPoint), destination);
		}
		/// <remarks>
		///  Stops an item movement before the animation is complete.
		///  Note that it is not necessary to call
		///  this on normal completion of the animation.
		///  @arg id the id of the animation as returned by moveItem
		///      </remarks>		<short>    Stops an item movement before the animation is complete.</short>
		public void StopItemMovement(int id) {
			interceptor.Invoke("stopItemMovement$", "stopItemMovement(int)", typeof(void), typeof(int), id);
		}
		/// <remarks>
		///  Starts a custom animation, preventing the need to create a timeline
		///  with its own timer tick.
		///  @arg frames the number of frames this animation should persist for
		///  @arg duration the length, in milliseconds, the animation will take
		///  @arg curve the curve applied to the frame rate
		///  @arg receive the object that will handle the actual animation
		///  @arg method the method name of slot to be invoked on each update.
		///              It must take a qreal. So if the slot is animate(qreal),
		///              pass in "animate" as the method parameter.
		///              It has an optional integer paramenter that takes an
		///              integer that reapresents the animation id, useful if
		///              you want to manage multiple animations with a sigle slot
		/// </remarks>		<return> an id that can be used to identify this animation.
		///      </return>
		/// 		<short>    Starts a custom animation, preventing the need to create a timeline  with its own timer tick.</short>
		public int CustomAnimation(int frames, int duration, Plasma.Animator.CurveShape curve, QObject receiver, string method) {
			return (int) interceptor.Invoke("customAnimation$$$#$", "customAnimation(int, int, Plasma::Animator::CurveShape, QObject*, const char*)", typeof(int), typeof(int), frames, typeof(int), duration, typeof(Plasma.Animator.CurveShape), curve, typeof(QObject), receiver, typeof(string), method);
		}
		/// <remarks>
		///  Stops a custom animation. Note that it is not necessary to call
		///  this on object destruction, as custom animations associated with
		///  a given QObject are cleaned up automatically on QObject destruction.
		///  @arg id the id of the animation as returned by customAnimation
		///      </remarks>		<short>    Stops a custom animation.</short>
		public void StopCustomAnimation(int id) {
			interceptor.Invoke("stopCustomAnimation$", "stopCustomAnimation(int)", typeof(void), typeof(int), id);
		}
		public int AnimateElement(QGraphicsItem arg1, Plasma.Animator.Animation arg2) {
			return (int) interceptor.Invoke("animateElement#$", "animateElement(QGraphicsItem*, Plasma::Animator::Animation)", typeof(int), typeof(QGraphicsItem), arg1, typeof(Plasma.Animator.Animation), arg2);
		}
		public void StopElementAnimation(int id) {
			interceptor.Invoke("stopElementAnimation$", "stopElementAnimation(int)", typeof(void), typeof(int), id);
		}
		public void SetInitialPixmap(int id, QPixmap pixmap) {
			interceptor.Invoke("setInitialPixmap$#", "setInitialPixmap(int, const QPixmap&)", typeof(void), typeof(int), id, typeof(QPixmap), pixmap);
		}
		public QPixmap CurrentPixmap(int id) {
			return (QPixmap) interceptor.Invoke("currentPixmap$", "currentPixmap(int)", typeof(QPixmap), typeof(int), id);
		}
		/// <remarks>
		///  Can be used to query if there are other animations happening. This way
		///  heavy operations can be delayed until all animations are finished.
		/// </remarks>		<return> true if there are animations going on.
		/// </return>
		/// 		<short>    Can be used to query if there are other animations happening.</short>
		public bool IsAnimating() {
			return (bool) interceptor.Invoke("isAnimating", "isAnimating() const", typeof(bool));
		}
		/// <remarks>
		///  Singleton accessor
		/// </remarks>		<short>    Singleton accessor </short>
		public static Plasma.Animator Self() {
			return (Plasma.Animator) staticInterceptor.Invoke("self", "self()", typeof(Plasma.Animator));
		}
		protected new IAnimatorSignals Emit {
			get { return (IAnimatorSignals) Q_EMIT; }
		}
	}

	public interface IAnimatorSignals : IQObjectSignals {
	}
}
