//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
	using Plasma;
	using System;
	using Kimono;
	using Qyoto;
	[SmokeClass("Plasma::QueryMatch")]
	public class QueryMatch : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected QueryMatch(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QueryMatch), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QueryMatch() {
			staticInterceptor = new SmokeInvocation(typeof(QueryMatch), null);
		}
		/// <remarks>
		///  The type of match. Value is important here as it is used for sorting
		///          </remarks>		<short>    The type of match.</short>
		public enum TypeOf {
			NoMatch = 0,
			CompletionMatch = 10,
			PossibleMatch = 30,
			InformationalMatch = 50,
			HelperMatch = 70,
			ExactMatch = 100,
		}
		/// <remarks>
		///  Constructs a PossibleMatch associated with a given RunnerContext
		///  and runner.
		///  @arg search the RunnerContext this match belongs to
		///  @arg runner the runner this match belongs to
		///          </remarks>		<short>    Constructs a PossibleMatch associated with a given RunnerContext  and runner.</short>
		public QueryMatch(Plasma.AbstractRunner runner) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QueryMatch#", "QueryMatch(Plasma::AbstractRunner*)", typeof(void), typeof(Plasma.AbstractRunner), runner);
		}
		/// <remarks>
		///  Copy constructor
		///          </remarks>		<short>    Copy constructor          </short>
		public QueryMatch(Plasma.QueryMatch other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QueryMatch#", "QueryMatch(const Plasma::QueryMatch&)", typeof(void), typeof(Plasma.QueryMatch), other);
		}
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Sets the type of match this action represents.
		///          </remarks>		<short>    Sets the type of match this action represents.</short>
		public void SetType(Plasma.QueryMatch.TypeOf type) {
			interceptor.Invoke("setType$", "setType(Plasma::QueryMatch::Type)", typeof(void), typeof(Plasma.QueryMatch.TypeOf), type);
		}
		/// <remarks>
		///  The type of action this is. Defaults to PossibleMatch.
		///          </remarks>		<short>    The type of action this is.</short>
		public Plasma.QueryMatch.TypeOf type() {
			return (Plasma.QueryMatch.TypeOf) interceptor.Invoke("type", "type() const", typeof(Plasma.QueryMatch.TypeOf));
		}
		/// <remarks>
		///  Sets the relevance of this action for the search
		///  it was created for.
		/// <param> name="relevance" a number between 0 and 1.
		///          </param></remarks>		<short>    Sets the relevance of this action for the search  it was created for.</short>
		public void SetRelevance(double relevance) {
			interceptor.Invoke("setRelevance$", "setRelevance(qreal)", typeof(void), typeof(double), relevance);
		}
		/// <remarks>
		///  The relevance of this action to the search. By default,
		///  the relevance is 1.
		/// </remarks>		<return> a number between 0 and 1
		///          </return>
		/// 		<short>    The relevance of this action to the search.</short>
		public double Relevance() {
			return (double) interceptor.Invoke("relevance", "relevance() const", typeof(double));
		}
		/// <remarks>
		///  The runner associated with this action
		///          </remarks>		<short>    The runner associated with this action          </short>
		public Plasma.AbstractRunner Runner() {
			return (Plasma.AbstractRunner) interceptor.Invoke("runner", "runner() const", typeof(Plasma.AbstractRunner));
		}
		/// <remarks>
		///  A string that can be used as an ID for this match,
		///  even between different queries. It is based in part
		///  on the source of the match (the AbstractRunner) and
		///  distinguishing information provided by the runner,
		///  ensuring global uniqueness as well as consistency
		///  between query matches.
		///          </remarks>		<short>    A string that can be used as an ID for this match,  even between different queries.</short>
		public string Id() {
			return (string) interceptor.Invoke("id", "id() const", typeof(string));
		}
		public string Text() {
			return (string) interceptor.Invoke("text", "text() const", typeof(string));
		}
		public string Subtext() {
			return (string) interceptor.Invoke("subtext", "subtext() const", typeof(string));
		}
		public QVariant Data() {
			return (QVariant) interceptor.Invoke("data", "data() const", typeof(QVariant));
		}
		public QIcon Icon() {
			return (QIcon) interceptor.Invoke("icon", "icon() const", typeof(QIcon));
		}
		public bool IsEnabled() {
			return (bool) interceptor.Invoke("isEnabled", "isEnabled() const", typeof(bool));
		}
		/// <remarks>
		///  Requests this match to activae using the given context
		/// <param> name="context" the context to use in conjunction with this run
		///          </param></remarks>		<short>    Requests this match to activae using the given context </short>
		public void Run(Plasma.RunnerContext context) {
			interceptor.Invoke("run#", "run(const Plasma::RunnerContext&) const", typeof(void), typeof(Plasma.RunnerContext), context);
		}
		/// <remarks>
		///  Sets data to be used internally by the associated
		///  AbstractRunner.
		///  When set, it is also used to form
		///  part of the id() for this match. If that is innapropriate
		///  as an id, the runner may generate its own id and set that
		///  with setId(string) directly after calling setData
		///          </remarks>		<short>    Sets data to be used internally by the associated  AbstractRunner.</short>
		public void SetData(QVariant data) {
			interceptor.Invoke("setData#", "setData(const QVariant&)", typeof(void), typeof(QVariant), data);
		}
		/// <remarks>
		///  Sets the id for this match; useful if the id does not
		///  match data().toString(). The id must be unique to all
		///  matches from this runner, and should remain constant
		///  for the same query for best results.
		/// <param> name="id" the new identifying string to use to refer
		///            to this entry
		///          </param></remarks>		<short>    Sets the id for this match; useful if the id does not  match data().</short>
		public void SetId(string id) {
			interceptor.Invoke("setId$", "setId(const QString&)", typeof(void), typeof(string), id);
		}
		public void SetText(string text) {
			interceptor.Invoke("setText$", "setText(const QString&)", typeof(void), typeof(string), text);
		}
		public void SetSubtext(string text) {
			interceptor.Invoke("setSubtext$", "setSubtext(const QString&)", typeof(void), typeof(string), text);
		}
		public void SetIcon(QIcon icon) {
			interceptor.Invoke("setIcon#", "setIcon(const QIcon&)", typeof(void), typeof(QIcon), icon);
		}
		public void SetEnabled(bool enable) {
			interceptor.Invoke("setEnabled$", "setEnabled(bool)", typeof(void), typeof(bool), enable);
		}
		~QueryMatch() {
			interceptor.Invoke("~QueryMatch", "~QueryMatch()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~QueryMatch", "~QueryMatch()", typeof(void));
		}
		public static bool operator<(QueryMatch lhs, Plasma.QueryMatch other) {
			return (bool) staticInterceptor.Invoke("operator<#", "operator<(const Plasma::QueryMatch&) const", typeof(bool), typeof(QueryMatch), lhs, typeof(Plasma.QueryMatch), other);
		}
		public static bool operator>(QueryMatch lhs, Plasma.QueryMatch other) {
			return !(bool) staticInterceptor.Invoke("operator<#", "operator<(const Plasma::QueryMatch&) const", typeof(bool), typeof(QueryMatch), lhs, typeof(Plasma.QueryMatch), other)
						&& !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Plasma::QueryMatch&) const", typeof(bool), typeof(QueryMatch), lhs, typeof(Plasma.QueryMatch), other);
		}
	}
}
